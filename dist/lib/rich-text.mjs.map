{"version":3,"sources":["../../src/lib/rich-text.ts"],"sourcesContent":["/**\n * Rich text conversion utilities for CMS adapters.\n * Converts markdown to Prismic, Contentful, and Sanity rich text formats.\n */\n\nimport { marked, type Token, type Tokens } from 'marked'\n\n// =============================================================================\n// Prismic Rich Text\n// =============================================================================\n\nexport interface PrismicSpan {\n  type: 'strong' | 'em' | 'hyperlink'\n  start: number\n  end: number\n  data?: { url: string }\n}\n\nexport interface PrismicRichTextNode {\n  type: string\n  text?: string\n  spans?: PrismicSpan[]\n  items?: PrismicRichTextNode[]\n  alt?: string\n  url?: string\n  dimensions?: { width: number; height: number }\n}\n\n/**\n * Convert markdown to Prismic rich text format.\n * @see https://prismic.io/docs/rich-text\n */\nexport function markdownToPrismicRichText(markdown: string): PrismicRichTextNode[] {\n  const tokens = marked.lexer(markdown)\n  const result: PrismicRichTextNode[] = []\n\n  function processInlineTokens(tokens: Token[]): { text: string; spans: PrismicSpan[] } {\n    let text = ''\n    const spans: PrismicSpan[] = []\n\n    for (const token of tokens) {\n      if (token.type === 'text') {\n        text += token.text\n      } else if (token.type === 'strong') {\n        const start = text.length\n        const inner = processInlineTokens(token.tokens || [])\n        text += inner.text\n        spans.push({ type: 'strong', start, end: text.length })\n        spans.push(...inner.spans.map((s) => ({ ...s, start: s.start + start, end: s.end + start })))\n      } else if (token.type === 'em') {\n        const start = text.length\n        const inner = processInlineTokens(token.tokens || [])\n        text += inner.text\n        spans.push({ type: 'em', start, end: text.length })\n        spans.push(...inner.spans.map((s) => ({ ...s, start: s.start + start, end: s.end + start })))\n      } else if (token.type === 'link') {\n        const start = text.length\n        const inner = processInlineTokens(token.tokens || [])\n        text += inner.text\n        spans.push({ type: 'hyperlink', start, end: text.length, data: { url: token.href } })\n        spans.push(...inner.spans.map((s) => ({ ...s, start: s.start + start, end: s.end + start })))\n      } else if (token.type === 'codespan') {\n        text += token.text\n      } else if (token.type === 'br') {\n        text += '\\n'\n      }\n    }\n\n    return { text, spans }\n  }\n\n  for (const token of tokens) {\n    if (token.type === 'heading') {\n      const { text, spans } = processInlineTokens(token.tokens || [])\n      result.push({\n        type: `heading${token.depth}`,\n        text,\n        spans,\n      })\n    } else if (token.type === 'paragraph') {\n      const { text, spans } = processInlineTokens(token.tokens || [])\n      result.push({\n        type: 'paragraph',\n        text,\n        spans,\n      })\n    } else if (token.type === 'list') {\n      const listType = token.ordered ? 'o-list-item' : 'list-item'\n      for (const item of token.items) {\n        const { text, spans } = processInlineTokens(item.tokens || [])\n        result.push({\n          type: listType,\n          text,\n          spans,\n        })\n      }\n    } else if (token.type === 'blockquote') {\n      // Flatten blockquote content\n      for (const child of token.tokens || []) {\n        if (child.type === 'paragraph') {\n          const { text, spans } = processInlineTokens((child as Tokens.Paragraph).tokens || [])\n          result.push({\n            type: 'preformatted',\n            text,\n            spans,\n          })\n        }\n      }\n    } else if (token.type === 'code') {\n      result.push({\n        type: 'preformatted',\n        text: token.text,\n        spans: [],\n      })\n    } else if (token.type === 'image') {\n      result.push({\n        type: 'image',\n        url: token.href,\n        alt: token.text || '',\n      })\n    } else if (token.type === 'hr') {\n      // Prismic doesn't have a native HR, skip or add empty paragraph\n    }\n  }\n\n  return result\n}\n\n// =============================================================================\n// Contentful Rich Text\n// =============================================================================\n\nexport interface ContentfulNode {\n  nodeType: string\n  content?: ContentfulNode[]\n  value?: string\n  data?: Record<string, unknown>\n  marks?: Array<{ type: string }>\n}\n\nexport interface ContentfulDocument {\n  nodeType: 'document'\n  data: Record<string, unknown>\n  content: ContentfulNode[]\n}\n\n/**\n * Convert markdown to Contentful rich text format.\n * @see https://www.contentful.com/developers/docs/concepts/rich-text/\n */\nexport function markdownToContentfulRichText(markdown: string): ContentfulDocument {\n  const tokens = marked.lexer(markdown)\n  const content: ContentfulNode[] = []\n\n  function processInlineTokens(tokens: Token[]): ContentfulNode[] {\n    const nodes: ContentfulNode[] = []\n\n    for (const token of tokens) {\n      if (token.type === 'text') {\n        nodes.push({\n          nodeType: 'text',\n          value: token.text,\n          marks: [],\n          data: {},\n        })\n      } else if (token.type === 'strong') {\n        const inner = processInlineTokens(token.tokens || [])\n        for (const node of inner) {\n          if (node.nodeType === 'text') {\n            node.marks = [...(node.marks || []), { type: 'bold' }]\n          }\n          nodes.push(node)\n        }\n      } else if (token.type === 'em') {\n        const inner = processInlineTokens(token.tokens || [])\n        for (const node of inner) {\n          if (node.nodeType === 'text') {\n            node.marks = [...(node.marks || []), { type: 'italic' }]\n          }\n          nodes.push(node)\n        }\n      } else if (token.type === 'link') {\n        nodes.push({\n          nodeType: 'hyperlink',\n          content: processInlineTokens(token.tokens || []),\n          data: { uri: token.href },\n        })\n      } else if (token.type === 'codespan') {\n        nodes.push({\n          nodeType: 'text',\n          value: token.text,\n          marks: [{ type: 'code' }],\n          data: {},\n        })\n      } else if (token.type === 'br') {\n        nodes.push({\n          nodeType: 'text',\n          value: '\\n',\n          marks: [],\n          data: {},\n        })\n      }\n    }\n\n    return nodes\n  }\n\n  for (const token of tokens) {\n    if (token.type === 'heading') {\n      content.push({\n        nodeType: `heading-${token.depth}`,\n        content: processInlineTokens(token.tokens || []),\n        data: {},\n      })\n    } else if (token.type === 'paragraph') {\n      content.push({\n        nodeType: 'paragraph',\n        content: processInlineTokens(token.tokens || []),\n        data: {},\n      })\n    } else if (token.type === 'list') {\n      const listType = token.ordered ? 'ordered-list' : 'unordered-list'\n      content.push({\n        nodeType: listType,\n        content: token.items.map((item: Tokens.ListItem) => ({\n          nodeType: 'list-item',\n          content: [\n            {\n              nodeType: 'paragraph',\n              content: processInlineTokens(item.tokens || []),\n              data: {},\n            },\n          ],\n          data: {},\n        })),\n        data: {},\n      })\n    } else if (token.type === 'blockquote') {\n      content.push({\n        nodeType: 'blockquote',\n        content: (token.tokens || [])\n          .filter((t): t is Tokens.Paragraph => t.type === 'paragraph')\n          .map((t) => ({\n            nodeType: 'paragraph',\n            content: processInlineTokens(t.tokens || []),\n            data: {},\n          })),\n        data: {},\n      })\n    } else if (token.type === 'code') {\n      // Contentful doesn't have a native code block, use paragraph with code marks\n      content.push({\n        nodeType: 'paragraph',\n        content: [\n          {\n            nodeType: 'text',\n            value: token.text,\n            marks: [{ type: 'code' }],\n            data: {},\n          },\n        ],\n        data: {},\n      })\n    } else if (token.type === 'hr') {\n      content.push({\n        nodeType: 'hr',\n        content: [],\n        data: {},\n      })\n    }\n    // Note: Contentful images require asset references, not inline URLs\n  }\n\n  return {\n    nodeType: 'document',\n    data: {},\n    content,\n  }\n}\n\n// =============================================================================\n// Sanity Portable Text\n// =============================================================================\n\nexport interface PortableTextSpan {\n  _type: 'span'\n  _key: string\n  text: string\n  marks?: string[]\n}\n\nexport interface PortableTextBlock {\n  _type: 'block'\n  _key: string\n  style: string\n  markDefs?: Array<{ _type: string; _key: string; href?: string }>\n  children: PortableTextSpan[]\n  listItem?: 'bullet' | 'number'\n  level?: number\n}\n\nexport type PortableTextNode = PortableTextBlock | { _type: 'image'; _key: string; asset: { url: string }; alt?: string }\n\nlet keyCounter = 0\nfunction generateKey(): string {\n  return `k${++keyCounter}`\n}\n\n/**\n * Convert markdown to Sanity Portable Text format.\n * @see https://www.sanity.io/docs/block-content\n */\nexport function markdownToPortableText(markdown: string): PortableTextNode[] {\n  keyCounter = 0 // Reset for consistent output\n  const tokens = marked.lexer(markdown)\n  const result: PortableTextNode[] = []\n\n  function processInlineTokens(\n    tokens: Token[],\n    markDefs: PortableTextBlock['markDefs']\n  ): PortableTextSpan[] {\n    const spans: PortableTextSpan[] = []\n\n    for (const token of tokens) {\n      if (token.type === 'text') {\n        spans.push({\n          _type: 'span',\n          _key: generateKey(),\n          text: token.text,\n          marks: [],\n        })\n      } else if (token.type === 'strong') {\n        const inner = processInlineTokens(token.tokens || [], markDefs)\n        for (const span of inner) {\n          span.marks = [...(span.marks || []), 'strong']\n        }\n        spans.push(...inner)\n      } else if (token.type === 'em') {\n        const inner = processInlineTokens(token.tokens || [], markDefs)\n        for (const span of inner) {\n          span.marks = [...(span.marks || []), 'em']\n        }\n        spans.push(...inner)\n      } else if (token.type === 'link') {\n        const linkKey = generateKey()\n        markDefs?.push({ _type: 'link', _key: linkKey, href: token.href })\n        const inner = processInlineTokens(token.tokens || [], markDefs)\n        for (const span of inner) {\n          span.marks = [...(span.marks || []), linkKey]\n        }\n        spans.push(...inner)\n      } else if (token.type === 'codespan') {\n        spans.push({\n          _type: 'span',\n          _key: generateKey(),\n          text: token.text,\n          marks: ['code'],\n        })\n      } else if (token.type === 'br') {\n        spans.push({\n          _type: 'span',\n          _key: generateKey(),\n          text: '\\n',\n          marks: [],\n        })\n      }\n    }\n\n    return spans\n  }\n\n  function getStyle(token: Token): string {\n    if (token.type === 'heading') {\n      return `h${token.depth}`\n    }\n    if (token.type === 'blockquote') {\n      return 'blockquote'\n    }\n    return 'normal'\n  }\n\n  for (const token of tokens) {\n    if (token.type === 'heading' || token.type === 'paragraph') {\n      const markDefs: PortableTextBlock['markDefs'] = []\n      const children = processInlineTokens(token.tokens || [], markDefs)\n      result.push({\n        _type: 'block',\n        _key: generateKey(),\n        style: getStyle(token),\n        markDefs,\n        children: children.length ? children : [{ _type: 'span', _key: generateKey(), text: '', marks: [] }],\n      })\n    } else if (token.type === 'list') {\n      const listItem = token.ordered ? 'number' : 'bullet'\n      for (const item of token.items) {\n        const markDefs: PortableTextBlock['markDefs'] = []\n        const children = processInlineTokens(item.tokens || [], markDefs)\n        result.push({\n          _type: 'block',\n          _key: generateKey(),\n          style: 'normal',\n          listItem,\n          level: 1,\n          markDefs,\n          children: children.length ? children : [{ _type: 'span', _key: generateKey(), text: '', marks: [] }],\n        })\n      }\n    } else if (token.type === 'blockquote') {\n      for (const child of token.tokens || []) {\n        if (child.type === 'paragraph') {\n          const markDefs: PortableTextBlock['markDefs'] = []\n          const children = processInlineTokens((child as Tokens.Paragraph).tokens || [], markDefs)\n          result.push({\n            _type: 'block',\n            _key: generateKey(),\n            style: 'blockquote',\n            markDefs,\n            children: children.length ? children : [{ _type: 'span', _key: generateKey(), text: '', marks: [] }],\n          })\n        }\n      }\n    } else if (token.type === 'code') {\n      result.push({\n        _type: 'block',\n        _key: generateKey(),\n        style: 'normal',\n        markDefs: [],\n        children: [\n          {\n            _type: 'span',\n            _key: generateKey(),\n            text: token.text,\n            marks: ['code'],\n          },\n        ],\n      })\n    } else if (token.type === 'image') {\n      result.push({\n        _type: 'image',\n        _key: generateKey(),\n        asset: { url: token.href },\n        alt: token.text || undefined,\n      })\n    }\n  }\n\n  return result\n}\n"],"mappings":"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","names":["tokens"]}
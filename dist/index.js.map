{"version":3,"sources":["../node_modules/@prismicio/client/src/types/value/richText.ts","../node_modules/@prismicio/client/src/helpers/mapSliceZone.ts","../node_modules/@prismicio/client/src/filter.ts","../node_modules/@prismicio/client/dist/_virtual/rolldown_runtime.js","../node_modules/@prismicio/client/src/cookie.ts","../node_modules/@prismicio/client/src/errors.ts","../node_modules/@prismicio/client/src/types/value/link.ts","../node_modules/@prismicio/client/src/helpers/documentToLinkField.ts","../node_modules/@prismicio/client/src/helpers/asLink.ts","../node_modules/@prismicio/client/package.json","../node_modules/@prismicio/client/src/lib/devMsg.ts","../node_modules/@prismicio/client/src/buildQueryURL.ts","../node_modules/@prismicio/client/src/isRepositoryName.ts","../node_modules/@prismicio/client/src/getRepositoryEndpoint.ts","../node_modules/@prismicio/client/src/getRepositoryName.ts","../node_modules/@prismicio/client/src/isRepositoryEndpoint.ts","../node_modules/@prismicio/client/src/lib/getPreviewCookie.ts","../node_modules/@prismicio/client/src/lib/pLimit.ts","../node_modules/@prismicio/client/src/lib/request.ts","../node_modules/@prismicio/client/src/lib/throttledWarn.ts","../node_modules/@prismicio/client/src/Client.ts","../node_modules/@prismicio/client/src/createClient.ts","../node_modules/@prismicio/client/src/types/migration/Asset.ts","../node_modules/@prismicio/client/src/types/migration/Document.ts","../node_modules/@prismicio/client/src/helpers/isFilled.ts","../node_modules/@prismicio/client/src/lib/isValue.ts","../node_modules/@prismicio/client/src/lib/isMigrationValue.ts","../node_modules/@prismicio/client/src/lib/getOptionalLinkProperties.ts","../node_modules/@prismicio/client/src/lib/resolveMigrationDocumentData.ts","../node_modules/@prismicio/client/src/WriteClient.ts","../node_modules/@prismicio/client/src/createWriteClient.ts","../node_modules/@prismicio/client/src/lib/validateAssetMetadata.ts","../node_modules/@prismicio/client/src/Migration.ts","../node_modules/@prismicio/client/src/createMigration.ts","../node_modules/@prismicio/client/src/getGraphQLEndpoint.ts","../node_modules/@prismicio/client/src/getToolbarSrc.ts","../node_modules/@prismicio/client/src/helpers/asDate.ts","../node_modules/@prismicio/client/src/lib/isInternalURL.ts","../node_modules/@prismicio/client/src/helpers/asLinkAttrs.ts","../node_modules/@prismicio/client/src/richtext/asText.ts","../node_modules/@prismicio/client/src/helpers/asText.ts","../node_modules/@prismicio/client/src/lib/escapeHTML.ts","../node_modules/@prismicio/client/src/lib/serializerHelpers.ts","../node_modules/@prismicio/client/src/richtext/asTree.ts","../node_modules/@prismicio/client/src/richtext/serialize.ts","../node_modules/@prismicio/client/src/richtext/types.ts","../node_modules/@prismicio/client/src/richtext/wrapMapSerializer.ts","../node_modules/@prismicio/client/src/richtext/composeSerializers.ts","../node_modules/@prismicio/client/src/helpers/asHTML.ts","../node_modules/src/buildURL.ts","../node_modules/src/buildPixelDensitySrcSet.ts","../node_modules/src/buildWidthSrcSet.ts","../node_modules/imgix-url-builder/dist/index.js","../node_modules/@prismicio/client/src/helpers/asImageSrc.ts","../node_modules/@prismicio/client/src/helpers/asImageWidthSrcSet.ts","../node_modules/@prismicio/client/src/helpers/asImagePixelDensitySrcSet.ts","../node_modules/@prismicio/client/src/types/value/embed.ts","../node_modules/@prismicio/client/src/types/model/types.ts","../node_modules/@prismicio/client/src/types/model/link.ts","../node_modules/@prismicio/client/src/types/model/sliceZone.ts","../node_modules/@prismicio/client/src/types/model/slice.ts","../node_modules/@prismicio/client/src/types/webhook/types.ts","../node_modules/@prismicio/client/src/index.ts","../src/ai/prompts/types.ts","../src/ai/prompts/templates/generate.ts","../src/ai/prompts/templates/chat.ts","../src/ai/prompts/templates/rewrite.ts","../src/ai/prompts/templates/auto-draft.ts","../src/ai/prompts/templates/plan.ts","../src/ai/prompts/templates/agent.ts","../src/ai/prompts/templates/ask.ts","../src/ai/prompts/templates/expand-plan.ts","../src/ai/prompts/templates/search.ts","../src/ai/prompts/builders.ts","../src/ai/prompts/index.ts","../src/ai/models.ts","../src/ai/provider.ts","../src/ai/builders.ts","../src/lib/url-extractor.ts","../src/ai/generate.ts","../src/ai/chat.ts","../src/index.ts","../src/types/models.ts","../src/destinations/prismic.ts","../src/data/posts.ts","../src/data/comments.ts","../src/data/factory.ts","../src/data/tags.ts","../src/data/revisions.ts","../src/data/ai-settings.ts","../src/data/topics.ts","../src/data/news-items.ts","../src/data/users.ts","../src/api/posts.ts","../src/api/utils.ts","../src/api/comments.ts","../src/api/tags.ts","../src/api/ai.ts","../src/api/upload.ts","../src/api/topics.ts","../src/api/users.ts","../src/api/admin.ts","../src/api/settings.ts","../src/api/revisions.ts","../src/api/chat-history.ts","../src/api/index.ts","../src/auto-draft/rss.ts","../src/auto-draft/keywords.ts","../src/ai/index.ts","../src/ai/parse.ts","../src/lib/markdown.ts","../src/auto-draft/runner.ts","../src/destinations/dispatcher.ts","../src/lib/storage.ts","../src/types/config.ts","../src/server.ts","../src/schema.ts","../src/lib/format.ts","../src/lib/seo.ts","../src/lib/comments.ts","../node_modules/@tiptap/core/src/helpers/createChainableState.ts","../node_modules/@tiptap/core/src/CommandManager.ts","../node_modules/@tiptap/core/src/commands/index.ts","../node_modules/@tiptap/core/src/commands/blur.ts","../node_modules/@tiptap/core/src/commands/clearContent.ts","../node_modules/@tiptap/core/src/commands/clearNodes.ts","../node_modules/@tiptap/core/src/commands/command.ts","../node_modules/@tiptap/core/src/commands/createParagraphNear.ts","../node_modules/@tiptap/core/src/commands/cut.ts","../node_modules/@tiptap/core/src/commands/deleteCurrentNode.ts","../node_modules/@tiptap/core/src/helpers/getNodeType.ts","../node_modules/@tiptap/core/src/commands/deleteNode.ts","../node_modules/@tiptap/core/src/commands/deleteRange.ts","../node_modules/@tiptap/core/src/commands/deleteSelection.ts","../node_modules/@tiptap/core/src/commands/enter.ts","../node_modules/@tiptap/core/src/commands/exitCode.ts","../node_modules/@tiptap/core/src/commands/extendMarkRange.ts","../node_modules/@tiptap/core/src/utilities/isRegExp.ts","../node_modules/@tiptap/core/src/utilities/objectIncludes.ts","../node_modules/@tiptap/core/src/helpers/getMarkRange.ts","../node_modules/@tiptap/core/src/helpers/getMarkType.ts","../node_modules/@tiptap/core/src/commands/first.ts","../node_modules/@tiptap/core/src/helpers/isTextSelection.ts","../node_modules/@tiptap/core/src/helpers/resolveFocusPosition.ts","../node_modules/@tiptap/core/src/utilities/minMax.ts","../node_modules/@tiptap/core/src/utilities/isAndroid.ts","../node_modules/@tiptap/core/src/utilities/isiOS.ts","../node_modules/@tiptap/core/src/utilities/isSafari.ts","../node_modules/@tiptap/core/src/commands/focus.ts","../node_modules/@tiptap/core/src/commands/forEach.ts","../node_modules/@tiptap/core/src/commands/insertContent.ts","../node_modules/@tiptap/core/src/commands/insertContentAt.ts","../node_modules/@tiptap/core/src/helpers/createNodeFromContent.ts","../node_modules/@tiptap/core/src/utilities/elementFromString.ts","../node_modules/@tiptap/core/src/helpers/selectionToInsertionEnd.ts","../node_modules/@tiptap/core/src/commands/join.ts","../node_modules/@tiptap/core/src/commands/joinItemBackward.ts","../node_modules/@tiptap/core/src/commands/joinItemForward.ts","../node_modules/@tiptap/core/src/commands/joinTextblockBackward.ts","../node_modules/@tiptap/core/src/commands/joinTextblockForward.ts","../node_modules/@tiptap/core/src/utilities/isMacOS.ts","../node_modules/@tiptap/core/src/commands/keyboardShortcut.ts","../node_modules/@tiptap/core/src/commands/lift.ts","../node_modules/@tiptap/core/src/helpers/isNodeActive.ts","../node_modules/@tiptap/core/src/commands/liftEmptyBlock.ts","../node_modules/@tiptap/core/src/commands/liftListItem.ts","../node_modules/@tiptap/core/src/commands/newlineInCode.ts","../node_modules/@tiptap/core/src/helpers/getSchemaTypeNameByName.ts","../node_modules/@tiptap/core/src/utilities/deleteProps.ts","../node_modules/@tiptap/core/src/commands/resetAttributes.ts","../node_modules/@tiptap/core/src/commands/scrollIntoView.ts","../node_modules/@tiptap/core/src/commands/selectAll.ts","../node_modules/@tiptap/core/src/commands/selectNodeBackward.ts","../node_modules/@tiptap/core/src/commands/selectNodeForward.ts","../node_modules/@tiptap/core/src/commands/selectParentNode.ts","../node_modules/@tiptap/core/src/commands/selectTextblockEnd.ts","../node_modules/@tiptap/core/src/commands/selectTextblockStart.ts","../node_modules/@tiptap/core/src/helpers/createDocument.ts","../node_modules/@tiptap/core/src/commands/setContent.ts","../node_modules/@tiptap/core/src/helpers/getMarkAttributes.ts","../node_modules/@tiptap/core/src/helpers/combineTransactionSteps.ts","../node_modules/@tiptap/core/src/helpers/defaultBlockAt.ts","../node_modules/@tiptap/core/src/helpers/findChildren.ts","../node_modules/@tiptap/core/src/helpers/findChildrenInRange.ts","../node_modules/@tiptap/core/src/helpers/findParentNodeClosestToPos.ts","../node_modules/@tiptap/core/src/helpers/findParentNode.ts","../node_modules/@tiptap/core/src/helpers/getExtensionField.ts","../node_modules/@tiptap/core/src/helpers/flattenExtensions.ts","../node_modules/@tiptap/core/src/helpers/generateHTML.ts","../node_modules/@tiptap/core/src/helpers/getHTMLFromFragment.ts","../node_modules/@tiptap/core/src/helpers/getSchemaByResolvedExtensions.ts","../node_modules/@tiptap/core/src/utilities/isFunction.ts","../node_modules/@tiptap/core/src/utilities/callOrReturn.ts","../node_modules/@tiptap/core/src/utilities/isEmptyObject.ts","../node_modules/@tiptap/core/src/helpers/splitExtensions.ts","../node_modules/@tiptap/core/src/helpers/getAttributesFromExtensions.ts","../node_modules/@tiptap/core/src/utilities/mergeAttributes.ts","../node_modules/@tiptap/core/src/helpers/getRenderedAttributes.ts","../node_modules/@tiptap/core/src/utilities/fromString.ts","../node_modules/@tiptap/core/src/helpers/injectExtensionAttributesToParseRule.ts","../node_modules/@tiptap/core/src/utilities/findDuplicates.ts","../node_modules/@tiptap/core/src/helpers/sortExtensions.ts","../node_modules/@tiptap/core/src/helpers/resolveExtensions.ts","../node_modules/@tiptap/core/src/helpers/getSchema.ts","../node_modules/@tiptap/core/src/helpers/generateJSON.ts","../node_modules/@tiptap/core/src/helpers/generateText.ts","../node_modules/@tiptap/core/src/helpers/getTextBetween.ts","../node_modules/@tiptap/core/src/helpers/getText.ts","../node_modules/@tiptap/core/src/helpers/getTextSerializersFromSchema.ts","../node_modules/@tiptap/core/src/helpers/getNodeAttributes.ts","../node_modules/@tiptap/core/src/helpers/getAttributes.ts","../node_modules/@tiptap/core/src/utilities/removeDuplicates.ts","../node_modules/@tiptap/core/src/helpers/getChangedRanges.ts","../node_modules/@tiptap/core/src/helpers/getDebugJSON.ts","../node_modules/@tiptap/core/src/helpers/getMarksBetween.ts","../node_modules/@tiptap/core/src/helpers/getNodeAtPosition.ts","../node_modules/@tiptap/core/src/helpers/getSchemaTypeByName.ts","../node_modules/@tiptap/core/src/helpers/getSplittedAttributes.ts","../node_modules/@tiptap/core/src/helpers/getTextContentFromNodes.ts","../node_modules/@tiptap/core/src/helpers/isMarkActive.ts","../node_modules/@tiptap/core/src/helpers/isActive.ts","../node_modules/@tiptap/core/src/helpers/isAtEndOfNode.ts","../node_modules/@tiptap/core/src/helpers/isAtStartOfNode.ts","../node_modules/@tiptap/core/src/helpers/isExtensionRulesEnabled.ts","../node_modules/@tiptap/core/src/helpers/isList.ts","../node_modules/@tiptap/core/src/helpers/isNodeEmpty.ts","../node_modules/@tiptap/core/src/helpers/isNodeSelection.ts","../node_modules/@tiptap/core/src/helpers/MappablePosition.ts","../node_modules/@tiptap/core/src/helpers/posToDOMRect.ts","../node_modules/@tiptap/core/src/helpers/rewriteUnknownContent.ts","../node_modules/@tiptap/core/src/commands/setMark.ts","../node_modules/@tiptap/core/src/commands/setMeta.ts","../node_modules/@tiptap/core/src/commands/setNode.ts","../node_modules/@tiptap/core/src/commands/setNodeSelection.ts","../node_modules/@tiptap/core/src/commands/setTextDirection.ts","../node_modules/@tiptap/core/src/commands/setTextSelection.ts","../node_modules/@tiptap/core/src/commands/sinkListItem.ts","../node_modules/@tiptap/core/src/commands/splitBlock.ts","../node_modules/@tiptap/core/src/commands/splitListItem.ts","../node_modules/@tiptap/core/src/commands/toggleList.ts","../node_modules/@tiptap/core/src/commands/toggleMark.ts","../node_modules/@tiptap/core/src/commands/toggleNode.ts","../node_modules/@tiptap/core/src/commands/toggleWrap.ts","../node_modules/@tiptap/core/src/commands/undoInputRule.ts","../node_modules/@tiptap/core/src/commands/unsetAllMarks.ts","../node_modules/@tiptap/core/src/commands/unsetMark.ts","../node_modules/@tiptap/core/src/commands/unsetTextDirection.ts","../node_modules/@tiptap/core/src/commands/updateAttributes.ts","../node_modules/@tiptap/core/src/commands/wrapIn.ts","../node_modules/@tiptap/core/src/commands/wrapInList.ts","../node_modules/@tiptap/core/src/Editor.ts","../node_modules/@tiptap/core/src/EventEmitter.ts","../node_modules/@tiptap/core/src/ExtensionManager.ts","../node_modules/@tiptap/core/src/InputRule.ts","../node_modules/@tiptap/core/src/utilities/isPlainObject.ts","../node_modules/@tiptap/core/src/utilities/mergeDeep.ts","../node_modules/@tiptap/core/src/Extendable.ts","../node_modules/@tiptap/core/src/Mark.ts","../node_modules/@tiptap/core/src/PasteRule.ts","../node_modules/@tiptap/core/src/utilities/isNumber.ts","../node_modules/@tiptap/core/src/extensions/index.ts","../node_modules/@tiptap/core/src/extensions/clipboardTextSerializer.ts","../node_modules/@tiptap/core/src/Extension.ts","../node_modules/@tiptap/core/src/extensions/commands.ts","../node_modules/@tiptap/core/src/extensions/delete.ts","../node_modules/@tiptap/core/src/extensions/drop.ts","../node_modules/@tiptap/core/src/extensions/editable.ts","../node_modules/@tiptap/core/src/extensions/focusEvents.ts","../node_modules/@tiptap/core/src/extensions/keymap.ts","../node_modules/@tiptap/core/src/extensions/paste.ts","../node_modules/@tiptap/core/src/extensions/tabindex.ts","../node_modules/@tiptap/core/src/extensions/textDirection.ts","../node_modules/@tiptap/core/src/NodePos.ts","../node_modules/@tiptap/core/src/style.ts","../node_modules/@tiptap/core/src/utilities/createStyleTag.ts","../node_modules/@tiptap/core/src/inputRules/markInputRule.ts","../node_modules/@tiptap/core/src/inputRules/nodeInputRule.ts","../node_modules/@tiptap/core/src/inputRules/textblockTypeInputRule.ts","../node_modules/@tiptap/core/src/inputRules/textInputRule.ts","../node_modules/@tiptap/core/src/inputRules/wrappingInputRule.ts","../node_modules/@tiptap/core/src/jsx-runtime.ts","../node_modules/@tiptap/core/src/lib/ResizableNodeView.ts","../node_modules/@tiptap/core/src/utilities/canInsertNode.ts","../node_modules/@tiptap/core/src/utilities/escapeForRegEx.ts","../node_modules/@tiptap/core/src/utilities/isString.ts","../node_modules/@tiptap/core/src/utilities/markdown/index.ts","../node_modules/@tiptap/core/src/utilities/markdown/attributeUtils.ts","../node_modules/@tiptap/core/src/utilities/markdown/createAtomBlockMarkdownSpec.ts","../node_modules/@tiptap/core/src/utilities/markdown/createBlockMarkdownSpec.ts","../node_modules/@tiptap/core/src/utilities/markdown/createInlineMarkdownSpec.ts","../node_modules/@tiptap/core/src/utilities/markdown/parseIndentedBlocks.ts","../node_modules/@tiptap/core/src/utilities/markdown/renderNestedMarkdownContent.ts","../node_modules/@tiptap/core/src/MarkView.ts","../node_modules/@tiptap/core/src/Node.ts","../node_modules/@tiptap/core/src/NodeView.ts","../node_modules/@tiptap/core/src/pasteRules/markPasteRule.ts","../node_modules/@tiptap/core/src/pasteRules/nodePasteRule.ts","../node_modules/@tiptap/core/src/pasteRules/textPasteRule.ts","../node_modules/@tiptap/core/src/Tracker.ts","../src/lib/comment-mark.ts"],"sourcesContent":["import type { FieldState } from \"./types\"\n\nimport type { EmbedField } from \"./embed\"\nimport type { FilledLinkField } from \"./link\"\n\n/**\n * Types enum for RichTextNodes\n *\n * @see More details: {@link https://prismic.io/docs/rich-text-title}\n */\nexport const RichTextNodeType = {\n\theading1: \"heading1\",\n\theading2: \"heading2\",\n\theading3: \"heading3\",\n\theading4: \"heading4\",\n\theading5: \"heading5\",\n\theading6: \"heading6\",\n\tparagraph: \"paragraph\",\n\tpreformatted: \"preformatted\",\n\tstrong: \"strong\",\n\tem: \"em\",\n\tlistItem: \"list-item\",\n\toListItem: \"o-list-item\",\n\tlist: \"group-list-item\",\n\toList: \"group-o-list-item\",\n\timage: \"image\",\n\tembed: \"embed\",\n\thyperlink: \"hyperlink\",\n\tlabel: \"label\",\n\tspan: \"span\",\n} as const\n\n/**\n * Types for RichTextNodes\n *\n * @see More details: {@link https://prismic.io/docs/rich-text-title}\n */\nexport type RichTextNodeTypes =\n\t(typeof RichTextNodeType)[keyof typeof RichTextNodeType]\n\n// Text nodes\n\n/**\n * Base to be extended by other rich text nodes.\n */\nexport interface RTTextNodeBase {\n\ttext: string\n\tspans: RTInlineNode[]\n\tdirection?: \"ltr\" | \"rtl\"\n}\n\n/**\n * Rich text `heading1` node\n */\nexport interface RTHeading1Node extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.heading1\n}\n\n/**\n * Rich text `heading2` node\n */\nexport interface RTHeading2Node extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.heading2\n}\n\n/**\n * Rich text `heading3` node\n */\nexport interface RTHeading3Node extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.heading3\n}\n\n/**\n * Rich text `heading4` node\n */\nexport interface RTHeading4Node extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.heading4\n}\n\n/**\n * Rich text `heading5` node\n */\nexport interface RTHeading5Node extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.heading5\n}\n\n/**\n * Rich text `heading6` node\n */\nexport interface RTHeading6Node extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.heading6\n}\n\n/**\n * Rich text `paragraph` node\n */\nexport interface RTParagraphNode extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.paragraph\n}\n\n/**\n * Rich text `preformatted` node\n */\nexport interface RTPreformattedNode extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.preformatted\n}\n\n/**\n * Rich text `list-item` node\n */\nexport interface RTListItemNode extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.listItem\n}\n\n/**\n * Rich text `o-list-item` node for ordered lists\n */\nexport interface RTOListItemNode extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.oListItem\n}\n\n// Span nodes\n\n/**\n * @internal Span Node base to be extended for other Span nodes\n */\nexport interface RTSpanNodeBase {\n\tstart: number\n\tend: number\n}\n/**\n * Rich text `strong` node\n */\nexport interface RTStrongNode extends RTSpanNodeBase {\n\ttype: typeof RichTextNodeType.strong\n}\n\n/**\n * Rich text `embed` node\n */\nexport interface RTEmNode extends RTSpanNodeBase {\n\ttype: typeof RichTextNodeType.em\n}\n\n/**\n * Rich text `label` node\n */\nexport interface RTLabelNode extends RTSpanNodeBase {\n\ttype: typeof RichTextNodeType.label\n\tdata: {\n\t\tlabel: string\n\t}\n}\n\n// Media nodes\n\n/**\n * Rich text `image` nodes. They could link to other documents, external web\n * links and media fields\n */\nexport type RTImageNode = {\n\ttype: typeof RichTextNodeType.image\n\tid: string\n\turl: string\n\talt: string | null\n\tcopyright: string | null\n\tdimensions: {\n\t\twidth: number\n\t\theight: number\n\t}\n\tedit: {\n\t\tx: number\n\t\ty: number\n\t\tzoom: number\n\t\tbackground: string\n\t}\n\tlinkTo?: FilledLinkField\n}\n\n/**\n * Rich text `embed` node\n */\nexport type RTEmbedNode = {\n\ttype: typeof RichTextNodeType.embed\n\toembed: EmbedField\n}\n\n// Link nodes\n\n/**\n * Rich text `a` node\n *\n * @see More details: {@link https://prismic.io/docs/rich-text-title#elements-and-styles}\n */\nexport interface RTLinkNode extends RTSpanNodeBase {\n\ttype: typeof RichTextNodeType.hyperlink\n\tdata: FilledLinkField\n}\n\n// Serialization related nodes\n\n/**\n * Rich text `list` node\n */\nexport interface RTListNode {\n\ttype: typeof RichTextNodeType.list\n\titems: RTListItemNode[]\n}\n\n/**\n * Rich text o-lost node\n */\nexport interface RTOListNode {\n\ttype: typeof RichTextNodeType.oList\n\titems: RTOListItemNode[]\n}\n\n// This one is confusing but it's actually the inner content of a block\n/**\n * Rich text `span` node\n */\nexport interface RTSpanNode extends RTTextNodeBase {\n\ttype: typeof RichTextNodeType.span\n}\n\n// Helpers\n\n/**\n * Nodes from a rich text field\n */\nexport type RTNode =\n\t| RTHeading1Node\n\t| RTHeading2Node\n\t| RTHeading3Node\n\t| RTHeading4Node\n\t| RTHeading5Node\n\t| RTHeading6Node\n\t| RTParagraphNode\n\t| RTPreformattedNode\n\t| RTListItemNode\n\t| RTOListItemNode\n\t| RTImageNode\n\t| RTEmbedNode\n\n/**\n * Rich text nodes with text\n */\nexport type RTTextNode =\n\t| RTHeading1Node\n\t| RTHeading2Node\n\t| RTHeading3Node\n\t| RTHeading4Node\n\t| RTHeading5Node\n\t| RTHeading6Node\n\t| RTParagraphNode\n\t| RTPreformattedNode\n\t| RTListItemNode\n\t| RTOListItemNode\n\n/**\n * Rich text block nodes\n */\nexport type RTBlockNode =\n\t| RTHeading1Node\n\t| RTHeading2Node\n\t| RTHeading3Node\n\t| RTHeading4Node\n\t| RTHeading5Node\n\t| RTHeading6Node\n\t| RTParagraphNode\n\t| RTPreformattedNode\n\t| RTListItemNode\n\t| RTOListItemNode\n\t| RTListNode\n\t| RTOListNode\n\t| RTImageNode\n\t| RTEmbedNode\n\n/**\n * Inline rich text nodes\n */\nexport type RTInlineNode = RTStrongNode | RTEmNode | RTLabelNode | RTLinkNode\n\n/**\n * All rich text nodes\n */\nexport type RTAnyNode = RTBlockNode | RTInlineNode | RTSpanNode\n\n/**\n * A rich text field.\n *\n * @see Rich text field documentation: {@link https://prismic.io/docs/rich-text-title}\n */\nexport type RichTextField<State extends FieldState = FieldState> =\n\tState extends \"empty\" ? [] : [RTNode, ...RTNode[]]\n","import type { Slice } from \"../types/value/slice\"\n\n/**\n * Convert a value to a lazyily loaded module. This is useful when using\n * functions like `() => import(\"...\")`.\n */\ntype LazyModule<T> = () => Promise<T | { default: T }>\n\n/**\n * Mark a type as potentially lazy-loaded via a module.\n */\ntype MaybeLazyModule<T> = T | LazyModule<T>\n\n// oxlint-disable-next-line no-explicit-any\ntype AnyFunction = (...args: any[]) => any\n\n/**\n * Returns the type of a `SliceLike` type.\n *\n * @typeParam Slice - The Slice from which the type will be extracted.\n */\ntype ExtractSliceType<TSlice extends SliceLike> = TSlice extends SliceLikeRestV2\n\t? TSlice[\"slice_type\"]\n\t: TSlice extends SliceLikeGraphQL\n\t\t? TSlice[\"type\"]\n\t\t: never\n\n/**\n * The minimum required properties to represent a Prismic slice from the Prismic\n * Content API for the `mapSliceZone()` helper.\n *\n * @typeParam SliceType - Type name of the slice.\n */\ntype SliceLikeRestV2<TSliceType extends string = string> = Pick<\n\tSlice<TSliceType>,\n\t\"id\" | \"slice_type\"\n>\n\n/**\n * The minimum required properties to represent a Prismic slice from the Prismic\n * GraphQL API for the `mapSliceZone()` helper.\n *\n * @typeParam SliceType - Type name of the slice.\n */\ntype SliceLikeGraphQL<TSliceType extends string = string> = {\n\ttype: Slice<TSliceType>[\"slice_type\"]\n}\n\n/**\n * The minimum required properties to represent a Prismic slice for the\n * `mapSliceZone()` helper.\n *\n * If using Prismic's Content API, use the `Slice` export from\n * `@prismicio/client` for a full interface.\n *\n * @typeParam SliceType - Type name of the slice.\n */\ntype SliceLike<TSliceType extends string = string> =\n\t| SliceLikeRestV2<TSliceType>\n\t| SliceLikeGraphQL<TSliceType>\n\n/**\n * A looser version of the `SliceZone` type from `@prismicio/client` using\n * `SliceLike`.\n *\n * If using Prismic's Content API, use the `SliceZone` export from\n * `@prismicio/client` for the full type.\n *\n * @typeParam TSlice - The type(s) of a slice in the slice zone.\n */\ntype SliceZoneLike<TSlice extends SliceLike = SliceLike> = readonly TSlice[]\n\n/**\n * A set of properties that identify a Slice as having been mapped. Consumers of\n * the mapped Slice Zone can use these properties to detect and specially handle\n * mapped Slices.\n */\ntype MappedSliceLike = {\n\t/**\n\t * If `true`, this Slice has been modified from its original value using a\n\t * mapper.\n\t *\n\t * @internal\n\t */\n\t__mapped: true\n}\n\n/**\n * Arguments for a function mapping content from a Prismic Slice using the\n * `mapSliceZone()` helper.\n *\n * @typeParam TSlice - The Slice passed as a prop.\n * @typeParam TContext - Arbitrary data passed to `mapSliceZone()` and made\n *   available to all Slice mappers.\n */\ntype SliceMapperArgs<\n\tTSlice extends SliceLike = SliceLike,\n\tTContext = unknown,\n> = {\n\t/**\n\t * Slice data.\n\t */\n\tslice: TSlice\n\n\t/**\n\t * The index of the Slice in the Slice Zone.\n\t */\n\tindex: number\n\n\t/**\n\t * All Slices from the Slice Zone to which the Slice belongs.\n\t */\n\t// TODO: We have to keep this list of Slices general due to circular\n\t// reference limtiations. If we had another generic to determine the full\n\t// union of Slice types, it would include TSlice. This causes TypeScript to\n\t// throw a compilation error.\n\tslices: SliceZoneLike<\n\t\tTSlice extends SliceLikeGraphQL ? SliceLikeGraphQL : SliceLikeRestV2\n\t>\n\n\t/**\n\t * Arbitrary data passed to `mapSliceZone()` and made available to all Slice\n\t * mappers.\n\t */\n\tcontext: TContext\n}\n\n/**\n * A record of mappers.\n */\ntype SliceMappers<TSlice extends SliceLike = SliceLike, TContext = unknown> = {\n\t[P in ExtractSliceType<TSlice>]?: MaybeLazyModule<\n\t\tSliceMapper<\n\t\t\tExtract<TSlice, SliceLike<P>>,\n\t\t\t// oxlint-disable-next-line no-explicit-any\n\t\t\tany,\n\t\t\tTContext\n\t\t>\n\t>\n}\n\n/**\n * A function that maps a Slice and its metadata to a modified version. The\n * return value will replace the Slice in the Slice Zone.\n */\nexport type SliceMapper<\n\tTSlice extends SliceLike = SliceLike,\n\tTMappedSlice extends Record<string, unknown> | undefined | void =\n\t\t| Record<string, unknown>\n\t\t| undefined\n\t\t| void,\n\tTContext = unknown,\n> = (\n\targs: SliceMapperArgs<TSlice, TContext>,\n) => TMappedSlice | Promise<TMappedSlice>\n\n/**\n * Unwraps a lazily loaded mapper module.\n */\ntype ResolveLazySliceMapperModule<\n\t// oxlint-disable-next-line no-explicit-any\n\tTSliceMapper extends SliceMapper<any, any> | LazyModule<SliceMapper>,\n> =\n\tTSliceMapper extends LazyModule<SliceMapper>\n\t\t? Awaited<ReturnType<TSliceMapper>> extends {\n\t\t\t\tdefault: unknown\n\t\t\t}\n\t\t\t? Awaited<ReturnType<TSliceMapper>>[\"default\"]\n\t\t\t: Awaited<ReturnType<TSliceMapper>>\n\t\t: TSliceMapper\n\n/**\n * Transforms a Slice into its mapped version.\n */\ntype MapSliceLike<\n\t// oxlint-disable-next-line no-explicit-any\n\tTSliceLike extends SliceLike<any>,\n\tTSliceMappers extends SliceMappers<\n\t\tTSliceLike,\n\t\t// oxlint-disable-next-line no-explicit-any\n\t\tany\n\t>,\n> = TSliceLike extends Slice\n\t? TSliceLike[\"slice_type\"] extends keyof TSliceMappers\n\t\t? TSliceMappers[TSliceLike[\"slice_type\"]] extends AnyFunction\n\t\t\t? SliceLikeRestV2<TSliceLike[\"slice_type\"]> &\n\t\t\t\t\tMappedSliceLike &\n\t\t\t\t\tAwaited<\n\t\t\t\t\t\tReturnType<\n\t\t\t\t\t\t\tResolveLazySliceMapperModule<\n\t\t\t\t\t\t\t\tTSliceMappers[TSliceLike[\"slice_type\"]]\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t>\n\t\t\t\t\t>\n\t\t\t: TSliceLike\n\t\t: TSliceLike\n\t: TSliceLike extends SliceLikeGraphQL\n\t\t? TSliceLike[\"type\"] extends keyof TSliceMappers\n\t\t\t? TSliceMappers[TSliceLike[\"type\"]] extends AnyFunction\n\t\t\t\t? SliceLikeGraphQL<TSliceLike[\"type\"]> &\n\t\t\t\t\t\tMappedSliceLike &\n\t\t\t\t\t\tAwaited<\n\t\t\t\t\t\t\tReturnType<\n\t\t\t\t\t\t\t\tResolveLazySliceMapperModule<TSliceMappers[TSliceLike[\"type\"]]>\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t>\n\t\t\t\t: TSliceLike\n\t\t\t: TSliceLike\n\t\t: never\n\n/**\n * Transforms a Slice Zone using a set of mapping functions, one for each type\n * of Slice. Mapping functions can be async.\n *\n * Whenever possible, use this function on the server to minimize client-side\n * processing.\n *\n * @example\n *\n * ```typescript\n * const mappedSliceZone = await mapSliceZone(page.data.slices, {\n * \tcode_block: ({ slice }) => ({\n * \t\tcodeHTML: await highlight(slice.primary.code),\n * \t}),\n * });\n * ```\n */\nexport function mapSliceZone<\n\tTSliceLike extends SliceLike,\n\tTSliceMappers extends SliceMappers<TSliceLike, TContext>,\n\tTContext = unknown,\n>(\n\tsliceZone: SliceZoneLike<TSliceLike>,\n\tmappers: TSliceMappers,\n\tcontext?: TContext,\n): Promise<MapSliceLike<TSliceLike, TSliceMappers>[]> {\n\treturn Promise.all(\n\t\tsliceZone.map(async (slice, index, slices) => {\n\t\t\tconst isRestSliceType = \"slice_type\" in slice\n\t\t\tconst sliceType = isRestSliceType ? slice.slice_type : slice.type\n\n\t\t\tconst mapper = mappers[sliceType as keyof typeof mappers]\n\n\t\t\tif (!mapper) {\n\t\t\t\treturn slice\n\t\t\t}\n\n\t\t\tconst mapperArgs = { slice, slices, index, context }\n\n\t\t\t// `result` may be a mapper function OR a module\n\t\t\t// containing a mapper function.\n\t\t\tlet result = await mapper(\n\t\t\t\t// @ts-expect-error - I don't know how to fix this type\n\t\t\t\tmapperArgs,\n\t\t\t)\n\n\t\t\t// `result` is a module containing a mapper function,\n\t\t\t// we need to dig out the mapper function. `result`\n\t\t\t// will be reassigned with the mapper function's value.\n\t\t\tif (\n\t\t\t\t// `mapper.length < 1` ensures the given\n\t\t\t\t// function is something of the form:\n\t\t\t\t// `() => import(...)`\n\t\t\t\tmapper.length < 1 &&\n\t\t\t\t(typeof result === \"function\" ||\n\t\t\t\t\t(typeof result === \"object\" && \"default\" in result))\n\t\t\t) {\n\t\t\t\tresult = \"default\" in result ? result.default : result\n\t\t\t\tresult = await result(mapperArgs)\n\t\t\t}\n\n\t\t\tif (isRestSliceType) {\n\t\t\t\treturn {\n\t\t\t\t\t__mapped: true,\n\t\t\t\t\tid: slice.id,\n\t\t\t\t\tslice_type: sliceType,\n\t\t\t\t\t...result,\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\t__mapped: true,\n\t\t\t\t\ttype: sliceType,\n\t\t\t\t\t...result,\n\t\t\t\t}\n\t\t\t}\n\t\t}),\n\t)\n}\n","/**\n * Formats the value of a filter element to a stringified version accepted by\n * the Prismic REST API.\n *\n * @param value - Value to format.\n *\n * @returns `value` formatted for the Prismic REST API.\n */\nconst formatValue = (\n\tvalue:\n\t\t| string\n\t\t| number\n\t\t| Date\n\t\t| unknown\n\t\t| (string | number | Date | unknown)[],\n): string => {\n\tif (Array.isArray(value)) {\n\t\treturn `[${value.map(formatValue).join(\", \")}]`\n\t}\n\n\tif (typeof value === \"string\") {\n\t\treturn `\"${value.replace(/\"/g, '\\\\\"')}\"`\n\t}\n\n\tif (value instanceof Date) {\n\t\treturn `${value.getTime()}`\n\t}\n\n\treturn `${value}`\n}\n\n/**\n * Creates a filter builder function for filters with a path and arguments.\n *\n * @typeParam Args - Arguments for the filter.\n *\n * @param name - Name of the filter used in the resulting string.\n *\n * @returns Filter builder function for the given name.\n */\nconst pathWithArgsFilter = <Args extends unknown[]>(name: string) => {\n\t/**\n\t * @param path - Path to the value to be compared.\n\t */\n\tconst fn = (path: string, ...args: Args): string => {\n\t\tconst formattedArgs = args.map(formatValue).join(\", \")\n\t\tconst joiner = path && args.length ? \", \" : \"\"\n\n\t\treturn `[${name}(${path}${joiner}${formattedArgs})]`\n\t}\n\n\treturn fn\n}\n\n/**\n * Creates a filter builder function for filters with only a path.\n *\n * @param name - Name of the filter used in the resulting string.\n *\n * @returns Filter builder function for the given name.\n */\nconst pathFilter = (name: string) => {\n\tconst filterFn = pathWithArgsFilter(name)\n\n\t/**\n\t * @param path - Path for the filter.\n\t */\n\tconst fn = (path: string): string => {\n\t\treturn filterFn(path)\n\t}\n\n\treturn fn\n}\n\n/**\n * Creates a filter builder function for filters with only arguments and no\n * path.\n *\n * @param name - Name of the filter used in the resulting string.\n *\n * @returns Filter builder function for the given name.\n */\nconst argsFilter = <Args extends unknown[]>(name: string) => {\n\tconst filterFn = pathWithArgsFilter<Args>(name)\n\n\t/**\n\t * @param args - Arguments for the filter.\n\t */\n\tconst fn = (...args: Args): string => {\n\t\treturn filterFn(\"\", ...args)\n\t}\n\n\treturn fn\n}\n\nexport const filter = {\n\t/**\n\t * The `at` filter checks that the path matches the described value exactly.\n\t * It takes a single value for a field or an array (only for tags).\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#at}\n\t */\n\tat: pathWithArgsFilter<[value: string | number | boolean | Date | string[]]>(\n\t\t\"at\",\n\t),\n\n\t/**\n\t * The `not` filter checks that the path doesn't match the provided value\n\t * exactly. It takes a single value for a field or an array (only for tags).\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#not}\n\t */\n\tnot: pathWithArgsFilter<[value: string | number | boolean | Date | string[]]>(\n\t\t\"not\",\n\t),\n\n\t/**\n\t * The `any` filter takes an array of values. It works exactly the same way as\n\t * the `at` operator, but checks whether the fragment matches any of the\n\t * values in the array.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#any}\n\t */\n\tany: pathWithArgsFilter<[values: (string | number | boolean | Date)[]]>(\n\t\t\"any\",\n\t),\n\n\t/**\n\t * The `in` filter is used specifically to retrieve an array of documents by\n\t * their IDs or UIDs. This filter is much more efficient at this than the any\n\t * filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#in}\n\t */\n\tin: pathWithArgsFilter<[values: string[]]>(\"in\"),\n\n\t/**\n\t * The `fulltext` filter provides two capabilities:\n\t *\n\t * 1. Checking if a certain string is anywhere inside a document (this is what\n\t *    you should use to make your project's search engine feature)\n\t * 2. Checking if the string is contained inside a specific custom typeâ€™s Rich\n\t *    Text or Key Text fragment.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#fulltext}\n\t */\n\tfulltext: pathWithArgsFilter<[searchTerms: string]>(\"fulltext\"),\n\n\t/**\n\t * The `has` filter checks whether a fragment has a value. It will return all\n\t * the documents of the specified type that contain a value for the specified\n\t * field.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#has}\n\t */\n\thas: pathFilter(\"has\"),\n\n\t/**\n\t * The `missing` filter checks if a fragment doesn't have a value. It will\n\t * return all the documents of the specified type that do not contain a value\n\t * for the specified field.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#missing}\n\t */\n\tmissing: pathFilter(\"missing\"),\n\n\t/**\n\t * The `similar` filter takes the ID of a document, and returns a list of\n\t * documents with similar content. This allows you to build an automated\n\t * content discovery feature (for example, a \"Related posts\" section).\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#similar}\n\t */\n\tsimilar: argsFilter<[id: string, value: number]>(\"similar\"),\n\n\t/**\n\t * The `geopoint.near` filter checks that the value in the path is within the\n\t * radius of the given coordinates.\n\t *\n\t * This filter will only work for a geopoint field.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#geopointnear}\n\t */\n\tgeopointNear:\n\t\tpathWithArgsFilter<[latitude: number, longitude: number, radius: number]>(\n\t\t\t\"geopoint.near\",\n\t\t),\n\n\t/**\n\t * The `number.lt` filter checks that the value in the number field is less\n\t * than the value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#numberlessthan}\n\t */\n\tnumberLessThan: pathWithArgsFilter<[value: number]>(\"number.lt\"),\n\n\t/**\n\t * The `number.gt` filter checks that the value in the number field is greater\n\t * than the value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#numbergreaterthan}\n\t */\n\tnumberGreaterThan: pathWithArgsFilter<[value: number]>(\"number.gt\"),\n\n\t/**\n\t * The `number.inRange` filter checks that the value in the path is within the\n\t * two values passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#numberinrange}\n\t */\n\tnumberInRange:\n\t\tpathWithArgsFilter<[lowerLimit: number, upperLimit: number]>(\n\t\t\t\"number.inRange\",\n\t\t),\n\n\t/**\n\t * The `date.after` filter checks that the value in the path is after the date\n\t * value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateAfter: pathWithArgsFilter<[date: string | number | Date]>(\"date.after\"),\n\n\t/**\n\t * The `date.before` filter checks that the value in the path is before the\n\t * date value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateBefore: pathWithArgsFilter<[date: string | number | Date]>(\"date.before\"),\n\n\t/**\n\t * The `date.between` filter checks that the value in the path is within the\n\t * date values passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateBetween:\n\t\tpathWithArgsFilter<\n\t\t\t[startDate: string | number | Date, endDate: string | number | Date]\n\t\t>(\"date.between\"),\n\n\t/**\n\t * The `date.day-of-month` filter checks that the value in the path is equal\n\t * to the day of the month passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateDayOfMonth: pathWithArgsFilter<[day: number]>(\"date.day-of-month\"),\n\n\t/**\n\t * The `date.day-of-month-after` filter checks that the value in the path is\n\t * after the day of the month passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateDayOfMonthAfter: pathWithArgsFilter<[day: number]>(\n\t\t\"date.day-of-month-after\",\n\t),\n\n\t/**\n\t * The `date.day-of-month-before` filter checks that the value in the path is\n\t * before the day of the month passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateDayOfMonthBefore: pathWithArgsFilter<[day: number]>(\n\t\t\"date.day-of-month-before\",\n\t),\n\n\t/**\n\t * The `date.day-of-week` filter checks that the value in the path is equal to\n\t * the day of the week passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateDayOfWeek: pathWithArgsFilter<[day: string | number]>(\"date.day-of-week\"),\n\n\t/**\n\t * The `date.day-of-week-after` filter checks that the value in the path is\n\t * after the day of the week passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateDayOfWeekAfter: pathWithArgsFilter<[day: string | number]>(\n\t\t\"date.day-of-week-after\",\n\t),\n\n\t/**\n\t * The date.day-of-week-before filter checks that the value in the path is\n\t * before the day of the week passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateDayOfWeekBefore: pathWithArgsFilter<[day: string | number]>(\n\t\t\"date.day-of-week-before\",\n\t),\n\n\t/**\n\t * The `date.month` filter checks that the value in the path occurs in the\n\t * month value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateMonth: pathWithArgsFilter<[month: string | number]>(\"date.month\"),\n\n\t/**\n\t * The `date.month-after` filter checks that the value in the path occurs in\n\t * any month after the value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateMonthAfter:\n\t\tpathWithArgsFilter<[month: string | number]>(\"date.month-after\"),\n\n\t/**\n\t * The `date.month-before` filter checks that the value in the path occurs in\n\t * any month before the value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateMonthBefore:\n\t\tpathWithArgsFilter<[month: string | number]>(\"date.month-before\"),\n\n\t/**\n\t * The `date.year` filter checks that the value in the path occurs in the year\n\t * value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateYear: pathWithArgsFilter<[year: number]>(\"date.year\"),\n\n\t/**\n\t * The `date.hour` filter checks that the value in the path occurs within the\n\t * hour value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateHour: pathWithArgsFilter<[hour: number]>(\"date.hour\"),\n\n\t/**\n\t * The `date.hour-after` filter checks that the value in the path occurs after\n\t * the hour value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateHourAfter: pathWithArgsFilter<[hour: number]>(\"date.hour-after\"),\n\n\t/**\n\t * The `date.hour-before` filter checks that the value in the path occurs\n\t * before the hour value passed into the filter.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#date-filters}\n\t */\n\tdateHourBefore: pathWithArgsFilter<[hour: number]>(\"date.hour-before\"),\n}\n","//#region rolldown:runtime\nvar __defProp = Object.defineProperty;\nvar __export = (all) => {\n\tlet target = {};\n\tfor (var name in all) __defProp(target, name, {\n\t\tget: all[name],\n\t\tenumerable: true\n\t});\n\treturn target;\n};\n\n//#endregion\nexport { __export };","/**\n * The well-known name of the cookie used to store a Prismic preview session's\n * ref.\n */\nexport const preview = \"io.prismic.preview\"\n","export class PrismicError<Response> extends Error {\n\turl?: string\n\tresponse: Response\n\n\tconstructor(\n\t\tmessage = \"An invalid API response was returned\",\n\t\turl: string | undefined,\n\t\tresponse: Response,\n\t) {\n\t\tsuper(message)\n\n\t\tthis.url = url\n\t\tthis.response = response\n\t}\n}\n\ntype ForbiddenErrorRepositoryAPIResponse = {\n\ttype: string\n\tmessage: string\n}\n\ntype ForbiddenErrorQueryAPIResponse = {\n\terror: string\n}\n\nexport class ForbiddenError<\n\tTResponse =\n\t\t| ForbiddenErrorRepositoryAPIResponse\n\t\t| ForbiddenErrorQueryAPIResponse,\n> extends PrismicError<TResponse> {}\n\nexport class NotFoundError<\n\tTResponse = undefined,\n> extends PrismicError<TResponse> {}\n\nexport class RepositoryNotFoundError<\n\tTResponse = undefined,\n> extends NotFoundError<TResponse> {}\n\ntype ParsingErrorAPIResponse = {\n\ttype: \"parsing-error\"\n\tmessage: string\n\tpos: {\n\t\tline: number\n\t\tcolumn: number\n\t\tid: number\n\t\tlocation: string\n\t}\n}\n\nexport class ParsingError<\n\tTResponse = ParsingErrorAPIResponse,\n> extends PrismicError<TResponse> {}\n\nexport class InvalidDataError<\n\tTResponse = undefined,\n> extends PrismicError<TResponse> {}\n\ntype RefExpiredErrorAPIResponse = {\n\ttype: \"api_validation_error\"\n\tmessage: string\n}\n\n// This error extends `ForbiddenError` for backwards compatibility. Before the\n// API started returning 410 for expired refs, it returned 403, which threw a\n// `ForbiddenError`.\n// TODO: Extend this error from `PrismicError` in v8.\nexport class RefExpiredError<\n\tTResponse = RefExpiredErrorAPIResponse,\n> extends ForbiddenError<TResponse> {}\n\ntype RefNotFoundErrorAPIResponse = {\n\ttype: \"api_notfound_error\"\n\tmessage: string\n}\n\n// This error extends `ForbiddenError` for backwards compatibility. Before the\n// API started returning 404 for not found refs, it returned 403, which threw a\n// `ForbiddenError`.\n// TODO: Extend this error from `PrismicError` in v8.\nexport class RefNotFoundError<\n\tTResponse = RefNotFoundErrorAPIResponse,\n> extends ForbiddenError<TResponse> {}\n\ntype PreviewTokenExpiredErrorAPIResponse = {\n\ttype: \"api_security_error\"\n\tmessage: string\n}\n\n// This error extends `ForbiddenError` for backwards compatibility.\n// TODO: Extend this error from `PrismicError` in v8.\nexport class PreviewTokenExpiredError<\n\tTResponse = PreviewTokenExpiredErrorAPIResponse,\n> extends ForbiddenError<TResponse> {}\n","import type { AnyRegularField, FieldState } from \"./types\"\n\nimport type { FilledContentRelationshipField } from \"./contentRelationship\"\nimport type { GroupField } from \"./group\"\nimport type { FilledLinkToMediaField } from \"./linkToMedia\"\nimport type { SliceZone } from \"./sliceZone\"\n\n/**\n * Link types\n */\nexport const LinkType = {\n\tAny: \"Any\",\n\tDocument: \"Document\",\n\tMedia: \"Media\",\n\tWeb: \"Web\",\n} as const\n\n/**\n * A link field.\n *\n * @typeParam TypeEnum - Type API ID of the document.\n * @typeParam LangEnum - Language API ID of the document.\n * @typeParam DataInterface - Data fields for the document (filled via the\n *   `fetchLinks` or `graphQuery` query parameter).\n * @typeParam State - State of the field which determines its shape.\n * @typeParam Variant - Variants of the link.\n */\nexport type LinkField<\n\tTypeEnum = string,\n\tLangEnum = string,\n\tDataInterface extends\n\t\t| Record<string, AnyRegularField | GroupField | SliceZone>\n\t\t| unknown = unknown,\n\tState extends FieldState = FieldState,\n\tVariant = string,\n> = State extends \"empty\"\n\t? EmptyLinkField<typeof LinkType.Any, Variant>\n\t: FilledLinkField<TypeEnum, LangEnum, DataInterface, Variant>\n\n/**\n * A link field that is filled.\n *\n * @typeParam TypeEnum - Type API ID of the document.\n * @typeParam LangEnum - Language API ID of the document.\n * @typeParam DataInterface - Data fields for the document (filled via the\n *   `fetchLinks` or `graphQuery` query parameter).\n * @typeParam Variant - Variants of the link.\n */\nexport type FilledLinkField<\n\tTypeEnum = string,\n\tLangEnum = string,\n\tDataInterface extends\n\t\t| Record<string, AnyRegularField | GroupField | SliceZone>\n\t\t| unknown = unknown,\n\tVariant = string,\n> =\n\t| (FilledContentRelationshipField<TypeEnum, LangEnum, DataInterface> &\n\t\t\tOptionalLinkProperties<Variant>)\n\t| FilledLinkToMediaField<Variant>\n\t| FilledLinkToWebField<Variant>\n\n/**\n * A link field that is not filled.\n *\n * @typeParam _Unused - THIS PARAMETER IS NOT USED. If you are passing a type,\n *   **please remove it**.\n * @typeParam Variant - Variants of the link.\n */\nexport type EmptyLinkField<\n\t_Unused extends\n\t\t(typeof LinkType)[keyof typeof LinkType] = typeof LinkType.Any,\n\tVariant = string,\n> = {\n\tlink_type: \"Any\"\n} & OptionalLinkProperties<Variant>\n\n/**\n * A link field pointing to a relative or absolute URL.\n *\n * @typeParam Variant - Variants of the link.\n */\nexport type FilledLinkToWebField<Variant = string> = {\n\tlink_type: \"Web\"\n\turl: string\n\ttarget?: string\n} & OptionalLinkProperties<Variant>\n\n/**\n * Optional properties available to link fields. It is used to augment existing\n * link-like fields (like content relationship fields) with field-specific\n * properties.\n *\n * @typeParam Variant - Variants of the link.\n *\n * @internal\n */\n// Remember to update the `getOptionalLinkProperties()` function when updating\n// this type. The function should check for every property.\nexport type OptionalLinkProperties<Variant = string> = {\n\ttext?: string\n\tvariant?: Variant\n}\n","import type { FilledContentRelationshipField } from \"../types/value/contentRelationship\"\nimport type { PrismicDocument } from \"../types/value/document\"\nimport { LinkType } from \"../types/value/link\"\n\ntype SetOptional<T, Keys extends keyof T> = Omit<T, Keys> &\n\tPartial<Pick<T, Keys>>\n\n/**\n * Converts a document into a link field, this is useful when crawling the API\n * for document links\n *\n * @typeParam TDocument - Specific interface of the provided document\n *\n * @param prismicDocument - A document coming from Prismic\n *\n * @returns The equivalent link field to use with `asLink()`\n *\n * @internal\n */\nexport const documentToLinkField = <\n\tTDocument extends SetOptional<PrismicDocument, \"slugs\">,\n>(\n\tprismicDocument: TDocument,\n): FilledContentRelationshipField<\n\tTDocument[\"type\"],\n\tTDocument[\"lang\"],\n\tTDocument[\"data\"]\n> => {\n\treturn {\n\t\tlink_type: LinkType.Document,\n\t\tid: prismicDocument.id,\n\t\tuid: prismicDocument.uid || undefined,\n\t\ttype: prismicDocument.type,\n\t\ttags: prismicDocument.tags,\n\t\tlang: prismicDocument.lang,\n\t\turl: prismicDocument.url == null ? undefined : prismicDocument.url,\n\t\tslug: prismicDocument.slugs?.[0], // Slug field is not available with GraphQL\n\t\t// The REST API does not include a `data` property if the data\n\t\t// object is empty.\n\t\t//\n\t\t// A presence check for `prismicDocument.data` is done to\n\t\t// support partial documents. While `documentToLinkField` is\n\t\t// not typed to accept partial documents, passing a partial\n\t\t// document can happen in untyped projects.\n\t\t...(prismicDocument.data && Object.keys(prismicDocument.data).length > 0\n\t\t\t? { data: prismicDocument.data }\n\t\t\t: {}),\n\t}\n}\n","import type { FilledContentRelationshipField } from \"../types/value/contentRelationship\"\nimport type { PrismicDocument } from \"../types/value/document\"\nimport type { FilledLinkToWebField, LinkField } from \"../types/value/link\"\nimport { LinkType } from \"../types/value/link\"\nimport type { FilledLinkToMediaField } from \"../types/value/linkToMedia\"\n\nimport { documentToLinkField } from \"./documentToLinkField\"\n\n/**\n * Resolves a link to a Prismic page to a URL.\n *\n * @typeParam ReturnType - Return type of your link resolver function. Useful if\n *   you prefer to return a complex object.\n *\n * @param linkToDocumentField - A page link field to resolve.\n *\n * @returns Resolved URL.\n *\n * @see Learn about route resolvers and link resolvers: {@link https://prismic.io/docs/routes}\n */\nexport type LinkResolverFunction<ReturnType = string | null | undefined> = (\n\tlinkToDocumentField: FilledContentRelationshipField,\n) => ReturnType\n\n/**\n * Configuration that determines the output of `asLink()`.\n */\ntype AsLinkConfig<LinkResolverFunctionReturnType = string | null | undefined> =\n\t{\n\t\t/**\n\t\t * An optional link resolver function. Without it, you're expected to use\n\t\t * the `routes` option from the API.\n\t\t */\n\t\tlinkResolver?: LinkResolverFunction<LinkResolverFunctionReturnType> | null\n\t}\n\n// TODO: Remove when we remove support for deprecated tuple-style configuration.\n/**\n * @deprecated Use object-style configuration instead.\n */\ntype AsLinkDeprecatedTupleConfig<\n\tLinkResolverFunctionReturnType = string | null | undefined,\n> = [linkResolver?: LinkResolverFunction<LinkResolverFunctionReturnType> | null]\n\n/**\n * The return type of `asLink()`.\n */\nexport type AsLinkReturnType<\n\tLinkResolverFunctionReturnType = string | null | undefined,\n\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t| LinkField\n\t\t| PrismicDocument\n\t\t| null\n\t\t| undefined,\n> = Field extends\n\t| FilledLinkToWebField\n\t| FilledLinkToMediaField\n\t| FilledContentRelationshipField\n\t| PrismicDocument\n\t? LinkResolverFunctionReturnType | string | null\n\t: null\n\n// TODO: Remove overload when we remove support for deprecated tuple-style configuration.\nexport const asLink: {\n\t/**\n\t * Converts any type of link field or Prismic page to a URL.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const url = asLink(document.data.link)\n\t * // => \"/blog/my-post\"\n\t * ```\n\t *\n\t * @typeParam LinkResolverFunctionReturnType - Link resolver function return\n\t *   type.\n\t * @typeParam Field - Link field or Prismic page to resolve to a URL.\n\t *\n\t * @param linkFieldOrDocument - Any kind of link field or a page to resolve.\n\t * @param config - Configuration that determines the output of `asLink()`.\n\t *\n\t * @returns Resolved URL, or `null` if the link field or page is empty.\n\t *\n\t * @see Learn about route resolvers and link resolvers: {@link https://prismic.io/docs/routes}\n\t */\n\t<\n\t\tLinkResolverFunctionReturnType = string | null | undefined,\n\t\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t\t| LinkField\n\t\t\t| PrismicDocument\n\t\t\t| null\n\t\t\t| undefined,\n\t>(\n\t\tlinkFieldOrDocument: Field,\n\t\tconfig?: AsLinkConfig<LinkResolverFunctionReturnType>,\n\t): AsLinkReturnType<LinkResolverFunctionReturnType, Field>\n\n\t/**\n\t * Converts any type of link field or Prismic page to a URL.\n\t *\n\t * @deprecated Use object-style configuration instead.\n\t *\n\t * @typeParam LinkResolverFunctionReturnType - Link resolver function return\n\t *   type.\n\t * @typeParam Field - Link field or Prismic page to resolve to a URL.\n\t *\n\t * @param linkFieldOrDocument - Any kind of link field or a page to resolve.\n\t * @param linkResolver - An optional link resolver function. Without it,\n\t *   you're expected to use the `routes` option from the API.\n\t *\n\t * @returns Resolved URL, or `null` if the link field or page is empty.\n\t *\n\t * @see Learn about route resolvers and link resolvers: {@link https://prismic.io/docs/routes}\n\t */\n\t<\n\t\tLinkResolverFunctionReturnType = string | null | undefined,\n\t\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t\t| LinkField\n\t\t\t| PrismicDocument\n\t\t\t| null\n\t\t\t| undefined,\n\t>(\n\t\tlinkFieldOrDocument: Field,\n\t\t...config: AsLinkDeprecatedTupleConfig<LinkResolverFunctionReturnType>\n\t): AsLinkReturnType<LinkResolverFunctionReturnType, Field>\n} = <\n\tLinkResolverFunctionReturnType = string | null | undefined,\n\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t| LinkField\n\t\t| PrismicDocument\n\t\t| null\n\t\t| undefined,\n>(\n\tlinkFieldOrDocument: Field,\n\t// TODO: Rename to `config` when we remove support for deprecated tuple-style configuration.\n\t...configObjectOrTuple:\n\t\t| [config?: AsLinkConfig<LinkResolverFunctionReturnType>]\n\t\t| AsLinkDeprecatedTupleConfig<LinkResolverFunctionReturnType>\n): AsLinkReturnType<LinkResolverFunctionReturnType, Field> => {\n\tif (!linkFieldOrDocument) {\n\t\treturn null as AsLinkReturnType<LinkResolverFunctionReturnType, Field>\n\t}\n\n\t// Converts document to link field if needed\n\tconst linkField =\n\t\t// prettier-ignore\n\t\t(\n\t\t\t\"link_type\" in linkFieldOrDocument\n\t\t\t\t? linkFieldOrDocument\n\t\t\t\t: documentToLinkField(linkFieldOrDocument)\n\t\t) as LinkField\n\n\t// TODO: Remove when we remove support for deprecated tuple-style configuration.\n\tconst [configObjectOrLinkResolver] = configObjectOrTuple\n\tlet config: AsLinkConfig<LinkResolverFunctionReturnType>\n\tif (\n\t\ttypeof configObjectOrLinkResolver === \"function\" ||\n\t\tconfigObjectOrLinkResolver == null\n\t) {\n\t\tconfig = {\n\t\t\tlinkResolver: configObjectOrLinkResolver,\n\t\t}\n\t} else {\n\t\tconfig = { ...configObjectOrLinkResolver }\n\t}\n\n\tswitch (linkField.link_type) {\n\t\tcase LinkType.Media:\n\t\tcase LinkType.Web:\n\t\t\treturn (\"url\" in linkField ? linkField.url : null) as AsLinkReturnType<\n\t\t\t\tLinkResolverFunctionReturnType,\n\t\t\t\tField\n\t\t\t>\n\n\t\tcase LinkType.Document: {\n\t\t\tif (\"id\" in linkField && config.linkResolver) {\n\t\t\t\t// When using link resolver...\n\t\t\t\tconst resolvedURL = config.linkResolver(linkField)\n\n\t\t\t\tif (resolvedURL != null) {\n\t\t\t\t\treturn resolvedURL as AsLinkReturnType<\n\t\t\t\t\t\tLinkResolverFunctionReturnType,\n\t\t\t\t\t\tField\n\t\t\t\t\t>\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (\"url\" in linkField && linkField.url) {\n\t\t\t\t// When using route resolver...\n\t\t\t\treturn linkField.url as AsLinkReturnType<\n\t\t\t\t\tLinkResolverFunctionReturnType,\n\t\t\t\t\tField\n\t\t\t\t>\n\t\t\t}\n\n\t\t\t// When empty or route resolver and link resolver are not used...\n\t\t\treturn null as AsLinkReturnType<LinkResolverFunctionReturnType, Field>\n\t\t}\n\n\t\tcase LinkType.Any:\n\t\tdefault:\n\t\t\treturn null as AsLinkReturnType<LinkResolverFunctionReturnType, Field>\n\t}\n}\n","{\n\t\"name\": \"@prismicio/client\",\n\t\"version\": \"7.21.3\",\n\t\"description\": \"The official JavaScript + TypeScript client library for Prismic\",\n\t\"keywords\": [\n\t\t\"typescript\",\n\t\t\"client\",\n\t\t\"helpers\",\n\t\t\"types\",\n\t\t\"utils\",\n\t\t\"toolbox\",\n\t\t\"cms\",\n\t\t\"prismic\",\n\t\t\"prismic.io\"\n\t],\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"ssh://git@github.com/prismicio/prismic-client.git\"\n\t},\n\t\"license\": \"Apache-2.0\",\n\t\"author\": \"Prismic <contact@prismic.io> (https://prismic.io)\",\n\t\"sideEffects\": false,\n\t\"type\": \"module\",\n\t\"exports\": {\n\t\t\".\": {\n\t\t\t\"import\": \"./dist/index.js\",\n\t\t\t\"require\": \"./dist/index.cjs\"\n\t\t},\n\t\t\"./richtext\": {\n\t\t\t\"import\": \"./dist/richtext.js\",\n\t\t\t\"require\": \"./dist/richtext.cjs\"\n\t\t},\n\t\t\"./package.json\": \"./package.json\"\n\t},\n\t\"main\": \"./dist/index.cjs\",\n\t\"module\": \"./dist/index.js\",\n\t\"react-native\": \"./dist/index.js\",\n\t\"types\": \"./dist/index.d.cts\",\n\t\"typesVersions\": {\n\t\t\"*\": {\n\t\t\t\"*\": [\n\t\t\t\t\"dist/index.d.ts\"\n\t\t\t],\n\t\t\t\"richtext\": [\n\t\t\t\t\"dist/richtext.d.ts\"\n\t\t\t]\n\t\t}\n\t},\n\t\"files\": [\n\t\t\"dist\",\n\t\t\"src\"\n\t],\n\t\"scripts\": {\n\t\t\"build\": \"tsdown\",\n\t\t\"dev\": \"tsdown --watch\",\n\t\t\"format\": \"prettier --write .\",\n\t\t\"prepare\": \"npm run build\",\n\t\t\"lint\": \"oxlint --deny-warnings\",\n\t\t\"types\": \"tsc --noEmit\",\n\t\t\"unit\": \"vitest run --coverage\",\n\t\t\"unit:watch\": \"vitest watch\",\n\t\t\"test\": \"npm run lint && npm run types && npm run unit && npm run build\"\n\t},\n\t\"dependencies\": {\n\t\t\"imgix-url-builder\": \"^0.0.6\"\n\t},\n\t\"devDependencies\": {\n\t\t\"@prismicio/e2e-tests-utils\": \"^1.14.0\",\n\t\t\"@prismicio/types-internal\": \"^3.16.1\",\n\t\t\"@trivago/prettier-plugin-sort-imports\": \"^4.3.0\",\n\t\t\"@types/node\": \"^24.10.0\",\n\t\t\"@vitest/coverage-v8\": \"^4.0.6\",\n\t\t\"oxlint\": \"^1.26.0\",\n\t\t\"prettier\": \"^3.6.2\",\n\t\t\"prettier-plugin-jsdoc\": \"1.3.3\",\n\t\t\"tsdown\": \"^0.16.1\",\n\t\t\"typescript\": \"^5.9.3\",\n\t\t\"vitest\": \"^4.0.6\"\n\t},\n\t\"engines\": {\n\t\t\"node\": \">=14.15.0\"\n\t},\n\t\"publishConfig\": {\n\t\t\"access\": \"public\"\n\t}\n}\n","import { version } from \"../../package.json\"\n\n/**\n * Returns a `prismic.dev/msg` URL for a given message slug.\n *\n * @example\n *\n * ```ts\n * devMsg(\"missing-param\")\n * // => \"https://prismic.dev/msg/client/v1.2.3/missing-param.md\"\n * ```\n *\n * @param slug - Slug for the message. This corresponds to a Markdown file in\n *   the Git repository's `/messages` directory.\n *\n * @returns The `prismic.dev/msg` URL for the given slug.\n */\nexport const devMsg = (slug: string): string => {\n\treturn `https://prismic.dev/msg/client/v${version}/${slug}`\n}\n","import { devMsg } from \"./lib/devMsg\"\n\nimport { version } from \"../package.json\"\n\n/**\n * The query parameter used to indicate if the client is in development mode to\n * the API.\n */\nconst PRISMIC_DEV_PARAM = \"x-d\"\n\n/** The query parameter used to indicate the version of the client to the API. */\nconst PRISMIC_CLIENT_VERSION_PARAM = \"x-c\"\n\n/**\n * Create a union of the given object's values, and optionally specify which\n * keys to get the values from.\n *\n * Taken from the `type-fest` package.\n *\n * See:\n * https://github.com/sindresorhus/type-fest/blob/61c35052f09caa23de5eef96d95196375d8ed498/source/value-of.d.ts\n */\ntype ValueOf<\n\tObjectType,\n\tValueType extends keyof ObjectType = keyof ObjectType,\n> = ObjectType[ValueType]\n\n/**\n * An `orderings` parameter that orders the results by the specified field.\n *\n * {@link https://prismic.io/docs/rest-api-technical-reference#orderings}\n */\nexport interface Ordering {\n\tfield: string\n\tdirection?: \"asc\" | \"desc\"\n}\n\n/**\n * A `routes` parameter that determines how a page's URL field is resolved.\n *\n * {@link https://prismic.io/docs/route-resolver}\n *\n * @example With a page's UID field.\n *\n * ```ts\n * {\n * \t\"type\": \"page\",\n * \t\"path\": \"/:uid\"\n * }\n * ```\n *\n * @example With a Content Relationship `parent` field.\n *\n * ```ts\n * {\n * \t\"type\": \"page\",\n * \t\"path\": \"/:parent?/:uid\",\n * \t\"resolvers\": {\n * \t\t\"parent\": \"parent\"\n * \t}\n * }\n * ```\n */\nexport interface Route {\n\t/** The custom type of the page. */\n\ttype: string\n\n\t/**\n\t * A specific UID to which this route definition is scoped. The route is only\n\t * defined for the page whose UID matches the given UID.\n\t */\n\tuid?: string\n\n\t/**\n\t * A specific language to which this route definition is scoped. The route is\n\t * only defined for pages whose language matches the given language.\n\t */\n\tlang?: string\n\n\t/** The resolved path of the page with optional placeholders. */\n\tpath: string\n\n\t/** An object that lists the API IDs of the Content Relationships in the route. */\n\tresolvers?: Record<string, string>\n}\n\n/**\n * Parameters for the Prismic Content API.\n *\n * @see Learn how to fetch content from Prismic: {@link https://prismic.io/docs/fetch-content}\n */\nexport interface QueryParams {\n\t/**\n\t * The secure token for accessing the API (only needed if your repository is\n\t * set to private).\n\t *\n\t * {@link https://prismic.io/docs/access-token}\n\t */\n\taccessToken?: string\n\n\t/**\n\t * The `pageSize` parameter defines the maximum number of pages that the API\n\t * will return for your query.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#pagesize}\n\t */\n\tpageSize?: number\n\n\t/**\n\t * The `page` parameter defines the pagination for the result of your query.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#page}\n\t */\n\tpage?: number\n\n\t/**\n\t * The `after` parameter can be used along with the orderings option. It will\n\t * remove all the pages except for those after the specified page in the\n\t * list.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#after}\n\t */\n\tafter?: string\n\n\t/**\n\t * The `fetch` parameter is used to make queries faster by only retrieving the\n\t * specified field(s).\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#fetch}\n\t */\n\tfetch?: string | string[]\n\n\t/**\n\t * The `fetchLinks` parameter allows you to retrieve a specific content field\n\t * from a linked page and add it to the page response object.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#fetchlinks}\n\t */\n\tfetchLinks?: string | string[]\n\n\t/**\n\t * The `graphQuery` parameter allows you to specify which fields to retrieve\n\t * and what content to retrieve from Linked Documents / Content\n\t * Relationships.\n\t *\n\t * {@link https://prismic.io/docs/graphquery-rest-api}\n\t */\n\tgraphQuery?: string\n\n\t/**\n\t * The `lang` option defines the language code for the results of your query.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#lang}\n\t */\n\tlang?: string\n\n\t/**\n\t * The `orderings` parameter orders the results by the specified field(s). You\n\t * can specify as many fields as you want.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#orderings}\n\t *\n\t * @remarks\n\t * Strings and arrays of strings are deprecated as of\n\t * `@prismicio/client@7.0.0`. Please migrate to the more explicit array of\n\t * objects.\n\t *\n\t * @example\n\t *\n\t * ```typescript\n\t * buildQueryURL(endpoint, {\n\t * \torderings: [\n\t * \t\t{ field: \"my.product.price\", direction: \"desc\" },\n\t * \t\t{ field: \"my.product.title\" },\n\t * \t],\n\t * })\n\t * ```\n\t */\n\t// TODO: Update TSDoc with deprecated API removal in v8\n\torderings?: string | Ordering | (string | Ordering)[]\n\n\t/**\n\t * The `routes` option allows you to define how a page's `url` field is\n\t * resolved.\n\t *\n\t * {@link https://prismic.io/docs/route-resolver}\n\t */\n\troutes?: Route | string | (Route | string)[]\n\n\t/**\n\t * The `brokenRoute` option allows you to define the route populated in the\n\t * `url` property for broken link or content relationship fields. A broken\n\t * link is a link or content relationship field whose linked page has been\n\t * unpublished or deleted.\n\t *\n\t * {@link https://prismic.io/docs/route-resolver}\n\t */\n\tbrokenRoute?: string\n}\n\n/** Arguments for `buildQueryURL` to construct a Query URL. */\ntype BuildQueryURLParams = {\n\t/**\n\t * Ref used to query documents.\n\t *\n\t * {@link https://prismic.io/docs/api#refs-and-the-entry-api}\n\t */\n\tref: string\n\n\t/**\n\t * Ref used to populate integration fields with the latest content.\n\t *\n\t * {@link https://prismic.io/docs/integration-fields}\n\t */\n\tintegrationFieldsRef?: string\n\n\t/**\n\t * One or more filters to filter documents for the query.\n\t *\n\t * {@link https://prismic.io/docs/rest-api-technical-reference#q}\n\t */\n\tfilters?: string | string[]\n\n\t/**\n\t * @deprecated Renamed to `filters`. Ensure the value is an array of filters,\n\t *   not a single, non-array filter.\n\t */\n\tpredicates?: string | string[]\n}\n\n/**\n * Parameters in this map have been renamed from the official Prismic REST API\n * V2 specification for better developer ergonomics.\n *\n * These parameters are renamed to their mapped value.\n */\nconst RENAMED_PARAMS = {\n\taccessToken: \"access_token\",\n} as const\n\n/** A valid parameter name for the Prismic REST API V2. */\ntype ValidParamName =\n\t| Exclude<\n\t\t\tkeyof QueryParams,\n\t\t\tkeyof typeof RENAMED_PARAMS | keyof BuildQueryURLParams\n\t  >\n\t| ValueOf<typeof RENAMED_PARAMS>\n\n/**\n * Converts an Ordering to a string that is compatible with Prismic's REST API.\n * If the value provided is already a string, no conversion is performed.\n *\n * @param ordering - Ordering to convert.\n *\n * @returns String representation of the Ordering.\n */\nconst castOrderingToString = (ordering: Ordering | string): string => {\n\t// TODO: Remove the following when `orderings` strings are no longer supported.\n\tif (typeof ordering === \"string\") {\n\t\tif (process.env.NODE_ENV === \"development\") {\n\t\t\tconst [field, direction] = ordering.split(\" \")\n\n\t\t\tconst objectForm =\n\t\t\t\tdirection === \"desc\"\n\t\t\t\t\t? `{ field: \"${field}\", direction: \"desc\" }`\n\t\t\t\t\t: `{ field: \"${field}\" }`\n\n\t\t\tconsole.warn(\n\t\t\t\t`[@prismicio/client] A string value was provided to the \\`orderings\\` query parameter. Strings are deprecated. Please convert it to the object form: ${objectForm}. For more details, see ${devMsg(\n\t\t\t\t\t\"orderings-must-be-an-array-of-objects\",\n\t\t\t\t)}`,\n\t\t\t)\n\t\t}\n\n\t\treturn ordering\n\t}\n\n\treturn ordering.direction === \"desc\"\n\t\t? `${ordering.field} desc`\n\t\t: ordering.field\n}\n\nexport type BuildQueryURLArgs = QueryParams & BuildQueryURLParams\n\n/**\n * Builds a Prismic Content API URL to request pages from a repository. The\n * paginated response for this URL includes pages matching the parameters.\n *\n * A ref is required to make a request. Request the `endpoint` URL to retrieve a\n * list of available refs.\n *\n * Type the JSON response with `Query`.\n *\n * @example\n *\n * ```ts\n * const url = buildQueryURL(\"https://my-repo.cdn.prismic.io/api/v2\", {\n * \tref: \"my-ref\",\n * \tfilters: [filter.at(\"document.type\", \"blog_post\")],\n * })\n * ```\n *\n * @param endpoint - URL to the repository's Content API.\n * @param args - Arguments to filter and scope the query.\n *\n * @returns URL that can be used to request pages from the repository.\n *\n * @see Prismic Content API technical reference: {@link https://prismic.io/docs/content-api}\n */\nexport const buildQueryURL = (\n\tendpoint: string,\n\targs: BuildQueryURLArgs,\n): string => {\n\tconst { filters, predicates, ...params } = args\n\n\tif (!endpoint.endsWith(\"/\")) {\n\t\tendpoint += \"/\"\n\t}\n\tconst url = new URL(`documents/search`, endpoint)\n\n\tif (filters) {\n\t\t// TODO: Remove warning when we remove support for string `filters` values.\n\t\tif (process.env.NODE_ENV === \"development\" && !Array.isArray(filters)) {\n\t\t\tconsole.warn(\n\t\t\t\t`[@prismicio/client] A non-array value was provided to the \\`filters\\` query parameter (\\`${filters}\\`). Non-array values are deprecated. Please convert it to an array. For more details, see ${devMsg(\n\t\t\t\t\t\"filters-must-be-an-array\",\n\t\t\t\t)}`,\n\t\t\t)\n\t\t}\n\n\t\t// TODO: Remove `castArray` when we remove support for string `filters` values.\n\t\tfor (const filter of castArray(filters)) {\n\t\t\turl.searchParams.append(\"q\", `[${filter}]`)\n\t\t}\n\t}\n\n\t// TODO: Remove when we remove support for deprecated `predicates` argument.\n\tif (predicates) {\n\t\tfor (const predicate of castArray(predicates)) {\n\t\t\turl.searchParams.append(\"q\", `[${predicate}]`)\n\t\t}\n\t}\n\n\t// Iterate over each parameter and add it to the URL. In some cases, the\n\t// parameter value needs to be transformed to fit the REST API.\n\tfor (const k in params) {\n\t\tconst name = (RENAMED_PARAMS[k as keyof typeof RENAMED_PARAMS] ||\n\t\t\tk) as ValidParamName\n\n\t\tlet value = params[k as keyof typeof params]\n\n\t\tif (name === \"orderings\") {\n\t\t\tconst scopedValue = params[name]\n\n\t\t\tif (scopedValue != null) {\n\t\t\t\t// TODO: Remove the following warning when `orderings` strings are no longer supported.\n\t\t\t\tif (\n\t\t\t\t\tprocess.env.NODE_ENV === \"development\" &&\n\t\t\t\t\ttypeof scopedValue === \"string\"\n\t\t\t\t) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`[@prismicio/client] A string value was provided to the \\`orderings\\` query parameter. Strings are deprecated. Please convert it to an array of objects. For more details, see ${devMsg(\n\t\t\t\t\t\t\t\"orderings-must-be-an-array-of-objects\",\n\t\t\t\t\t\t)}`,\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tconst v = castArray(scopedValue)\n\t\t\t\t\t.map((ordering) => castOrderingToString(ordering))\n\t\t\t\t\t.join(\",\")\n\n\t\t\t\tvalue = `[${v}]`\n\t\t\t}\n\t\t} else if (name === \"routes\") {\n\t\t\tif (typeof params[name] === \"object\") {\n\t\t\t\tvalue = JSON.stringify(castArray(params[name]))\n\t\t\t}\n\t\t}\n\n\t\tif (value != null) {\n\t\t\turl.searchParams.set(\n\t\t\t\tname,\n\t\t\t\tcastArray<string | number | Route | Ordering>(value).join(\",\"),\n\t\t\t)\n\t\t}\n\t}\n\n\turl.searchParams.set(PRISMIC_CLIENT_VERSION_PARAM, `js-${version}`)\n\n\tif (process.env.NODE_ENV === \"development\") {\n\t\turl.searchParams.set(PRISMIC_DEV_PARAM, \"1\")\n\t}\n\n\treturn url.toString()\n}\n\nfunction castArray<A>(a: A | A[]): A[] {\n\treturn Array.isArray(a) ? a : [a]\n}\n","/**\n * Determines if an input is a valid Prismic repository name.\n *\n * @param input - Input to test.\n *\n * @returns `true` if `input` is a valid Prismic repository name, `false`\n *   otherwise.\n */\nexport const isRepositoryName = (input: string): boolean => {\n\treturn /^[a-zA-Z0-9][-a-zA-Z0-9]{2,}[a-zA-Z0-9]$/.test(input)\n}\n","import { PrismicError } from \"./errors\"\n\nimport { isRepositoryName } from \"./isRepositoryName\"\n\n/**\n * Get a repository's Prismic Content API endpoint.\n *\n * @example\n *\n * ```ts\n * getRepositoryEndpoint(\"my-repo\")\n * // => \"https://my-repo.cdn.prismic.io/api/v2\"\n * ```\n *\n * @typeParam RepositoryName - Name of the Prismic repository.\n *\n * @param repositoryName - Name of the repository.\n *\n * @returns The repository's Prismic Content API endpoint.\n *\n * @throws {@link Error} Thrown if an invalid repository name is provided.\n */\nexport const getRepositoryEndpoint = <RepositoryName extends string>(\n\trepositoryName: RepositoryName,\n): `https://${RepositoryName}.cdn.prismic.io/api/v2` => {\n\tif (isRepositoryName(repositoryName)) {\n\t\treturn `https://${repositoryName}.cdn.prismic.io/api/v2` as const\n\t} else {\n\t\tthrow new PrismicError(\n\t\t\t`An invalid Prismic repository name was given: ${repositoryName}`,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t)\n\t}\n}\n","import { PrismicError } from \"./errors\"\n\n/**\n * Get a Prismic repository's name from its standard Prismic Document API or\n * GraphQL endpoint.\n *\n * @param repositoryEndpoint - Prismic Document API endpoint for the repository.\n *\n * @returns The Prismic repository's name.\n *\n * @throws {@link Error} Thrown if an invalid Prismic Document API endpoint is\n *   provided.\n */\nexport const getRepositoryName = (repositoryEndpoint: string): string => {\n\ttry {\n\t\tconst hostname = new URL(repositoryEndpoint).hostname\n\n\t\tif (\n\t\t\thostname.endsWith(\"prismic.io\") || // Production\n\t\t\thostname.endsWith(\"wroom.io\") || // Staging\n\t\t\thostname.endsWith(\"wroom.test\") // Dev\n\t\t) {\n\t\t\treturn hostname.split(\".\")[0]\n\t\t}\n\t} catch {}\n\n\tthrow new PrismicError(\n\t\t`An invalid Prismic Document API endpoint was provided: ${repositoryEndpoint}`,\n\t\tundefined,\n\t\tundefined,\n\t)\n}\n","/**\n * Determines if a string is a Prismic Content API endpoint. Note that any valid\n * URL is a valid endpoint to support network proxies.\n *\n * @param input - Input to test.\n *\n * @returns `true` if `input` is a valid Prismic Content API endpoint, `false`\n *   otherwise.\n */\nexport const isRepositoryEndpoint = (input: string): boolean => {\n\ttry {\n\t\tnew URL(input)\n\n\t\treturn true\n\t} catch {\n\t\treturn false\n\t}\n}\n","import { preview as previewCookieName } from \"../cookie\"\n\nconst readValue = (value: string): string => {\n\treturn value.replace(/%3B/g, \";\")\n}\n\n/**\n * Returns the value of a cookie from a given cookie store.\n *\n * @param cookieJar - The stringified cookie store from which to read the\n *   cookie.\n *\n * @returns The value of the cookie, if it exists.\n */\nexport const getPreviewCookie = (cookieJar: string): string | undefined => {\n\tconst cookies = cookieJar.split(\"; \")\n\n\tlet value: string | undefined\n\n\tfor (const cookie of cookies) {\n\t\tconst parts = cookie.split(\"=\")\n\t\tconst name = readValue(parts[0]).replace(/%3D/g, \"=\")\n\n\t\tif (name === previewCookieName) {\n\t\t\tvalue = readValue(parts.slice(1).join(\"=\"))\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn value\n}\n","/*\n ** Core logic from https://github.com/sindresorhus/p-limit\n ** Many thanks to @sindresorhus\n */\n\n// oxlint-disable-next-line no-explicit-any\ntype AnyFunction = (...arguments_: readonly any[]) => unknown\n\nconst sleep = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms))\n\n/**\n * @param fn - Promise-returning/async function.\n * @param arguments - Any arguments to pass through to `fn`. Support for passing\n *   arguments on to the `fn` is provided in order to be able to avoid creating\n *   unnecessary closures. You probably don't need this optimization unless\n *   you're pushing a lot of functions.\n *\n * @returns The promise returned by calling `fn(...arguments)`.\n */\nexport type LimitFunction = <TArguments extends unknown[], TReturnType>(\n\tfunction_: (\n\t\t...arguments_: TArguments\n\t) => PromiseLike<TReturnType> | TReturnType,\n\t...arguments_: TArguments\n) => Promise<TReturnType>\n\n/**\n * Creates a limiting function that will only execute one promise at a time and\n * respect a given interval between each call.\n *\n * @param args - Options for the function, `interval` is the minimum time to\n *   wait between each promise execution.\n *\n * @returns A limiting function as per configuration, see {@link LimitFunction}.\n */\nexport const pLimit = ({\n\tinterval,\n}: { interval?: number } = {}): LimitFunction => {\n\tconst queue: AnyFunction[] = []\n\tlet busy = false\n\tlet lastCompletion = 0\n\n\tconst resumeNext = () => {\n\t\tif (!busy && queue.length > 0) {\n\t\t\tqueue.shift()?.()\n\t\t\tbusy = true\n\t\t}\n\t}\n\n\tconst next = () => {\n\t\tbusy = false\n\n\t\tresumeNext()\n\t}\n\n\tconst run = async (\n\t\tfunction_: AnyFunction,\n\t\tresolve: (value: unknown) => void,\n\t\targuments_: unknown[],\n\t) => {\n\t\tconst timeSinceLastCompletion = Date.now() - lastCompletion\n\n\t\tif (interval && timeSinceLastCompletion < interval) {\n\t\t\tawait sleep(interval - timeSinceLastCompletion)\n\t\t}\n\t\tconst result = (async () => function_(...arguments_))()\n\n\t\tresolve(result)\n\n\t\ttry {\n\t\t\tawait result\n\t\t} catch {}\n\n\t\tlastCompletion = Date.now()\n\n\t\tnext()\n\t}\n\n\tconst enqueue = (\n\t\tfunction_: AnyFunction,\n\t\tresolve: (value: unknown) => void,\n\t\targuments_: unknown[],\n\t) => {\n\t\t// Queue `internalResolve` instead of the `run` function\n\t\t// to preserve asynchronous context.\n\t\tnew Promise((internalResolve) => {\n\t\t\tqueue.push(internalResolve)\n\t\t}).then(run.bind(undefined, function_, resolve, arguments_))\n\t\t;(async () => {\n\t\t\t// This function needs to wait until the next microtask before comparing\n\t\t\t// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously\n\t\t\t// after the `internalResolve` function is dequeued and called. The comparison in the if-statement\n\t\t\t// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.\n\t\t\tawait Promise.resolve()\n\n\t\t\tif (!busy) {\n\t\t\t\tresumeNext()\n\t\t\t}\n\t\t})()\n\t}\n\n\treturn ((function_: AnyFunction, ...arguments_: unknown[]) =>\n\t\tnew Promise<unknown>((resolve) => {\n\t\t\tenqueue(function_, resolve, arguments_)\n\t\t})) as LimitFunction\n}\n","import { type LimitFunction, pLimit } from \"./pLimit\"\n\n/**\n * The default number of milliseconds to wait before retrying a rate-limited\n * `fetch()` request (429 response code). The default value is only used if the\n * response does not include a `retry-after` header.\n */\nexport const DEFAULT_RETRY_AFTER = 1500 // ms\n\n/**\n * A record of URLs mapped to throttled task runners.\n */\nconst THROTTLED_RUNNERS: Partial<Record<string, LimitFunction>> = {}\n\n/**\n * A record of URLs mapped to active deduplicated jobs. Jobs are keyed by their\n * optional signal.\n */\nconst DEDUPLICATED_JOBS: Partial<\n\tRecord<string, Map<AbortSignalLike | undefined, Promise<ResponseLike>>>\n> = {}\n\n/**\n * A universal API to make network requests. A subset of the `fetch()` API.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/fetch}\n */\nexport type FetchLike = (\n\tinput: string,\n\tinit?: RequestInitLike,\n) => Promise<ResponseLike>\n\n/**\n * An object that allows you to abort a `fetch()` request if needed via an\n * `AbortController` object\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal}\n */\n// `any` is used often here to ensure this type is universally valid among\n// different AbortSignal implementations. The types of each property are not\n// important to validate since it is blindly passed to a given `fetch()`\n// function.\n// oxlint-disable-next-line no-explicit-any\nexport type AbortSignalLike = any\n\n/**\n * A subset of RequestInit properties to configure a `fetch()` request.\n */\n// Only options relevant to the client are included. Extending from the full\n// RequestInit would cause issues, such as accepting Header objects.\n//\n// An interface is used to allow other libraries to augment the type with\n// environment-specific types.\nexport interface RequestInitLike extends Pick<RequestInit, \"cache\"> {\n\t/**\n\t * The HTTP method to use for the request.\n\t */\n\tmethod?: string\n\n\t/**\n\t * The request body to send with the request.\n\t */\n\t// We want to keep the body type as compatible as possible, so\n\t// we only declare the type we need and accept anything else.\n\t// oxlint-disable-next-line no-explicit-any\n\tbody?: any | FormData | string\n\n\t/**\n\t * An object literal to set the `fetch()` request's headers.\n\t */\n\theaders?: Record<string, string>\n\n\t/**\n\t * An AbortSignal to set the `fetch()` request's signal.\n\t *\n\t * See:\n\t * [https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal)\n\t */\n\t// NOTE: `AbortSignalLike` is `any`! It is left as `AbortSignalLike`\n\t// for backwards compatibility (the type is exported) and to signal to\n\t// other readers that this should be an AbortSignal-like object.\n\tsignal?: AbortSignalLike\n}\n\n/**\n * The minimum required properties from Response.\n */\nexport interface ResponseLike {\n\tok: boolean\n\tstatus: number\n\theaders: HeadersLike\n\turl: string\n\t// oxlint-disable-next-line no-explicit-any\n\tjson(): Promise<any>\n\ttext(): Promise<string>\n\tblob(): Promise<Blob>\n\tclone(): ResponseLike\n}\n\n/**\n * The minimum required properties from Headers.\n */\nexport interface HeadersLike {\n\tget(name: string): string | null\n}\n\n/**\n * Makes an HTTP request with automatic retry for rate limits and request\n * deduplication.\n *\n * @param url - The URL to request.\n * @param init - Fetch options.\n * @param fetchFn - The fetch function to use.\n *\n * @returns The response from the fetch request.\n */\nexport async function request(\n\turl: URL,\n\tinit: RequestInitLike | undefined,\n\tfetchFn: FetchLike,\n): Promise<ResponseLike> {\n\tconst stringURL = url.toString()\n\n\tlet job: Promise<ResponseLike>\n\n\t// Throttle requests with a body.\n\tif (init?.body) {\n\t\t// Rate limiting is done per hostname.\n\t\tconst runner = (THROTTLED_RUNNERS[url.hostname] ||= pLimit({\n\t\t\tinterval: DEFAULT_RETRY_AFTER,\n\t\t}))\n\n\t\tjob = runner(() => fetchFn(stringURL, init))\n\t} else {\n\t\t// Deduplicate all other requests.\n\t\tconst existingJob = DEDUPLICATED_JOBS[stringURL]?.get(init?.signal)\n\t\tif (existingJob) {\n\t\t\tjob = existingJob\n\t\t} else {\n\t\t\tjob = fetchFn(stringURL, init).finally(() => {\n\t\t\t\tDEDUPLICATED_JOBS[stringURL]?.delete(init?.signal)\n\t\t\t\tif (DEDUPLICATED_JOBS[stringURL]?.size === 0) {\n\t\t\t\t\tdelete DEDUPLICATED_JOBS[stringURL]\n\t\t\t\t}\n\t\t\t})\n\t\t\tconst map = (DEDUPLICATED_JOBS[stringURL] ||= new Map())\n\t\t\tmap.set(init?.signal, job)\n\t\t}\n\t}\n\n\tconst response = await job\n\n\t// Retry rate limited requests.\n\tif (response.status === 429) {\n\t\tconst retryAfter = Number(response.headers.get(\"retry-after\"))\n\t\tconst resolvedRetryAfter = Number.isNaN(retryAfter)\n\t\t\t? DEFAULT_RETRY_AFTER\n\t\t\t: retryAfter * 1000\n\n\t\tawait new Promise((resolve) => setTimeout(resolve, resolvedRetryAfter))\n\n\t\treturn request(url, init, fetchFn)\n\t}\n\n\treturn response.clone()\n}\n","const THROTTLE_THRESHOLD_MS = 5000\n\nlet lastMessage: string | undefined\nlet lastCalledAt = 0\n\n/**\n * Logs a warning. If the message is identical the immediate previous logged\n * message and that message was logged within 5 seconds of the current call, the\n * log is ignored. This throttle behavior prevents identical messages from\n * flooding the console.\n *\n * @param message - A message to log.\n * @param config - Configuration for the log.\n */\nexport const throttledWarn = (message: string): void => {\n\tif (\n\t\tmessage === lastMessage &&\n\t\tDate.now() - lastCalledAt < THROTTLE_THRESHOLD_MS\n\t) {\n\t\tlastCalledAt = Date.now()\n\n\t\treturn\n\t}\n\n\tlastCalledAt = Date.now()\n\tlastMessage = message\n\n\tconsole.warn(message)\n}\n","import { devMsg } from \"./lib/devMsg\"\nimport { getPreviewCookie } from \"./lib/getPreviewCookie\"\nimport type { ResponseLike } from \"./lib/request\"\nimport {\n\ttype AbortSignalLike,\n\ttype FetchLike,\n\ttype RequestInitLike,\n\trequest,\n} from \"./lib/request\"\nimport { throttledWarn } from \"./lib/throttledWarn\"\n\nimport type { Query } from \"./types/api/query\"\nimport type { Ref } from \"./types/api/ref\"\nimport type { Repository } from \"./types/api/repository\"\nimport type { PrismicDocument } from \"./types/value/document\"\n\nimport {\n\tForbiddenError,\n\tNotFoundError,\n\tParsingError,\n\tPreviewTokenExpiredError,\n\tPrismicError,\n\tRefExpiredError,\n\tRefNotFoundError,\n\tRepositoryNotFoundError,\n} from \"./errors\"\n\nimport { type LinkResolverFunction, asLink } from \"./helpers/asLink\"\n\nimport { type BuildQueryURLArgs, buildQueryURL } from \"./buildQueryURL\"\nimport { filter } from \"./filter\"\nimport { getRepositoryEndpoint } from \"./getRepositoryEndpoint\"\nimport { getRepositoryName } from \"./getRepositoryName\"\nimport { isRepositoryEndpoint } from \"./isRepositoryEndpoint\"\n\nconst MAX_PAGE_SIZE = 100\nconst REPOSITORY_CACHE_TTL = 5000\nconst GET_ALL_QUERY_DELAY = 500\nconst MAX_INVALID_REF_RETRY_ATTEMPTS = 3\n\n/**\n * Extracts a document type with a matching `type` property from a union of\n * document types.\n */\ntype ExtractDocumentType<\n\tTDocuments extends PrismicDocument,\n\tTDocumentType extends TDocuments[\"type\"],\n> =\n\tExtract<TDocuments, { type: TDocumentType }> extends never\n\t\t? TDocuments\n\t\t: Extract<TDocuments, { type: TDocumentType }>\n\n/**\n * The minimum required properties to treat as an HTTP Request for automatic\n * Prismic preview support.\n */\nexport type HttpRequestLike =\n\t| // Web API Request\n\t{\n\t\t\theaders?: {\n\t\t\t\tget(name: string): string | null\n\t\t\t}\n\t\t\turl?: string\n\t  }\n\t// Express-style request\n\t| {\n\t\t\theaders?: {\n\t\t\t\tcookie?: string\n\t\t\t}\n\t\t\tquery?: Record<string, unknown>\n\t  }\n\n/**\n * A function that returns a ref string. Used to configure which ref the client\n * queries content from.\n */\ntype GetRef = (\n\tparams?: Pick<BuildQueryURLArgs, \"accessToken\"> & FetchParams,\n) => string | undefined | Promise<string | undefined>\n\n/** Parameters for client methods that use `fetch()`. */\nexport type FetchParams = {\n\t/**\n\t * Options provided to the client's `fetch()` on all network requests. These\n\t * options will be merged with internally required options. They can also be\n\t * overriden on a per-query basis using the query's `fetchOptions` parameter.\n\t */\n\tfetchOptions?: RequestInitLike\n\t/** @deprecated Move to `fetchOptions.signal`: */\n\t// TODO: Remove in v8.\n\tsignal?: AbortSignalLike\n}\n\n/** Prismic client configuration. */\nexport type ClientConfig = {\n\t/**\n\t * The client's Content API endpoint.\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#config-options}\n\t */\n\tdocumentAPIEndpoint?: string\n\t/**\n\t * The secure token used for the Content API.\n\t *\n\t * @see {@link https://prismic.io/docs/fetch-content#content-visibility}\n\t */\n\taccessToken?: string\n\t/**\n\t * The version of the repository's content. It can optionally be a function\n\t * that returns a ref.\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#config-options}\n\t */\n\tref?: string | GetRef\n\t/**\n\t * A list of route resolver objects that define how a document's `url`\n\t * property is resolved.\n\t *\n\t * @see {@link https://prismic.io/docs/routes}\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#config-options}\n\t */\n\troutes?: NonNullable<BuildQueryURLArgs[\"routes\"]>\n\t/**\n\t * The URL used for link or content relationship fields that point to an\n\t * archived or deleted page.\n\t *\n\t * @see {@link https://prismic.io/docs/routes}\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#config-options}\n\t */\n\tbrokenRoute?: NonNullable<BuildQueryURLArgs[\"brokenRoute\"]>\n\t/**\n\t * Default parameters sent with each Content API request. These parameters can\n\t * be overridden on each method.\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#config-options}\n\t */\n\tdefaultParams?: Omit<\n\t\tBuildQueryURLArgs,\n\t\t\"ref\" | \"integrationFieldsRef\" | \"accessToken\" | \"routes\" | \"brokenRoute\"\n\t>\n\t/**\n\t * The `fetch` function used to make network requests.\n\t *\n\t * @default The global `fetch` function.\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#config-options}\n\t */\n\tfetch?: FetchLike\n\t/**\n\t * The default `fetch` options sent with each Content API request. These\n\t * parameters can be overriden on each method.\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#config-options}\n\t */\n\tfetchOptions?: RequestInitLike\n}\n\n/**\n * Parameters specific to client methods that fetch all documents. These methods\n * start with `getAll` (e.g. `getAllByType`).\n */\ntype GetAllParams = {\n\t/**\n\t * Limit the number of documents queried.\n\t *\n\t * @default No limit.\n\t */\n\tlimit?: number\n}\n\n/**\n * A client for fetching content from a Prismic repository.\n *\n * @see {@link https://prismic.io/docs/fetch-content}\n * @see {@link https://prismic.io/docs/technical-reference/prismicio-client}\n */\nexport class Client<TDocuments extends PrismicDocument = PrismicDocument> {\n\t/**\n\t * The client's Content API endpoint.\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#config-options}\n\t */\n\tdocumentAPIEndpoint: string\n\t/**\n\t * The secure token used for the Content API.\n\t *\n\t * @see {@link https://prismic.io/docs/fetch-content#content-visibility}\n\t */\n\taccessToken?: string\n\t/**\n\t * A list of route resolver objects that define how a document's `url`\n\t * property is resolved.\n\t *\n\t * @see {@link https://prismic.io/docs/routes}\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#config-options}\n\t */\n\troutes?: NonNullable<BuildQueryURLArgs[\"routes\"]>\n\t/**\n\t * The URL used for link or content relationship fields that point to an\n\t * archived or deleted page.\n\t *\n\t * @see {@link https://prismic.io/docs/routes}\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#config-options}\n\t */\n\tbrokenRoute?: NonNullable<BuildQueryURLArgs[\"brokenRoute\"]>\n\t/**\n\t * Default parameters sent with each Content API request. These parameters can\n\t * be overridden on each method.\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#config-options}\n\t */\n\tdefaultParams?: Omit<\n\t\tBuildQueryURLArgs,\n\t\t\"ref\" | \"integrationFieldsRef\" | \"accessToken\" | \"routes\"\n\t>\n\t/**\n\t * The `fetch` function used to make network requests.\n\t *\n\t * @default The global `fetch` function.\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#config-options}\n\t */\n\tfetchFn: FetchLike\n\t/**\n\t * The default `fetch` options sent with each Content API request. These\n\t * parameters can be overriden on each method.\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#config-options}\n\t */\n\tfetchOptions: RequestInitLike\n\n\t#repositoryName: string | undefined\n\n\t#getRef?: GetRef\n\t#autoPreviews = true\n\t#autoPreviewsRequest?: HttpRequestLike\n\n\t#cachedRepository: Repository | undefined\n\t#cachedRepositoryExpiration = 0 // Timestamp\n\n\t/**\n\t * @param repositoryNameOrEndpoint - The Prismic repository name or full\n\t *   Content API endpoint for the repository.\n\t * @param config - Client configuration.\n\t */\n\tconstructor(repositoryNameOrEndpoint: string, config: ClientConfig = {}) {\n\t\tconst {\n\t\t\tdocumentAPIEndpoint,\n\t\t\taccessToken,\n\t\t\tref,\n\t\t\troutes,\n\t\t\tbrokenRoute,\n\t\t\tdefaultParams,\n\t\t\tfetchOptions = {},\n\t\t\tfetch = globalThis.fetch?.bind(globalThis),\n\t\t} = config\n\n\t\tif (isRepositoryEndpoint(repositoryNameOrEndpoint)) {\n\t\t\ttry {\n\t\t\t\tthis.repositoryName = getRepositoryName(repositoryNameOrEndpoint)\n\t\t\t} catch {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`[@prismicio/client] A repository name could not be inferred from the provided endpoint (\\`${repositoryNameOrEndpoint}\\`). Some methods will be disabled. Create the client using a repository name to prevent this warning. For more details, see ${devMsg(\"prefer-repository-name\")}`,\n\t\t\t\t)\n\t\t\t}\n\t\t\tthis.documentAPIEndpoint = documentAPIEndpoint || repositoryNameOrEndpoint\n\t\t} else {\n\t\t\tthis.repositoryName = repositoryNameOrEndpoint\n\t\t\tthis.documentAPIEndpoint =\n\t\t\t\tdocumentAPIEndpoint || getRepositoryEndpoint(repositoryNameOrEndpoint)\n\t\t}\n\n\t\tif (!fetch) {\n\t\t\tthrow new PrismicError(\n\t\t\t\t\"A valid fetch implementation was not provided. In environments where fetch is not available, a fetch implementation must be provided via a polyfill or the `fetch` option.\",\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t)\n\t\t}\n\t\tif (typeof fetch !== \"function\") {\n\t\t\tthrow new PrismicError(\n\t\t\t\t`fetch must be a function, but received: ${typeof fetch}`,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t)\n\t\t}\n\n\t\tif (!isRepositoryEndpoint(this.documentAPIEndpoint)) {\n\t\t\tthrow new PrismicError(\n\t\t\t\t`documentAPIEndpoint is not a valid URL: ${documentAPIEndpoint}`,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t)\n\t\t}\n\t\tif (\n\t\t\tisRepositoryEndpoint(repositoryNameOrEndpoint) &&\n\t\t\tdocumentAPIEndpoint &&\n\t\t\trepositoryNameOrEndpoint !== documentAPIEndpoint\n\t\t) {\n\t\t\tconsole.warn(\n\t\t\t\t`[@prismicio/client] Multiple incompatible endpoints were provided. Create the client using a repository name to prevent this error. For more details, see ${devMsg(\"prefer-repository-name\")}`,\n\t\t\t)\n\t\t}\n\t\tif (\n\t\t\tprocess.env.NODE_ENV === \"development\" &&\n\t\t\t/\\.prismic\\.io\\/(?!api\\/v2\\/?)/i.test(this.documentAPIEndpoint)\n\t\t) {\n\t\t\tthrow new PrismicError(\n\t\t\t\t\"@prismicio/client only supports Prismic Rest API V2. Please provide only the repository name to the first createClient() parameter or use the getRepositoryEndpoint() helper to generate a valid Rest API V2 endpoint URL.\",\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t)\n\t\t}\n\t\tif (\n\t\t\tprocess.env.NODE_ENV === \"development\" &&\n\t\t\t/(?<!\\.cdn)\\.prismic\\.io$/i.test(\n\t\t\t\tnew URL(this.documentAPIEndpoint).hostname,\n\t\t\t)\n\t\t) {\n\t\t\tconsole.warn(\n\t\t\t\t`[@prismicio/client] The client was created with a non-CDN endpoint. Convert it to the CDN endpoint for better performance. For more details, see ${devMsg(\"endpoint-must-use-cdn\")}`,\n\t\t\t)\n\t\t}\n\n\t\tthis.accessToken = accessToken\n\t\tthis.routes = routes\n\t\tthis.brokenRoute = brokenRoute\n\t\tthis.defaultParams = defaultParams\n\t\tthis.fetchOptions = fetchOptions\n\t\tthis.fetchFn = fetch\n\n\t\tthis.graphQLFetch = this.graphQLFetch.bind(this)\n\n\t\tif (ref) {\n\t\t\tthis.queryContentFromRef(ref)\n\t\t}\n\t}\n\n\t/** The Prismic repository's name. */\n\tset repositoryName(value: string) {\n\t\tthis.#repositoryName = value\n\t}\n\t/** The Prismic repository's name. */\n\tget repositoryName(): string {\n\t\tif (!this.#repositoryName) {\n\t\t\tthrow new PrismicError(\n\t\t\t\t`A repository name is required for this method but one could not be inferred from the provided API endpoint (\\`${this.documentAPIEndpoint}\\`). To fix this error, provide a repository name when creating the client. For more details, see ${devMsg(\"prefer-repository-name\")}`,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t)\n\t\t}\n\n\t\treturn this.#repositoryName\n\t}\n\n\t/** @deprecated Replace with `documentAPIEndpoint`. */\n\t// TODO: Remove in v8.\n\tset endpoint(value: string) {\n\t\tthis.documentAPIEndpoint = value\n\t}\n\t/** @deprecated Replace with `documentAPIEndpoint`. */\n\t// TODO: Remove in v8.\n\tget endpoint(): string {\n\t\treturn this.documentAPIEndpoint\n\t}\n\n\t/**\n\t * Enables the client to automatically query content from a preview session.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * client.enableAutoPreviews()\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#enableautopreviews}\n\t */\n\tenableAutoPreviews(): void {\n\t\tthis.#autoPreviews = true\n\t}\n\n\t/**\n\t * Enables the client to automatically query content from a preview session\n\t * using an HTTP request object.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * client.enableAutoPreviewsFromReq(req)\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#enableautopreviewsfromreq}\n\t */\n\tenableAutoPreviewsFromReq(request: HttpRequestLike): void {\n\t\tthis.enableAutoPreviews()\n\t\tthis.#autoPreviewsRequest = request\n\t}\n\n\t/**\n\t * Disables the client from automatically querying content from a preview\n\t * session.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * client.disableAutoPreviews()\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#disableautopreviews}\n\t */\n\tdisableAutoPreviews(): void {\n\t\tthis.#autoPreviews = false\n\t\tthis.#autoPreviewsRequest = undefined\n\t}\n\n\t/**\n\t * Fetches pages based on the `params` argument. Results are paginated.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.get({ pageSize: 10 })\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#get}\n\t */\n\tasync get<TDocument extends TDocuments>(\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\tconst response = await this.#internalGet(params)\n\n\t\treturn await response.json()\n\t}\n\n\t/**\n\t * Fetches the first page returned based on the `params` argument.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const page = await client.getFirst()\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#getfirst}\n\t */\n\tasync getFirst<TDocument extends TDocuments>(\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<TDocument> {\n\t\tconst actualParams =\n\t\t\tparams?.page || params?.pageSize ? params : { ...params, pageSize: 1 }\n\t\tconst response = await this.#internalGet(actualParams)\n\t\tconst { results }: Query<TDocument> = await response.clone().json()\n\n\t\tif (results[0]) {\n\t\t\treturn results[0]\n\t\t}\n\n\t\tthrow new NotFoundError(\n\t\t\t\"No documents were returned\",\n\t\t\tresponse.url,\n\t\t\tundefined,\n\t\t)\n\t}\n\n\t/**\n\t * Fetches all pages based on the `params` argument. This method may make\n\t * multiple network requests to fetch all matching pages.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const pages = await client.dangerouslyGetAll()\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#dangerouslygetall}\n\t */\n\tasync dangerouslyGetAll<TDocument extends TDocuments>(\n\t\tparams: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams = {},\n\t): Promise<TDocument[]> {\n\t\tconst { limit = Infinity, ...actualParams } = params\n\t\tconst resolvedParams = {\n\t\t\t...actualParams,\n\t\t\tpageSize: Math.min(\n\t\t\t\tlimit,\n\t\t\t\tactualParams.pageSize || this.defaultParams?.pageSize || MAX_PAGE_SIZE,\n\t\t\t),\n\t\t}\n\n\t\tconst documents: TDocument[] = []\n\t\tlet latestResult: Query<TDocument> | undefined\n\n\t\twhile (\n\t\t\t(!latestResult || latestResult.next_page) &&\n\t\t\tdocuments.length < limit\n\t\t) {\n\t\t\tconst page = latestResult ? latestResult.page + 1 : undefined\n\n\t\t\tlatestResult = await this.get<TDocument>({ ...resolvedParams, page })\n\t\t\tdocuments.push(...latestResult.results)\n\n\t\t\tif (latestResult.next_page) {\n\t\t\t\tawait new Promise((res) => setTimeout(res, GET_ALL_QUERY_DELAY))\n\t\t\t}\n\t\t}\n\n\t\treturn documents.slice(0, limit)\n\t}\n\n\t/**\n\t * Fetches a page with a specific ID.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const page = await client.getByID(\"WW4bKScAAMAqmluX\")\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#getbyid}\n\t */\n\tasync getByID<TDocument extends TDocuments>(\n\t\tid: string,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<TDocument> {\n\t\treturn await this.getFirst<TDocument>(\n\t\t\tappendFilters(params, filter.at(\"document.id\", id)),\n\t\t)\n\t}\n\n\t/**\n\t * Fetches pages with specific IDs. Results are paginated.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByIDs([\n\t * \t\"WW4bKScAAMAqmluX\",\n\t * \t\"U1kTRgEAAC8A5ldS\",\n\t * ])\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#getbyids}\n\t */\n\tasync getByIDs<TDocument extends TDocuments>(\n\t\tids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendFilters(params, filter.in(\"document.id\", ids)),\n\t\t)\n\t}\n\n\t/**\n\t * Fetches pages with specific IDs. This method may make multiple network\n\t * requests to fetch all matching pages.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const pages = await client.getAllByIDs([\n\t * \t\"WW4bKScAAMAqmluX\",\n\t * \t\"U1kTRgEAAC8A5ldS\",\n\t * ])\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#getallbyids}\n\t */\n\tasync getAllByIDs<TDocument extends TDocuments>(\n\t\tids: string[],\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendFilters(params, filter.in(\"document.id\", ids)),\n\t\t)\n\t}\n\n\t/**\n\t * Fetches a page with a specific UID and type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const page = await client.getByUID(\"blog_post\", \"my-first-post\")\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#getbyuid}\n\t */\n\tasync getByUID<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tuid: string,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>> {\n\t\treturn await this.getFirst<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendFilters(\n\t\t\t\tparams,\n\t\t\t\tfilter.at(\"document.type\", documentType),\n\t\t\t\tfilter.at(`my.${documentType}.uid`, uid),\n\t\t\t),\n\t\t)\n\t}\n\n\t/**\n\t * Fetches pages with specific UIDs and a specific type. Results are\n\t * paginated.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByUIDs(\"blog_post\", [\n\t * \t\"my-first-post\",\n\t * \t\"my-second-post\",\n\t * ])\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#getbyuids}\n\t */\n\tasync getByUIDs<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tuids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<ExtractDocumentType<TDocument, TDocumentType>>> {\n\t\treturn await this.get<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendFilters(\n\t\t\t\tparams,\n\t\t\t\tfilter.at(\"document.type\", documentType),\n\t\t\t\tfilter.in(`my.${documentType}.uid`, uids),\n\t\t\t),\n\t\t)\n\t}\n\n\t/**\n\t * Fetches pages with specific UIDs and a specific type. This method may make\n\t * multiple network requests to fetch all matching pages.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const pages = await client.getAllByUIDs(\"blog_post\", [\n\t * \t\"my-first-post\",\n\t * \t\"my-second-post\",\n\t * ])\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#getallbyuids}\n\t */\n\tasync getAllByUIDs<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tuids: string[],\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>[]> {\n\t\treturn await this.dangerouslyGetAll<\n\t\t\tExtractDocumentType<TDocument, TDocumentType>\n\t\t>(\n\t\t\tappendFilters(\n\t\t\t\tparams,\n\t\t\t\tfilter.at(\"document.type\", documentType),\n\t\t\t\tfilter.in(`my.${documentType}.uid`, uids),\n\t\t\t),\n\t\t)\n\t}\n\n\t/**\n\t * Fetches a specific single type page.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const page = await client.getSingle(\"settings\")\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#getsingle}\n\t */\n\tasync getSingle<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>> {\n\t\treturn await this.getFirst<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendFilters(params, filter.at(\"document.type\", documentType)),\n\t\t)\n\t}\n\n\t/**\n\t * Fetches pages with a specific type. Results are paginated.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByType(\"blog_post\")\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#getbytype}\n\t */\n\tasync getByType<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<ExtractDocumentType<TDocument, TDocumentType>>> {\n\t\treturn await this.get<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendFilters(params, filter.at(\"document.type\", documentType)),\n\t\t)\n\t}\n\n\t/**\n\t * Fetches pages with a specific type. This method may make multiple network\n\t * requests to fetch all matching documents.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const pages = await client.getAllByType(\"blog_post\")\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#getallbytype}\n\t */\n\tasync getAllByType<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>[]> {\n\t\treturn await this.dangerouslyGetAll<\n\t\t\tExtractDocumentType<TDocument, TDocumentType>\n\t\t>(appendFilters(params, filter.at(\"document.type\", documentType)))\n\t}\n\n\t/**\n\t * Fetches pages with a specific tag. Results are paginated.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByTag(\"featured\")\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#getbytag}\n\t */\n\tasync getByTag<TDocument extends TDocuments>(\n\t\ttag: string,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendFilters(params, filter.any(\"document.tags\", [tag])),\n\t\t)\n\t}\n\n\t/**\n\t * Fetches pages with a specific tag. This method may make multiple network\n\t * requests to fetch all matching documents.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const pages = await client.getAllByTag(\"featured\")\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#getallbytag}\n\t */\n\tasync getAllByTag<TDocument extends TDocuments>(\n\t\ttag: string,\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendFilters(params, filter.any(\"document.tags\", [tag])),\n\t\t)\n\t}\n\n\t/**\n\t * Fetches pages with every tag from a list of tags. Results are paginated.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByEveryTag([\"featured\", \"homepage\"])\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#getbyeverytag}\n\t */\n\tasync getByEveryTag<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendFilters(params, filter.at(\"document.tags\", tags)),\n\t\t)\n\t}\n\n\t/**\n\t * Fetches pages with every tag from a list of tags. This method may make\n\t * multiple network requests to fetch all matching pages.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const pages = await client.getAllByEveryTag([\"featured\", \"homepage\"])\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#getallbyeverytag}\n\t */\n\tasync getAllByEveryTag<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendFilters(params, filter.at(\"document.tags\", tags)),\n\t\t)\n\t}\n\n\t/**\n\t * Fetches pages with at least one tag from a list of tags. Results are\n\t * paginated.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getBySomeTags([\"featured\", \"homepage\"])\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#getbysometags}\n\t */\n\tasync getBySomeTags<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendFilters(params, filter.any(\"document.tags\", tags)),\n\t\t)\n\t}\n\n\t/**\n\t * Fetches pages with at least one tag from a list of tags. This method may\n\t * make multiple network requests to fetch all matching documents.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const pages = await client.getAllBySomeTags([\"featured\", \"homepage\"])\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#getallbysometags}\n\t */\n\tasync getAllBySomeTags<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendFilters(params, filter.any(\"document.tags\", tags)),\n\t\t)\n\t}\n\n\t/**\n\t * Fetches metadata about the client's Prismic repository.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const repository = await client.getRepository()\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#getrepository}\n\t */\n\tasync getRepository(\n\t\tparams?: Pick<BuildQueryURLArgs, \"accessToken\"> & FetchParams,\n\t): Promise<Repository> {\n\t\tif (\n\t\t\tthis.#cachedRepository &&\n\t\t\tthis.#cachedRepositoryExpiration > Date.now()\n\t\t) {\n\t\t\treturn this.#cachedRepository\n\t\t}\n\n\t\tconst url = new URL(this.documentAPIEndpoint)\n\n\t\tconst accessToken = params?.accessToken || this.accessToken\n\t\tif (accessToken) {\n\t\t\turl.searchParams.set(\"access_token\", accessToken)\n\t\t}\n\n\t\tconst response = await this.#request(url, params)\n\n\t\tif (response.ok) {\n\t\t\tthis.#cachedRepository = (await response.json()) as Repository\n\t\t\tthis.#cachedRepositoryExpiration = Date.now() + REPOSITORY_CACHE_TTL\n\n\t\t\treturn this.#cachedRepository\n\t\t}\n\n\t\tif (response.status === 404) {\n\t\t\tthrow new RepositoryNotFoundError(\n\t\t\t\t`Prismic repository not found. Check that \"${this.documentAPIEndpoint}\" is pointing to the correct repository.`,\n\t\t\t\turl.toString(),\n\t\t\t\tundefined,\n\t\t\t)\n\t\t}\n\n\t\treturn await this.#throwContentAPIError(response, url.toString())\n\t}\n\n\t/**\n\t * Fetches the repository's active refs.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const refs = await client.getRefs()\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#getrefs}\n\t */\n\tasync getRefs(params?: FetchParams): Promise<Ref[]> {\n\t\tconst repository = await this.getRepository(params)\n\n\t\treturn repository.refs\n\t}\n\n\t/**\n\t * Fetches a ref by its ID.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const ref = await client.getRefByID(\"YhE3YhEAACIA4321\")\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#getrefbyid}\n\t */\n\tasync getRefByID(id: string, params?: FetchParams): Promise<Ref> {\n\t\tconst refs = await this.getRefs(params)\n\t\tconst ref = refs.find((ref) => ref.id === id)\n\n\t\tif (!ref) {\n\t\t\tthrow new PrismicError(\n\t\t\t\t`Ref with ID \"${id}\" could not be found.`,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t)\n\t\t}\n\n\t\treturn ref\n\t}\n\n\t/**\n\t * Fetches a ref by its label. A release ref's label is its name shown in the\n\t * Page Builder.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const ref = await client.getRefByLabel(\"My Release\")\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#getrefbylabel}\n\t */\n\tasync getRefByLabel(label: string, params?: FetchParams): Promise<Ref> {\n\t\tconst refs = await this.getRefs(params)\n\t\tconst ref = refs.find((ref) => ref.label === label)\n\n\t\tif (!ref) {\n\t\t\tthrow new PrismicError(\n\t\t\t\t`Ref with label \"${label}\" could not be found.`,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t)\n\t\t}\n\n\t\treturn ref\n\t}\n\n\t/**\n\t * Fetches the repository's master ref.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const masterRef = await client.getMasterRef()\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#getmasterref}\n\t */\n\tasync getMasterRef(params?: FetchParams): Promise<Ref> {\n\t\tconst refs = await this.getRefs(params)\n\t\tconst ref = refs.find((ref) => ref.isMasterRef)\n\n\t\tif (!ref) {\n\t\t\tthrow new PrismicError(\n\t\t\t\t\"Master ref could not be found.\",\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t)\n\t\t}\n\n\t\treturn ref\n\t}\n\n\t/**\n\t * Fetches the repository's active releases.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const releases = await client.getReleases()\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#getreleases}\n\t */\n\tasync getReleases(params?: FetchParams): Promise<Ref[]> {\n\t\tconst refs = await this.getRefs(params)\n\n\t\treturn refs.filter((ref) => !ref.isMasterRef)\n\t}\n\n\t/**\n\t * Fetches a release with a specific ID.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const release = await client.getReleaseByID(\"YhE3YhEAACIA4321\")\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#getreleasebyid}\n\t */\n\tasync getReleaseByID(id: string, params?: FetchParams): Promise<Ref> {\n\t\tconst releases = await this.getReleases(params)\n\t\tconst release = releases.find((ref) => ref.id === id)\n\n\t\tif (!release) {\n\t\t\tthrow new PrismicError(\n\t\t\t\t`Release with ID \"${id}\" could not be found.`,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t)\n\t\t}\n\n\t\treturn release\n\t}\n\n\t/**\n\t * Fetches a release by its label. A release ref's label is its name shown in\n\t * the Page Builder.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const release = await client.getReleaseByLabel(\"My Release\")\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#getreleasebylabel}\n\t */\n\tasync getReleaseByLabel(label: string, params?: FetchParams): Promise<Ref> {\n\t\tconst releases = await this.getReleases(params)\n\t\tconst release = releases.find((ref) => ref.label === label)\n\n\t\tif (!release) {\n\t\t\tthrow new PrismicError(\n\t\t\t\t`Release with label \"${label}\" could not be found.`,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t)\n\t\t}\n\n\t\treturn release\n\t}\n\n\t/**\n\t * Fetches the repository's page tags.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const tags = await client.getTags()\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#gettags}\n\t */\n\tasync getTags(params?: FetchParams): Promise<string[]> {\n\t\tconst repository = await this.getRepository(params)\n\t\tconst form = repository.forms.tags\n\t\tif (form) {\n\t\t\tconst url = new URL(form.action)\n\t\t\tif (this.accessToken) {\n\t\t\t\turl.searchParams.set(\"access_token\", this.accessToken)\n\t\t\t}\n\n\t\t\tconst response = await this.#request(url, params)\n\t\t\tif (response.ok) {\n\t\t\t\treturn (await response.json()) as string[]\n\t\t\t}\n\t\t}\n\n\t\treturn repository.tags\n\t}\n\n\t/**\n\t * Builds a Content API query URL with a set of parameters.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const url = await client.buildQueryURL({\n\t * \tfilters: [filter.at(\"document.type\", \"blog_post\")],\n\t * })\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#buildqueryurl}\n\t */\n\tasync buildQueryURL({\n\t\tsignal,\n\t\tfetchOptions,\n\t\t...params\n\t}: Partial<BuildQueryURLArgs> & FetchParams = {}): Promise<string> {\n\t\tconst ref =\n\t\t\tparams.ref ||\n\t\t\t(await this.#getResolvedRef({\n\t\t\t\taccessToken: params.accessToken,\n\t\t\t\tsignal,\n\t\t\t\tfetchOptions,\n\t\t\t}))\n\t\tconst integrationFieldsRef =\n\t\t\tparams.integrationFieldsRef ||\n\t\t\t(\n\t\t\t\tawait this.getRepository({\n\t\t\t\t\taccessToken: params.accessToken,\n\t\t\t\t\tsignal,\n\t\t\t\t\tfetchOptions,\n\t\t\t\t})\n\t\t\t).integrationFieldsRef ||\n\t\t\tundefined\n\n\t\treturn buildQueryURL(this.documentAPIEndpoint, {\n\t\t\t...this.defaultParams,\n\t\t\t...params,\n\t\t\tref,\n\t\t\tintegrationFieldsRef,\n\t\t\troutes: params.routes || this.routes,\n\t\t\tbrokenRoute: params.brokenRoute || this.brokenRoute,\n\t\t\taccessToken: params.accessToken || this.accessToken,\n\t\t})\n\t}\n\n\t/**\n\t * Fetches a previewed page's URL using a preview token and page ID.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const url = await client.resolvePreviewURL({\n\t * \tlinkResolver,\n\t * \tdefaultURL: \"/\",\n\t * })\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#resolvepreviewurl}\n\t */\n\tasync resolvePreviewURL<LinkResolverReturnType>(\n\t\targs: {\n\t\t\t/** A function converts a document to a URL in your website. */\n\t\t\tlinkResolver?: LinkResolverFunction<LinkResolverReturnType>\n\t\t\t/** A fallback URL used when the document does not have a URL. */\n\t\t\tdefaultURL: string\n\t\t\t/** The preview token for the preview session. */\n\t\t\tpreviewToken?: string\n\t\t\t/** The previewed document's ID. */\n\t\t\tdocumentID?: string\n\t\t} & FetchParams,\n\t): Promise<string> {\n\t\tlet documentID: string | undefined | null = args.documentID\n\t\tlet previewToken: string | undefined | null = args.previewToken\n\n\t\tif (typeof globalThis.location !== \"undefined\") {\n\t\t\tconst searchParams = new URLSearchParams(globalThis.location.search)\n\n\t\t\tdocumentID = documentID || searchParams.get(\"documentId\")\n\t\t\tpreviewToken = previewToken || searchParams.get(\"token\")\n\t\t} else if (this.#autoPreviewsRequest) {\n\t\t\tif (\"query\" in this.#autoPreviewsRequest) {\n\t\t\t\tdocumentID =\n\t\t\t\t\tdocumentID || (this.#autoPreviewsRequest.query?.documentId as string)\n\t\t\t\tpreviewToken =\n\t\t\t\t\tpreviewToken || (this.#autoPreviewsRequest.query?.token as string)\n\t\t\t} else if (\n\t\t\t\t\"url\" in this.#autoPreviewsRequest &&\n\t\t\t\tthis.#autoPreviewsRequest.url\n\t\t\t) {\n\t\t\t\t// Including \"missing-host://\" by default\n\t\t\t\t// handles a case where Next.js Route Handlers\n\t\t\t\t// only provide the pathname and search\n\t\t\t\t// parameters in the `url` property\n\t\t\t\t// (e.g. `/api/preview?foo=bar`).\n\t\t\t\tconst searchParams = new URL(\n\t\t\t\t\tthis.#autoPreviewsRequest.url,\n\t\t\t\t\t\"missing-host://\",\n\t\t\t\t).searchParams\n\n\t\t\t\tdocumentID = documentID || searchParams.get(\"documentId\")\n\t\t\t\tpreviewToken = previewToken || searchParams.get(\"token\")\n\t\t\t}\n\t\t}\n\n\t\tif (documentID != null && previewToken != null) {\n\t\t\tconst document = await this.getByID(documentID, {\n\t\t\t\tref: previewToken,\n\t\t\t\tlang: \"*\",\n\t\t\t\tsignal: args.signal,\n\t\t\t\tfetchOptions: args.fetchOptions,\n\t\t\t})\n\n\t\t\tconst url = asLink(document, { linkResolver: args.linkResolver })\n\n\t\t\tif (typeof url === \"string\") {\n\t\t\t\treturn url\n\t\t\t}\n\t\t}\n\n\t\treturn args.defaultURL\n\t}\n\n\t/**\n\t * Configures the client to query the latest published content. This is the\n\t * client's default mode.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * client.queryLatestContent()\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#querylatestcontent}\n\t */\n\tqueryLatestContent(): void {\n\t\tthis.#getRef = undefined\n\t}\n\n\t/**\n\t * Configures the client to query content from a release with a specific ID.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * client.queryContentFromReleaseByID(\"YhE3YhEAACIA4321\")\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#querycontentfromreleasebyid}\n\t */\n\tqueryContentFromReleaseByID(id: string): void {\n\t\tthis.#getRef = async (params) => {\n\t\t\tconst release = await this.getReleaseByID(id, params)\n\t\t\treturn release.ref\n\t\t}\n\t}\n\n\t/**\n\t * Configures the client to query content from a release with a specific\n\t * label.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * client.queryContentFromReleaseByLabel(\"My Release\")\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#querycontentfromreleasebylabel}\n\t */\n\tqueryContentFromReleaseByLabel(label: string): void {\n\t\tthis.#getRef = async (params) => {\n\t\t\tconst release = await this.getReleaseByLabel(label, params)\n\t\t\treturn release.ref\n\t\t}\n\t}\n\n\t/**\n\t * Configures the client to query content from a specific ref.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * client.queryContentFromRef(\"my-ref\")\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#querycontentfromref}\n\t */\n\tqueryContentFromRef(ref: string | GetRef): void {\n\t\tthis.#getRef = typeof ref === \"string\" ? () => ref : ref\n\t}\n\n\t/**\n\t * A preconfigured `fetch()` function for Prismic's GraphQL API that can be\n\t * provided to GraphQL clients.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * import { createClient, getGraphQLEndpoint } from \"@prismicio/client\"\n\t *\n\t * const client = createClient(\"example-prismic-repo\")\n\t * const graphQLClient = new ApolloClient({\n\t * \tlink: new HttpLink({\n\t * \t\turi: getGraphQLEndpoint(client.repositoryName),\n\t * \t\t// Provide `client.graphQLFetch` as the fetch implementation.\n\t * \t\tfetch: client.graphQLFetch,\n\t * \t\t// Using GET is required.\n\t * \t\tuseGETForQueries: true,\n\t * \t}),\n\t * \tcache: new InMemoryCache(),\n\t * })\n\t * ```\n\t *\n\t * @see {@link https://prismic.io/docs/technical-reference/prismicio-client/v7#graphqlfetch}\n\t */\n\tasync graphQLFetch(\n\t\tinput: RequestInfo,\n\t\tinit?: Omit<RequestInit, \"signal\"> & { signal?: AbortSignalLike },\n\t): Promise<Response> {\n\t\tconst params = {\n\t\t\taccessToken: this.accessToken,\n\t\t\tfetchOptions: this.fetchOptions,\n\t\t}\n\t\tconst repository = await this.getRepository(params)\n\t\tconst ref = await this.#getResolvedRef(params)\n\n\t\tconst headers: NonNullable<RequestInitLike[\"headers\"]> = {}\n\t\theaders[\"prismic-ref\"] = ref\n\t\tif (this.accessToken) {\n\t\t\theaders[\"authorization\"] = `Token ${this.accessToken}`\n\t\t}\n\t\tif (repository.integrationFieldsRef) {\n\t\t\theaders[\"prismic-integration-field-ref\"] = repository.integrationFieldsRef\n\t\t}\n\t\tfor (const [key, value] of Object.entries(init?.headers ?? {})) {\n\t\t\theaders[key.toLowerCase()] = value\n\t\t}\n\n\t\tconst url = new URL(typeof input === \"string\" ? input : input.url)\n\t\tconst query = (url.searchParams.get(\"query\") ?? \"\").replace(\n\t\t\t// Minify the query\n\t\t\t/(\\n| )*( |{|})(\\n| )*/gm,\n\t\t\t(_chars, _spaces, brackets) => brackets,\n\t\t)\n\t\turl.searchParams.set(\"query\", query)\n\t\t// Only used to prevent caching; caches ignore header differences\n\t\turl.searchParams.set(\"ref\", ref)\n\n\t\treturn (await this.fetchFn(url.toString(), {\n\t\t\t...init,\n\t\t\theaders,\n\t\t})) as Response\n\t}\n\n\t/**\n\t * Returns the ref needed to query based on the client's current state. This\n\t * method may make a network request to fetch a ref or resolve the user's ref\n\t * thunk.\n\t *\n\t * If auto previews are enabled, the preview ref takes priority.\n\t *\n\t * The following strategies are used depending on the client's state:\n\t *\n\t * - If the user called `queryLatestContent`: Use the repository's master ref.\n\t *   The ref is cached for 5 seconds. After 5 seconds, a new master ref is\n\t *   fetched.\n\t * - If the user called `queryContentFromReleaseByID`: Use the release's ref.\n\t *   The ref is cached for 5 seconds. After 5 seconds, a new ref for the\n\t *   release is fetched.\n\t * - If the user called `queryContentFromReleaseByLabel`: Use the release's ref.\n\t *   The ref is cached for 5 seconds. After 5 seconds, a new ref for the\n\t *   release is fetched.\n\t * - If the user called `queryContentFromRef`: Use the provided ref. Fall back\n\t *   to the master ref if the ref is not a string.\n\t */\n\tasync #getResolvedRef(\n\t\tparams?: Pick<BuildQueryURLArgs, \"accessToken\"> & FetchParams,\n\t) {\n\t\tif (this.#autoPreviews) {\n\t\t\tconst cookies = this.#autoPreviewsRequest?.headers\n\t\t\t\t? \"get\" in this.#autoPreviewsRequest.headers\n\t\t\t\t\t? this.#autoPreviewsRequest.headers.get(\"cookie\")\n\t\t\t\t\t: this.#autoPreviewsRequest.headers.cookie\n\t\t\t\t: globalThis.document?.cookie\n\t\t\tconst previewRef = getPreviewCookie(cookies ?? \"\")\n\t\t\tif (previewRef) {\n\t\t\t\treturn previewRef\n\t\t\t}\n\t\t}\n\n\t\tconst ref = await this.#getRef?.(params)\n\t\tif (ref) {\n\t\t\treturn ref\n\t\t}\n\n\t\tconst masterRef = await this.getMasterRef(params)\n\t\treturn masterRef.ref\n\t}\n\n\t/**\n\t * Performs a low-level Content API request with the given parameters.\n\t * Automatically retries if an invalid ref is used.\n\t */\n\tasync #internalGet(\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t\tattempt = 1,\n\t): Promise<ResponseLike> {\n\t\tconst url = await this.buildQueryURL(params)\n\t\tconst response = await this.#request(new URL(url), params)\n\n\t\tif (response.ok) {\n\t\t\treturn response\n\t\t}\n\n\t\ttry {\n\t\t\treturn await this.#throwContentAPIError(response, url)\n\t\t} catch (error) {\n\t\t\tif (\n\t\t\t\t(error instanceof RefNotFoundError ||\n\t\t\t\t\terror instanceof RefExpiredError) &&\n\t\t\t\tattempt < MAX_INVALID_REF_RETRY_ATTEMPTS\n\t\t\t) {\n\t\t\t\t// If no explicit ref is given (i.e. the master ref from\n\t\t\t\t// /api/v2 is used), clear the cached repository value.\n\t\t\t\t// Clearing the cached value prevents other methods from\n\t\t\t\t// using a known-stale ref.\n\t\t\t\tif (!params?.ref) {\n\t\t\t\t\tthis.#cachedRepository = undefined\n\t\t\t\t}\n\n\t\t\t\tconst masterRef = error.message.match(/master ref is: (?<ref>.*)$/i)\n\t\t\t\t\t?.groups?.ref\n\t\t\t\tif (!masterRef) {\n\t\t\t\t\tthrow error\n\t\t\t\t}\n\n\t\t\t\tconst badRef = new URL(url).searchParams.get(\"ref\")\n\t\t\t\tconst issue = error instanceof RefNotFoundError ? \"invalid\" : \"expired\"\n\t\t\t\tthrottledWarn(\n\t\t\t\t\t`[@prismicio/client] The ref (${badRef}) was ${issue}. Now retrying with the latest master ref (${masterRef}). If you were previewing content, the response will not include draft content.`,\n\t\t\t\t)\n\n\t\t\t\treturn await this.#internalGet(\n\t\t\t\t\t{ ...params, ref: masterRef },\n\t\t\t\t\tattempt + 1,\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tthrow error\n\t\t}\n\t}\n\n\t/**\n\t * Throws an error based on a Content API response. Only call in known-errored\n\t * states.\n\t */\n\tasync #throwContentAPIError(\n\t\tresponse: ResponseLike,\n\t\turl: string,\n\t): Promise<never> {\n\t\tswitch (response.status) {\n\t\t\tcase 400: {\n\t\t\t\tconst json = await response.clone().json()\n\t\t\t\tthrow new ParsingError(json.message, url, json)\n\t\t\t}\n\t\t\tcase 401: {\n\t\t\t\tconst json = await response.clone().json()\n\t\t\t\tthrow new ForbiddenError(json.message, url, json)\n\t\t\t}\n\t\t\tcase 404: {\n\t\t\t\tconst json = await response.clone().json()\n\t\t\t\tswitch (json.type) {\n\t\t\t\t\tcase \"api_notfound_error\": {\n\t\t\t\t\t\tthrow new RefNotFoundError(json.message, url, json)\n\t\t\t\t\t}\n\t\t\t\t\tcase \"api_security_error\": {\n\t\t\t\t\t\tif (/preview token.*expired/i.test(json.message)) {\n\t\t\t\t\t\t\tthrow new PreviewTokenExpiredError(json.message, url, json)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tthrow new NotFoundError(json.message, url, json)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcase 410: {\n\t\t\t\tconst json = await response.clone().json()\n\t\t\t\tthrow new RefExpiredError(json.message, url, json)\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tthrow new PrismicError(undefined, url, await response.text())\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Performs a low-level network request with the client's fetch options. */\n\tasync #request(url: URL, params?: FetchParams): Promise<ResponseLike> {\n\t\treturn await request(\n\t\t\turl,\n\t\t\t{\n\t\t\t\t...this.fetchOptions,\n\t\t\t\t...params?.fetchOptions,\n\t\t\t\theaders: {\n\t\t\t\t\t...this.fetchOptions?.headers,\n\t\t\t\t\t...params?.fetchOptions?.headers,\n\t\t\t\t},\n\t\t\t\tsignal:\n\t\t\t\t\tparams?.fetchOptions?.signal ||\n\t\t\t\t\tparams?.signal ||\n\t\t\t\t\tthis.fetchOptions?.signal,\n\t\t\t},\n\t\t\tthis.fetchFn,\n\t\t)\n\t}\n}\n\n/** Appends filters to a params object. */\nfunction appendFilters<T extends Pick<BuildQueryURLArgs, \"filters\">>(\n\tparams = {} as T,\n\t...filters: string[]\n): T & { filters: string[] } {\n\treturn { ...params, filters: [...(params.filters ?? []), ...filters] }\n}\n","import type { PrismicDocument } from \"./types/value/document\"\n\nimport type { ClientConfig } from \"./Client\"\nimport { Client } from \"./Client\"\n\n/**\n * Type definitions for the `createClient()` function. May be augmented by\n * third-party libraries.\n */\nexport interface CreateClient {\n\t<TDocuments extends PrismicDocument>(\n\t\t...args: ConstructorParameters<typeof Client>\n\t): Client<TDocuments>\n}\n\n/**\n * Creates a Prismic client that can be used to query content from a repository.\n *\n * @example\n *\n * ```ts\n * // With a repository name\n * createClient(\"my-repo\")\n *\n * // With a full Prismic Content API endpoint\n * createClient(\"https://my-repo.cdn.prismic.io/api/v2\")\n * ```\n *\n * @typeParam TDocuments - A union of Prismic page and custom types for the\n *   repository.\n *\n * @param repositoryNameOrEndpoint - The Prismic repository name or full Content\n *   API endpoint for the repository.\n * @param options - Configuration that determines how content will be queried\n *   from the Prismic repository.\n *\n * @returns A client that can query content from the repository.\n *\n * @see https://prismic.io/docs/technical-reference/prismicio-client/v7\n */\nexport const createClient: CreateClient = <TDocuments extends PrismicDocument>(\n\trepositoryNameOrEndpoint: string,\n\toptions?: ClientConfig,\n) => new Client<TDocuments>(repositoryNameOrEndpoint, options)\n","import type { Asset } from \"../api/asset/asset\"\nimport type { FilledImageFieldImage } from \"../value/image\"\nimport type { LinkToMediaField } from \"../value/linkToMedia\"\nimport { type RTImageNode } from \"../value/richText\"\n\nimport type { InjectMigrationSpecificTypes } from \"./Document\"\n\n/**\n * An asset to be uploaded to Prismic media library.\n */\nexport type MigrationAssetConfig = {\n\t/**\n\t * ID the assets is indexed with on the migration instance.\n\t *\n\t * @remarks\n\t * This property's value is not necessarily the same as the as the one in the\n\t * `file` property. It is mainly used for deduplication within a `Migration`\n\t * instance.\n\t */\n\tid:\n\t\t| string\n\t\t| URL\n\t\t| File\n\t\t| NonNullable<ConstructorParameters<typeof File>[0]>[0]\n\n\t/**\n\t * File to be uploaded as an asset.\n\t */\n\tfile:\n\t\t| string\n\t\t| URL\n\t\t| File\n\t\t| NonNullable<ConstructorParameters<typeof File>[0]>[0]\n\n\t/**\n\t * Filename of the asset.\n\t */\n\tfilename: string\n\n\t/**\n\t * Notes about the asset. Notes are private and only visible in Prismic media\n\t * library.\n\t */\n\tnotes?: string\n\n\t/**\n\t * Credits and copyright for the asset if any.\n\t */\n\tcredits?: string\n\n\t/**\n\t * Alternate text for the asset.\n\t */\n\talt?: string\n\n\t/**\n\t * Tags associated with the asset.\n\t *\n\t * @remarks\n\t * Tags should be at least 3 characters long and 20 characters at most.\n\t */\n\ttags?: string[]\n}\n\n/**\n * An image field in a migration.\n */\nexport type MigrationImage =\n\t| PrismicMigrationAsset\n\t| ({\n\t\t\t/**\n\t\t\t * A reference to the migration asset used to resolve the image field's\n\t\t\t * value.\n\t\t\t */\n\t\t\tid: PrismicMigrationAsset\n\t  } & Record<string, PrismicMigrationAsset>)\n\n/**\n * A link to media field in a migration.\n */\nexport type MigrationLinkToMedia = Pick<\n\tLinkToMediaField<\"filled\">,\n\t\"link_type\" | \"text\"\n> & {\n\t/**\n\t * A reference to the migration asset used to resolve the link to media\n\t * field's value.\n\t */\n\tid: PrismicMigrationAsset\n}\n\n/**\n * The minimum amount of information needed to represent a link to media field\n * with the migration API.\n */\nexport type MigrationLinkToMediaField =\n\t| Pick<LinkToMediaField<\"filled\">, \"link_type\" | \"id\" | \"text\">\n\t| LinkToMediaField<\"empty\">\n\n/**\n * A rich text image node in a migration.\n */\nexport type MigrationRTImageNode = InjectMigrationSpecificTypes<\n\tPick<RTImageNode, \"type\" | \"linkTo\">\n> & {\n\t/**\n\t * A reference to the migration asset used to resolve the rich text image\n\t * node's value.\n\t */\n\tid: PrismicMigrationAsset\n}\n\n/**\n * A migration asset used with the Prismic Migration API.\n */\nexport class PrismicMigrationAsset {\n\t/**\n\t * Asset object from Prismic, available once created.\n\t */\n\tasset?: Asset\n\n\t/**\n\t * Configuration of the asset.\n\t */\n\tconfig: MigrationAssetConfig\n\n\t/**\n\t * The initial field value this migration field was created with.\n\t */\n\toriginalField?:\n\t\t| FilledImageFieldImage\n\t\t| LinkToMediaField<\"filled\">\n\t\t| RTImageNode\n\n\t/**\n\t * Creates a migration asset used with the Prismic Migration API.\n\t *\n\t * @param config - Configuration of the asset.\n\t * @param initialField - The initial field value if any.\n\t *\n\t * @returns A migration asset instance.\n\t */\n\tconstructor(\n\t\tconfig: MigrationAssetConfig,\n\t\tinitialField?:\n\t\t\t| FilledImageFieldImage\n\t\t\t| LinkToMediaField<\"filled\">\n\t\t\t| RTImageNode,\n\t) {\n\t\tthis.config = config\n\t\tthis.originalField = initialField\n\t}\n}\n","import type { FilledContentRelationshipField } from \"../value/contentRelationship\"\nimport type { PrismicDocument, PrismicDocumentWithUID } from \"../value/document\"\nimport type { AnyOEmbed, EmbedField, OEmbedExtra } from \"../value/embed\"\nimport type { FilledImageFieldImage } from \"../value/image\"\nimport type { FilledLinkToMediaField } from \"../value/linkToMedia\"\nimport type { RTImageNode } from \"../value/richText\"\nimport type { SharedSlice } from \"../value/sharedSlice\"\n\nimport type {\n\tMigrationImage,\n\tMigrationLinkToMedia,\n\tMigrationRTImageNode,\n} from \"./Asset\"\nimport type { MigrationContentRelationship } from \"./ContentRelationship\"\n\n/**\n * A utility type that extends any fields in a record with their migration\n * fields equivalent.\n *\n * @typeParam T - Type of the record to extend.\n */\nexport type InjectMigrationSpecificTypes<T> = T extends RTImageNode\n\t?\n\t\t\t| T\n\t\t\t| (Omit<T, \"linkTo\"> & InjectMigrationSpecificTypes<Pick<T, \"linkTo\">>)\n\t\t\t| MigrationRTImageNode\n\t\t\t| undefined\n\t: T extends FilledImageFieldImage\n\t\t? T | MigrationImage | undefined\n\t\t: T extends FilledLinkToMediaField\n\t\t\t? T | MigrationLinkToMedia | undefined\n\t\t\t: T extends FilledContentRelationshipField\n\t\t\t\t? T | MigrationContentRelationship\n\t\t\t\t: T extends EmbedField<AnyOEmbed & OEmbedExtra, \"filled\">\n\t\t\t\t\t? T | Pick<T, \"embed_url\">\n\t\t\t\t\t: T extends SharedSlice\n\t\t\t\t\t\t?\n\t\t\t\t\t\t\t\t| T\n\t\t\t\t\t\t\t\t| InjectMigrationSpecificTypes<\n\t\t\t\t\t\t\t\t\t\tOmit<T, \"id\" | \"slice_label\" | \"version\">\n\t\t\t\t\t\t\t\t  >\n\t\t\t\t\t\t: // oxlint-disable-next-line no-explicit-any\n\t\t\t\t\t\t\tT extends Record<any, any>\n\t\t\t\t\t\t\t? { [P in keyof T]: InjectMigrationSpecificTypes<T[P]> }\n\t\t\t\t\t\t\t: T extends Array<infer U>\n\t\t\t\t\t\t\t\t? Array<InjectMigrationSpecificTypes<U>>\n\t\t\t\t\t\t\t\t: T\n\n/**\n * A utility type that ties the type and data of a Prismic document, creating a\n * strict union.\n */\ntype TiedDocumentTypeAndData<TDocument extends PrismicDocument> =\n\tTDocument extends PrismicDocument<infer TData, infer TType>\n\t\t? {\n\t\t\t\t/**\n\t\t\t\t * Type of the document.\n\t\t\t\t */\n\t\t\t\ttype: TType\n\n\t\t\t\t/**\n\t\t\t\t * Data contained in the document.\n\t\t\t\t */\n\t\t\t\tdata: InjectMigrationSpecificTypes<TData>\n\t\t\t} & (TDocument extends PrismicDocumentWithUID\n\t\t\t\t? Pick<TDocument, \"uid\">\n\t\t\t\t: Partial<Pick<TDocument, \"uid\">>)\n\t\t: never\n\n/**\n * A pending Prismic document to be created with the Migration API.\n *\n * @typeParam TDocument - Type of the Prismic document.\n */\nexport type PendingPrismicDocument<\n\tTDocument extends PrismicDocument = PrismicDocument,\n> = Pick<TDocument, \"lang\"> &\n\tPartial<Pick<TDocument, \"tags\">> &\n\tTiedDocumentTypeAndData<TDocument>\n\n/**\n * An existing Prismic document to be updated with the Migration API.\n *\n * @typeParam TDocument - Type of the Prismic document.\n */\nexport type ExistingPrismicDocument<\n\tTDocument extends PrismicDocument = PrismicDocument,\n> = Omit<TDocument, \"uid\" | \"type\" | \"data\"> &\n\tTiedDocumentTypeAndData<TDocument>\n\n/**\n * A Prismic document to be sent to the Migration API.\n *\n * @typeParam TDocument - Type of the Prismic document.\n */\nexport type MigrationDocument<\n\tTDocument extends PrismicDocument = PrismicDocument,\n> = PendingPrismicDocument<TDocument> | ExistingPrismicDocument<TDocument>\n\n/**\n * A Prismic migration document instance.\n *\n * @typeParam TDocument - Type of the Prismic document.\n */\nexport class PrismicMigrationDocument<\n\tTDocument extends PrismicDocument = PrismicDocument,\n> {\n\t/**\n\t * The document to be sent to the Migration API.\n\t */\n\tdocument: MigrationDocument<TDocument> & Partial<Pick<TDocument, \"id\">>\n\n\t/**\n\t * The name of the document displayed in the editor.\n\t */\n\ttitle?: string\n\n\t/**\n\t * The link to the master language document to relate the document to if any.\n\t */\n\tmasterLanguageDocument?: MigrationContentRelationship\n\n\t/**\n\t * Original Prismic document when the migration document came from another\n\t * Prismic repository.\n\t *\n\t * @remarks\n\t * When migrating a document from another repository, one might want to alter\n\t * it with migration specific types, hence accepting an\n\t * `ExistingPrismicDocument` instead of a regular `PrismicDocument`.\n\t */\n\toriginalPrismicDocument?: ExistingPrismicDocument<PrismicDocument>\n\n\t/**\n\t * Creates a Prismic migration document instance.\n\t *\n\t * @param document - The document to be sent to the Migration API.\n\t * @param title - The name of the document displayed in the editor.\n\t * @param params - Parameters to create/update the document with on the\n\t *   Migration API.\n\t *\n\t * @returns A Prismic migration document instance.\n\t */\n\tconstructor(\n\t\tdocument: MigrationDocument<TDocument>,\n\t\ttitle?: string,\n\t\tparams?: {\n\t\t\tmasterLanguageDocument?: MigrationContentRelationship\n\t\t\toriginalPrismicDocument?: ExistingPrismicDocument<PrismicDocument>\n\t\t},\n\t) {\n\t\tthis.document = document\n\t\tthis.title = title\n\t\tthis.masterLanguageDocument = params?.masterLanguageDocument\n\t\tthis.originalPrismicDocument = params?.originalPrismicDocument\n\t}\n}\n","import type { ColorField } from \"../types/value/color\"\nimport type {\n\tContentRelationshipField,\n\tEmptyContentRelationshipField,\n} from \"../types/value/contentRelationship\"\nimport type { DateField } from \"../types/value/date\"\nimport type { AnyOEmbed, EmbedField } from \"../types/value/embed\"\nimport type { GeoPointField } from \"../types/value/geoPoint\"\nimport type { GroupField, NestedGroupField } from \"../types/value/group\"\nimport type { ImageField, ImageFieldImage } from \"../types/value/image\"\nimport type {\n\tIntegrationField,\n\tIntegrationFieldData,\n} from \"../types/value/integration\"\nimport type { KeyTextField } from \"../types/value/keyText\"\nimport type { LinkField } from \"../types/value/link\"\nimport type { LinkToMediaField } from \"../types/value/linkToMedia\"\nimport type { NumberField } from \"../types/value/number\"\nimport type { RichTextField } from \"../types/value/richText\"\nimport type { SelectField } from \"../types/value/select\"\nimport type { SharedSlice } from \"../types/value/sharedSlice\"\nimport type { Slice } from \"../types/value/slice\"\nimport type { SliceZone } from \"../types/value/sliceZone\"\nimport type { TableField } from \"../types/value/table\"\nimport type { TimestampField } from \"../types/value/timestamp\"\nimport type { TitleField } from \"../types/value/title\"\nimport type { AnyRegularField, Repeatable } from \"../types/value/types\"\n\n/**\n * Determines if a value is not nullish (i.e. not `null` or `undefined`). This\n * is used to check if nullable field values are filled.\n *\n * @param input - The value to check.\n *\n * @returns `true` if `input` is not nullish, `false` otherwise.\n */\nconst isNonNullish = <T>(input: T): input is NonNullable<T> => {\n\treturn input != null\n}\n\n/**\n * Determines if an array is not empty. This is used to check if array-based\n * fields are filled.\n *\n * @param input - The array to check.\n *\n * @returns `true` if `input` has at least one element, `false` otherwise.\n */\nconst isNonEmptyArray = <T>(input: T[]): input is [T, ...T[]] => {\n\treturn !!input.length\n}\n\n/**\n * Determines if a rich text field is filled.\n *\n * @param field - rich text field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const richText = (\n\tfield: RichTextField | null | undefined,\n): field is RichTextField<\"filled\"> => {\n\tif (!isNonNullish(field)) {\n\t\treturn false\n\t} else if (field.length === 1 && \"text\" in field[0]) {\n\t\treturn !!field[0].text\n\t} else {\n\t\treturn !!field.length\n\t}\n}\n\n/**\n * Determines if a title field is filled.\n *\n * @param field - Title field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const title = richText as (\n\tfield: TitleField | null | undefined,\n) => field is TitleField<\"filled\">\n\n/**\n * Determines if an image thumbnail is filled.\n *\n * @param thumbnail - Image thumbnail to check.\n *\n * @returns `true` if the thumbnail is filled, `false` otherwise.\n */\nexport const imageThumbnail = (\n\tthumbnail: ImageFieldImage | null | undefined,\n): thumbnail is ImageFieldImage<\"filled\"> => {\n\treturn isNonNullish(thumbnail) && !!thumbnail.url\n}\n\n/**\n * Determines if an image field is filled.\n *\n * @param field - Image field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const image = imageThumbnail as <\n\tThumbnailNames extends string | null = never,\n>(\n\tfield: ImageField<ThumbnailNames> | null | undefined,\n) => field is ImageField<ThumbnailNames, \"filled\">\n\n/**\n * Determines if a link field is filled.\n *\n * @param field - Link field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const link = <\n\tTypeEnum = string,\n\tLangEnum = string,\n\tDataInterface extends\n\t\t| Record<string, AnyRegularField | GroupField | SliceZone>\n\t\t| unknown = unknown,\n>(\n\tfield: LinkField<TypeEnum, LangEnum, DataInterface> | null | undefined,\n): field is LinkField<TypeEnum, LangEnum, DataInterface, \"filled\"> => {\n\treturn isNonNullish(field) && (\"id\" in field || \"url\" in field)\n}\n\n/**\n * Determines if a link to media field is filled.\n *\n * @param field - Link to media field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const linkToMedia = link as (\n\tfield: LinkToMediaField | null | undefined,\n) => field is LinkToMediaField<\"filled\">\n\n/**\n * Determines if a content relationship field is filled.\n *\n * @param field - Content relationship field to check.\n *\n * @returns `true` if the field is filled, `false` otherwise.\n */\nexport const contentRelationship = link as <\n\tField extends ContentRelationshipField,\n>(\n\tfield: Field | null | undefined,\n) => field is Exclude<Field, EmptyContentRelationshipField>\n\n/**\n * Determines if a date field is filled.\n *\n * @param field - Date field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const date = isNonNullish as (\n\tfield: DateField | null | undefined,\n) => field is DateField<\"filled\">\n\n/**\n * Determines if a timestamp field is filled.\n *\n * @param field - Timestamp field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const timestamp = isNonNullish as (\n\tfield: TimestampField | null | undefined,\n) => field is TimestampField<\"filled\">\n\n/**\n * Determines if a color field is filled.\n *\n * @param field - Color field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const color = isNonNullish as (\n\tfield: ColorField | null | undefined,\n) => field is ColorField<\"filled\">\n\n/**\n * Determines if a number field is filled.\n *\n * @param field - Number field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const number = isNonNullish as (\n\tfield: NumberField | null | undefined,\n) => field is NumberField<\"filled\">\n\n/**\n * Determines if a key text field is filled.\n *\n * @param field - Key text field to check.\n *\n * @returns `true` if the field is filled, `false` otherwise.\n */\nexport const keyText = (\n\tfield: KeyTextField | null | undefined,\n): field is KeyTextField<\"filled\"> => {\n\treturn !!field\n}\n\n/**\n * Determines if a select field is filled.\n *\n * @param field - Select field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const select = isNonNullish as <Enum extends string>(\n\tfield: SelectField<Enum> | null | undefined,\n) => field is SelectField<Enum, \"filled\">\n\n/**\n * Determines if an embed field is filled.\n *\n * @param field - Embed field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const embed = <Field extends EmbedField<AnyOEmbed>>(\n\tfield: Field | null | undefined,\n): field is Extract<Field, EmbedField<AnyOEmbed, \"filled\">> => {\n\treturn isNonNullish(field) && !!field.embed_url\n}\n\n/**\n * Determines if a geopoint field is filled.\n *\n * @param field - Geopoint field to check.\n *\n * @returns `true` if the field is filled, `false` otherwise.\n */\nexport const geoPoint = (\n\tfield: GeoPointField | null | undefined,\n): field is GeoPointField<\"filled\"> => {\n\treturn isNonNullish(field) && \"longitude\" in field\n}\n\n/**\n * Determines if a table field is filled.\n *\n * @param field - Table field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const table = isNonNullish as (\n\tfield: TableField | null | undefined,\n) => field is TableField<\"filled\">\n\n/**\n * Determines if an integration field is filled.\n *\n * @param field - Integration field to check.\n *\n * @returns `true` if `field` is filled, `false` otherwise.\n */\nexport const integration = isNonNullish as <Data extends IntegrationFieldData>(\n\tfield: IntegrationField<Data> | null | undefined,\n) => field is IntegrationField<Data, \"filled\">\n/**\n * @deprecated Renamed to `integration`.\n */\n// TODO: Remove when we remove support for deprecated `integrationField` export.\nexport const integrationField = integration\n/**\n * @deprecated Renamed to `integrationField`.\n */\n// TODO: Remove when we remove support for deprecated `integrationFields` export.\nexport const integrationFields = integration\n\n/**\n * Determines if a repeatable field has at least one item.\n *\n * @param repeatable - Repeatable to check.\n *\n * @returns `true` if `repeatable` contains at least one item, `false`\n *   otherwise.\n */\nexport const repeatable = <T extends LinkField>(\n\trepeatable: Repeatable<T> | null | undefined,\n): repeatable is Repeatable<T, \"filled\"> => {\n\treturn isNonNullish(repeatable) && isNonEmptyArray(repeatable)\n}\n\n/**\n * Determines if a group has at least one item.\n *\n * @param group - Group to check.\n *\n * @returns `true` if the group contains at least one item, `false` otherwise.\n */\nexport const group = <\n\tFields extends Record<string, AnyRegularField | NestedGroupField>,\n>(\n\tgroup: GroupField<Fields> | null | undefined,\n): group is GroupField<Fields, \"filled\"> => {\n\treturn isNonNullish(group) && isNonEmptyArray(group)\n}\n\n/**\n * Determines if a slice zone has at least one slice.\n *\n * @param slices - Slice zone to check.\n *\n * @returns `true` if the slice zone contains at least one slice, `false`\n *   otherwise.\n */\nexport const sliceZone = <Slices extends Slice | SharedSlice>(\n\tslices: SliceZone<Slices> | null | undefined,\n): slices is SliceZone<Slices, \"filled\"> => {\n\treturn isNonNullish(slices) && isNonEmptyArray(slices)\n}\n","import type { InjectMigrationSpecificTypes } from \"../types/migration/Document\"\nimport type { FilledContentRelationshipField } from \"../types/value/contentRelationship\"\nimport type { PrismicDocument } from \"../types/value/document\"\nimport type { GroupField } from \"../types/value/group\"\nimport type { ImageField } from \"../types/value/image\"\nimport { LinkType } from \"../types/value/link\"\nimport type { OptionalLinkProperties } from \"../types/value/link\"\nimport type { FilledLinkToMediaField } from \"../types/value/linkToMedia\"\nimport { type RTImageNode, RichTextNodeType } from \"../types/value/richText\"\nimport type { SliceZone } from \"../types/value/sliceZone\"\nimport type { AnyRegularField } from \"../types/value/types\"\n\n/**\n * Unknown value to check if it's a specific field type.\n *\n * @remarks\n * Explicit types are added to help ensure narrowing is done effectively.\n */\ntype UnknownValue =\n\t| PrismicDocument\n\t| InjectMigrationSpecificTypes<AnyRegularField | GroupField | SliceZone>\n\t| unknown\n\n/**\n * Checks if a value is a link to media field.\n *\n * @param value - Value to check.\n *\n * @returns `true` if `value` is a link to media field, `false` otherwise.\n *\n * @internal\n * This is not an official helper function and it's only designed to work with internal processes.\n */\nexport const filledLinkToMedia = (\n\tvalue: UnknownValue,\n): value is FilledLinkToMediaField => {\n\tif (value && typeof value === \"object\" && !(\"version\" in value)) {\n\t\tif (\n\t\t\t\"link_type\" in value &&\n\t\t\tvalue.link_type === LinkType.Media &&\n\t\t\t\"id\" in value &&\n\t\t\t\"name\" in value &&\n\t\t\t\"kind\" in value &&\n\t\t\t\"url\" in value &&\n\t\t\t\"size\" in value\n\t\t) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n/**\n * Checks if a value is like an image field.\n *\n * @param value - Value to check.\n *\n * @returns `true` if `value` is like an image field, `false` otherwise.\n *\n * @internal\n * This is not an official helper function and it's only designed to work with internal processes.\n */\nconst imageLike = (\n\tvalue: UnknownValue,\n): value is ImageField<string, \"filled\"> | RTImageNode => {\n\tif (\n\t\tvalue &&\n\t\ttypeof value === \"object\" &&\n\t\t(!(\"version\" in value) || typeof value.version === \"object\")\n\t) {\n\t\tif (\n\t\t\t\"id\" in value &&\n\t\t\t\"url\" in value &&\n\t\t\ttypeof value.url === \"string\" &&\n\t\t\t\"dimensions\" in value &&\n\t\t\t\"edit\" in value &&\n\t\t\t\"alt\" in value &&\n\t\t\t\"copyright\" in value\n\t\t) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n/**\n * Checks if a value is an image field.\n *\n * @param value - Value to check.\n *\n * @returns `true` if `value` is an image field, `false` otherwise.\n *\n * @internal\n * This is not an official helper function and it's only designed to work with internal processes.\n */\nexport const filledImage = (\n\tvalue: UnknownValue,\n): value is ImageField<string, \"filled\"> => {\n\tif (\n\t\timageLike(value) &&\n\t\t(!(\"type\" in value) || value.type !== RichTextNodeType.image)\n\t) {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n/**\n * Checks if a value is a rich text image node.\n *\n * @param value - Value to check.\n *\n * @returns `true` if `value` is a rich text image node, `false` otherwise.\n *\n * @internal\n * This is not an official helper function and it's only designed to work with internal processes.\n */\nexport const rtImageNode = (value: UnknownValue): value is RTImageNode => {\n\tif (\n\t\timageLike(value) &&\n\t\t\"type\" in value &&\n\t\tvalue.type === RichTextNodeType.image\n\t) {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n/**\n * Checks if a value is a content relationship field.\n *\n * @remarks\n * The return value includes `OptionalLinkProperties` because\n * `FilledContentRelationshipField` may be a link field, not strictly a content\n * relationship field.\n *\n * @param value - Value to check.\n *\n * @returns `true` if `value` is a content relationship, `false` otherwise.\n *\n * @internal\n * This is not an official helper function and it's only designed to work with internal processes.\n */\nexport const filledContentRelationship = (\n\tvalue: UnknownValue,\n): value is FilledContentRelationshipField & OptionalLinkProperties => {\n\tif (value && typeof value === \"object\" && !(\"version\" in value)) {\n\t\tif (\n\t\t\t\"link_type\" in value &&\n\t\t\tvalue.link_type === LinkType.Document &&\n\t\t\t\"id\" in value &&\n\t\t\t\"type\" in value &&\n\t\t\t\"tags\" in value &&\n\t\t\t\"lang\" in value\n\t\t) {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n\n/**\n * Checks if a value is a Prismic document.\n *\n * @param value - Value to check.\n *\n * @returns `true` if `value` is a Prismic document, `false` otherwise.\n *\n * @internal\n * This is not an official helper function and it's only designed to work with internal processes.\n */\nexport const prismicDocument = (\n\tvalue: UnknownValue,\n): value is PrismicDocument => {\n\ttry {\n\t\treturn (\n\t\t\ttypeof value === \"object\" &&\n\t\t\tvalue !== null &&\n\t\t\t\"id\" in value &&\n\t\t\t\"href\" in value &&\n\t\t\ttypeof value.href === \"string\" &&\n\t\t\tnew URL(value.href) &&\n\t\t\t\"type\" in value &&\n\t\t\t\"lang\" in value &&\n\t\t\t\"tags\" in value &&\n\t\t\tArray.isArray(value.tags)\n\t\t)\n\t} catch {\n\t\treturn false\n\t}\n}\n","import type {\n\tMigrationImage,\n\tMigrationLinkToMedia,\n\tMigrationRTImageNode,\n} from \"../types/migration/Asset\"\nimport { PrismicMigrationAsset } from \"../types/migration/Asset\"\nimport type { MigrationContentRelationship } from \"../types/migration/ContentRelationship\"\nimport {\n\ttype InjectMigrationSpecificTypes,\n\tPrismicMigrationDocument,\n} from \"../types/migration/Document\"\nimport type { PrismicDocument } from \"../types/value/document\"\nimport type { GroupField } from \"../types/value/group\"\nimport { LinkType } from \"../types/value/link\"\nimport type { OptionalLinkProperties } from \"../types/value/link\"\nimport { RichTextNodeType } from \"../types/value/richText\"\nimport type { SliceZone } from \"../types/value/sliceZone\"\nimport type { AnyRegularField } from \"../types/value/types\"\n\nimport * as is from \"./isValue\"\n\n/**\n * Unknown value to check if it's a specific field type.\n *\n * @remarks\n * Explicit types are added to help ensure narrowing is done effectively.\n */\ntype UnknownValue =\n\t| PrismicDocument\n\t| InjectMigrationSpecificTypes<AnyRegularField | GroupField | SliceZone>\n\t| unknown\n\n/**\n * Checks if a value is a migration content relationship field.\n *\n * @remarks\n * `OptionalLinkProperties` is included because `MigrationContentRelationship`\n * may be a link field, not strictly a content relationship field.\n *\n * @param value - Value to check.\n *\n * @returns `true` if `value` is a migration content relationship field, `false`\n *   otherwise.\n *\n * @internal\n * This is not an official helper function and it's only designed to work with internal processes.\n */\nexport const contentRelationship = (\n\tvalue: UnknownValue,\n): value is MigrationContentRelationship & OptionalLinkProperties => {\n\treturn (\n\t\tvalue instanceof PrismicMigrationDocument ||\n\t\tis.prismicDocument(value) ||\n\t\t(typeof value === \"object\" &&\n\t\t\tvalue !== null &&\n\t\t\t\"link_type\" in value &&\n\t\t\tvalue.link_type === LinkType.Document &&\n\t\t\t\"id\" in value &&\n\t\t\t(contentRelationship(value.id) || typeof value.id === \"function\"))\n\t)\n}\n\n/**\n * Checks if a value is a migration image field.\n *\n * @param value - Value to check.\n *\n * @returns `true` if `value` is a migration image field, `false` otherwise.\n *\n * @internal\n * This is not an official helper function and it's only designed to work with internal processes.\n */\nexport const image = (value: UnknownValue): value is MigrationImage => {\n\treturn (\n\t\tvalue instanceof PrismicMigrationAsset ||\n\t\t(typeof value === \"object\" &&\n\t\t\tvalue !== null &&\n\t\t\t\"id\" in value &&\n\t\t\tObject.values(value).every(\n\t\t\t\t(maybeThumbnail) => maybeThumbnail instanceof PrismicMigrationAsset,\n\t\t\t))\n\t)\n}\n\n/**\n * Checks if a value is a migration link to media field.\n *\n * - @remarks `OptionalLinkProperties` is included because\n *   `MigrationContentRelationship` may be a link field, not strictly a content\n *   relationship field.\n *\n * @param value - Value to check.\n *\n * @returns `true` if `value` is a migration link to media field, `false`\n *   otherwise.\n *\n * @internal\n * This is not an official helper function and it's only designed to work with internal processes.\n */\nexport const linkToMedia = (\n\tvalue: UnknownValue,\n): value is MigrationLinkToMedia & OptionalLinkProperties => {\n\treturn (\n\t\ttypeof value === \"object\" &&\n\t\tvalue !== null &&\n\t\t\"id\" in value &&\n\t\tvalue.id instanceof PrismicMigrationAsset &&\n\t\t\"link_type\" in value &&\n\t\tvalue.link_type === LinkType.Media\n\t)\n}\n\n/**\n * Checks if a value is a migration rich text image node.\n *\n * @param value - Value to check.\n *\n * @returns `true` if `value` is a migration rich text image node, `false`\n *   otherwise.\n *\n * @internal\n * This is not an official helper function and it's only designed to work with internal processes.\n */\nexport const rtImageNode = (\n\tvalue: UnknownValue,\n): value is MigrationRTImageNode => {\n\treturn (\n\t\ttypeof value === \"object\" &&\n\t\tvalue !== null &&\n\t\t\"id\" in value &&\n\t\tvalue.id instanceof PrismicMigrationAsset &&\n\t\t\"type\" in value &&\n\t\tvalue.type === RichTextNodeType.image\n\t)\n}\n","import type { OptionalLinkProperties } from \"../types/value/link\"\n\n/**\n * Returns optional properties only available to link fields. Link fields can\n * have the same shape as content relationship and link to media fields,\n * requiring special treatment to extract link-specific properties.\n *\n * @param input - The content relationship or link to media field from which the\n *   link properties will be extracted.\n *\n * @returns Optional link properties that `input` might have.\n */\nexport const getOptionalLinkProperties = (\n\tinput: OptionalLinkProperties,\n): OptionalLinkProperties => {\n\tconst res: OptionalLinkProperties = {}\n\n\tif (\"text\" in input) {\n\t\tres.text = input.text\n\t}\n\n\tif (\"variant\" in input) {\n\t\tres.variant = input.variant\n\t}\n\n\treturn res\n}\n","import type { MigrationLinkToMediaField } from \"../types/migration/Asset\"\nimport {\n\ttype MigrationImage,\n\ttype MigrationLinkToMedia,\n\ttype MigrationRTImageNode,\n\tPrismicMigrationAsset,\n} from \"../types/migration/Asset\"\nimport type {\n\tMigrationContentRelationship,\n\tMigrationContentRelationshipField,\n} from \"../types/migration/ContentRelationship\"\nimport { PrismicMigrationDocument } from \"../types/migration/Document\"\nimport type { MaybeLink } from \"../types/migration/Link\"\nimport type { FilledImageFieldImage } from \"../types/value/image\"\nimport type { LinkField, OptionalLinkProperties } from \"../types/value/link\"\nimport { LinkType } from \"../types/value/link\"\nimport type { RTImageNode } from \"../types/value/richText\"\nimport { RichTextNodeType } from \"../types/value/richText\"\n\nimport * as isFilled from \"../helpers/isFilled\"\nimport type { Migration } from \"../Migration\"\n\nimport * as isMigration from \"./isMigrationValue\"\nimport { getOptionalLinkProperties } from \"./getOptionalLinkProperties\"\n\n/**\n * Resolves a migration content relationship to a content relationship field.\n *\n * @param relation - Content relationship to resolve.\n *\n * @returns Resolved content relationship field.\n */\nexport async function resolveMigrationContentRelationship(\n\trelation: MaybeLink<MigrationContentRelationship>,\n): Promise<MigrationContentRelationshipField & OptionalLinkProperties> {\n\tif (typeof relation === \"function\") {\n\t\treturn resolveMigrationContentRelationship(await relation())\n\t}\n\n\tif (relation instanceof PrismicMigrationDocument) {\n\t\treturn relation.document.id\n\t\t\t? { link_type: LinkType.Document, id: relation.document.id }\n\t\t\t: { link_type: LinkType.Any }\n\t}\n\n\tconst optionalLinkProperties =\n\t\trelation && \"link_type\" in relation\n\t\t\t? getOptionalLinkProperties(relation)\n\t\t\t: undefined\n\n\tif (relation) {\n\t\tif (\n\t\t\tisMigration.contentRelationship(relation.id) ||\n\t\t\ttypeof relation.id !== \"string\"\n\t\t) {\n\t\t\treturn {\n\t\t\t\t...optionalLinkProperties,\n\t\t\t\t...(await resolveMigrationContentRelationship(relation.id)),\n\t\t\t}\n\t\t}\n\n\t\t// This is only called when resolveMigrationContentRelationship recursively\n\t\t// calls itself from the statement above and the resolved content relation\n\t\t// is a Prismic document value.\n\t\treturn {\n\t\t\t...optionalLinkProperties,\n\t\t\tlink_type: LinkType.Document,\n\t\t\tid: relation.id,\n\t\t}\n\t}\n\n\treturn {\n\t\t...optionalLinkProperties,\n\t\tlink_type: LinkType.Any,\n\t}\n}\n\n/**\n * Resolves a migration image to an image field.\n *\n * @param migrationAsset - Asset to resolve.\n * @param migration - Migration instance.\n * @param withThumbnails - Whether to include thumbnails.\n *\n * @returns Resolved image field.\n */\nexport const resolveMigrationImage = (\n\timage: MigrationImage,\n\tmigration: Migration,\n\twithThumbnails?: boolean,\n): FilledImageFieldImage | undefined => {\n\tconst { id: master, ...thumbnails } =\n\t\timage instanceof PrismicMigrationAsset ? { id: image } : image\n\n\tconst asset = migration._assets.get(master.config.id)?.asset\n\tconst maybeInitialField = master.originalField\n\n\tif (asset) {\n\t\tconst parameters = (maybeInitialField?.url || asset.url).split(\"?\")[1]\n\t\tconst url = `${asset.url.split(\"?\")[0]}${parameters ? `?${parameters}` : \"\"}`\n\t\tconst dimensions: FilledImageFieldImage[\"dimensions\"] = {\n\t\t\twidth: asset.width!,\n\t\t\theight: asset.height!,\n\t\t}\n\t\tconst edit: FilledImageFieldImage[\"edit\"] =\n\t\t\tmaybeInitialField && \"edit\" in maybeInitialField\n\t\t\t\t? maybeInitialField?.edit\n\t\t\t\t: { x: 0, y: 0, zoom: 1, background: \"transparent\" }\n\n\t\t// We give priority to the asset's specific alt text, then the image's general alt text\n\t\tconst alt = master.config.alt || asset.alt || null\n\n\t\tconst resolvedThumbnails: Record<string, FilledImageFieldImage> = {}\n\t\tif (withThumbnails) {\n\t\t\tfor (const [name, thumbnail] of Object.entries(thumbnails)) {\n\t\t\t\tconst resolvedThumbnail = resolveMigrationImage(thumbnail, migration)\n\t\t\t\tif (resolvedThumbnail) {\n\t\t\t\t\tresolvedThumbnails[name] = resolvedThumbnail\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tid: asset.id,\n\t\t\turl,\n\t\t\tdimensions,\n\t\t\tedit,\n\t\t\talt: alt,\n\t\t\tcopyright: asset.credits || null,\n\t\t\t...resolvedThumbnails,\n\t\t}\n\t}\n}\n\n/**\n * Resolves a migration rich text image node to a regular rich text image node.\n *\n * @param rtImageNode - Migration rich text image node to resolve.\n * @param migration - Migration instance.\n *\n * @returns Resolved rich text image node.\n */\nexport const resolveMigrationRTImageNode = async (\n\trtImageNode: MigrationRTImageNode,\n\tmigration: Migration,\n): Promise<RTImageNode | undefined> => {\n\tconst image = resolveMigrationImage(rtImageNode.id, migration)\n\n\tif (image) {\n\t\tconst linkTo = (await resolveMigrationDocumentData(\n\t\t\trtImageNode.linkTo,\n\t\t\tmigration,\n\t\t)) as LinkField\n\n\t\treturn {\n\t\t\t...image,\n\t\t\ttype: RichTextNodeType.image,\n\t\t\tlinkTo: isFilled.link(linkTo) ? linkTo : undefined,\n\t\t}\n\t}\n}\n\n/**\n * Resolves a migration link to media to a regular link to media field.\n *\n * @param linkToMedia - Migration link to media to resolve.\n * @param migration - Migration instance.\n *\n * @returns Resolved link to media field.\n */\nexport const resolveMigrationLinkToMedia = (\n\tlinkToMedia: MaybeLink<MigrationLinkToMedia>,\n\tmigration: Migration,\n): MigrationLinkToMediaField => {\n\tconst asset = migration._assets.get(linkToMedia.id.config.id)?.asset\n\tconst optionalLinkProperties = getOptionalLinkProperties(linkToMedia)\n\n\tif (asset) {\n\t\treturn {\n\t\t\t...optionalLinkProperties,\n\t\t\tid: asset.id,\n\t\t\tlink_type: LinkType.Media,\n\t\t}\n\t}\n\n\treturn {\n\t\t...optionalLinkProperties,\n\t\tlink_type: LinkType.Any,\n\t}\n}\n\n/**\n * Resolves a migration document data to actual data ready to be sent to the\n * Migration API.\n *\n * @param input - Migration link to media to resolve.\n * @param migration - Migration instance.\n *\n * @returns Resolved data.\n */\nexport async function resolveMigrationDocumentData(\n\tinput: unknown,\n\tmigration: Migration,\n): Promise<unknown> {\n\t// Migration fields\n\tif (isMigration.contentRelationship(input)) {\n\t\treturn resolveMigrationContentRelationship(input)\n\t}\n\n\tif (isMigration.image(input)) {\n\t\treturn resolveMigrationImage(input, migration, true)\n\t}\n\n\tif (isMigration.linkToMedia(input)) {\n\t\treturn resolveMigrationLinkToMedia(input, migration)\n\t}\n\n\tif (isMigration.rtImageNode(input)) {\n\t\treturn resolveMigrationRTImageNode(input, migration)\n\t}\n\n\tif (typeof input === \"function\") {\n\t\treturn await resolveMigrationDocumentData(await input(), migration)\n\t}\n\n\t// Object traversing\n\tif (Array.isArray(input)) {\n\t\tconst res = []\n\n\t\tfor (const element of input) {\n\t\t\tres.push(await resolveMigrationDocumentData(element, migration))\n\t\t}\n\n\t\treturn res.filter(Boolean)\n\t}\n\n\tif (input && typeof input === \"object\") {\n\t\tconst res: Record<PropertyKey, unknown> = {}\n\n\t\tfor (const key in input) {\n\t\t\tres[key] = await resolveMigrationDocumentData(\n\t\t\t\tinput[key as keyof typeof input],\n\t\t\t\tmigration,\n\t\t\t)\n\t\t}\n\n\t\treturn res\n\t}\n\n\t// Primitives\n\treturn input\n}\n","import { devMsg } from \"./lib/devMsg\"\nimport { pLimit } from \"./lib/pLimit\"\nimport type { ResponseLike } from \"./lib/request\"\nimport { type RequestInitLike, request } from \"./lib/request\"\nimport {\n\tresolveMigrationContentRelationship,\n\tresolveMigrationDocumentData,\n} from \"./lib/resolveMigrationDocumentData\"\n\nimport type {\n\tAsset,\n\tPatchAssetParams,\n\tPostAssetParams,\n\tPostAssetResult,\n} from \"./types/api/asset/asset\"\nimport type {\n\tAssetTag,\n\tGetAssetTagsResult,\n\tPostAssetTagResult,\n} from \"./types/api/asset/tag\"\nimport { type PostDocumentResult } from \"./types/api/migration/document\"\nimport type { PrismicMigrationAsset } from \"./types/migration/Asset\"\nimport type {\n\tMigrationDocument,\n\tPendingPrismicDocument,\n\tPrismicMigrationDocument,\n} from \"./types/migration/Document\"\nimport type { PrismicDocument } from \"./types/value/document\"\n\nimport {\n\tForbiddenError,\n\tInvalidDataError,\n\tNotFoundError,\n\tPrismicError,\n} from \"./errors\"\n\nimport { name, version } from \"../package.json\"\n\nimport { Client } from \"./Client\"\nimport type { ClientConfig, FetchParams } from \"./Client\"\nimport type { Migration } from \"./Migration\"\n// oxlint-disable-next-line no-unused-vars\nimport type { createMigration } from \"./createMigration\"\n\nconst CLIENT_IDENTIFIER = `${name.replace(\"@\", \"\").replace(\"/\", \"-\")}/${version}`\n\n/**\n * Extracts one or more Prismic document types that match a given Prismic\n * document type. If no matches are found, no extraction is performed and the\n * union of all provided Prismic document types are returned.\n *\n * @typeParam TDocuments - Prismic document types from which to extract.\n * @typeParam TDocumentType - Type(s) to match `TDocuments` against.\n */\ntype ExtractDocumentType<\n\tTDocuments extends { type: string },\n\tTDocumentType extends TDocuments[\"type\"],\n> =\n\tExtract<TDocuments, { type: TDocumentType }> extends never\n\t\t? TDocuments\n\t\t: Extract<TDocuments, { type: TDocumentType }>\n\n/**\n * Utility type to construct events reported by the migration process.\n */\ntype MigrateReporterEvent<\n\tTType extends string,\n\tTData = never,\n> = TData extends never\n\t? { type: TType }\n\t: {\n\t\t\ttype: TType\n\t\t\tdata: TData\n\t\t}\n\n/**\n * A map of event types and their data reported by the migration process.\n */\ntype MigrateReporterEventMap = {\n\tstart: {\n\t\tpending: {\n\t\t\tdocuments: number\n\t\t\tassets: number\n\t\t}\n\t}\n\tend: {\n\t\tmigrated: {\n\t\t\tdocuments: number\n\t\t\tassets: number\n\t\t}\n\t}\n\t\"assets:creating\": {\n\t\tcurrent: number\n\t\tremaining: number\n\t\ttotal: number\n\t\tasset: PrismicMigrationAsset\n\t}\n\t\"assets:created\": {\n\t\tcreated: number\n\t}\n\t\"documents:masterLocale\": {\n\t\tmasterLocale: string\n\t}\n\t\"documents:creating\": {\n\t\tcurrent: number\n\t\tremaining: number\n\t\ttotal: number\n\t\tdocument: PrismicMigrationDocument\n\t}\n\t\"documents:created\": {\n\t\tcreated: number\n\t}\n\t\"documents:updating\": {\n\t\tcurrent: number\n\t\tremaining: number\n\t\ttotal: number\n\t\tdocument: PrismicMigrationDocument\n\t}\n\t\"documents:updated\": {\n\t\tupdated: number\n\t}\n}\n\n/**\n * Available event types reported by the migration process.\n */\ntype MigrateReporterEventTypes = keyof MigrateReporterEventMap\n\n/**\n * All events reported by the migration process. Events can be listened to by\n * providing a `reporter` function to the `migrate` method.\n */\nexport type MigrateReporterEvents = {\n\t[K in MigrateReporterEventTypes]: MigrateReporterEvent<\n\t\tK,\n\t\tMigrateReporterEventMap[K]\n\t>\n}[MigrateReporterEventTypes]\n\n/**\n * Additional parameters for creating an asset in the Prismic media library.\n */\nexport type CreateAssetParams = {\n\t/**\n\t * Asset notes.\n\t */\n\tnotes?: string\n\n\t/**\n\t * Asset credits.\n\t */\n\tcredits?: string\n\n\t/**\n\t * Asset alt text.\n\t */\n\talt?: string\n\n\t/**\n\t * Asset tags.\n\t */\n\ttags?: string[]\n}\n\n/**\n * Configuration for clients that determine how content is queried.\n */\nexport type WriteClientConfig = {\n\t/**\n\t * A Prismic write token that allows writing content to the repository.\n\t */\n\twriteToken: string\n\n\t/**\n\t * The Prismic Asset API endpoint.\n\t *\n\t * @defaultValue `\"https://asset-api.prismic.io/\"`\n\t *\n\t * @see Prismic Asset API technical reference: {@link https://prismic.io/docs/asset-api-technical-reference}\n\t */\n\tassetAPIEndpoint?: string\n\n\t/**\n\t * The Prismic Migration API endpoint.\n\t *\n\t * @defaultValue `\"https://migration.prismic.io/\"`\n\t *\n\t * @see Prismic Migration API technical reference: {@link https://prismic.io/docs/migration-api-technical-reference}\n\t */\n\tmigrationAPIEndpoint?: string\n} & ClientConfig\n\n/**\n * A client that allows querying and writing content to a Prismic repository.\n *\n * If used in an environment where a global `fetch` function is unavailable,\n * such as Node.js, the `fetch` option must be provided as part of the `options`\n * parameter.\n *\n * @typeParam TDocuments - Document types that are registered for the Prismic\n *   repository. Query methods will automatically be typed based on this type.\n */\nexport class WriteClient<\n\tTDocuments extends PrismicDocument = PrismicDocument,\n> extends Client<TDocuments> {\n\twriteToken: string\n\n\tassetAPIEndpoint = \"https://asset-api.prismic.io/\"\n\tmigrationAPIEndpoint = \"https://migration.prismic.io/\"\n\n\t/**\n\t * Creates a Prismic client that can be used to query and write content to a\n\t * repository.\n\t *\n\t * If used in an environment where a global `fetch` function is unavailable,\n\t * such as in some Node.js versions, the `fetch` option must be provided as\n\t * part of the `options` parameter.\n\t *\n\t * @param repositoryName - The Prismic repository name for the repository.\n\t * @param options - Configuration that determines how content will be queried\n\t *   from and written to the Prismic repository.\n\t *\n\t * @returns A client that can query and write content to the repository.\n\t */\n\tconstructor(repositoryName: string, options: WriteClientConfig) {\n\t\tsuper(repositoryName, options)\n\n\t\tif (typeof globalThis.window !== \"undefined\") {\n\t\t\tconsole.warn(\n\t\t\t\t`[@prismicio/client] Prismic write client appears to be running in a browser environment. This is not recommended as it exposes your write token. Consider using Prismic write client in a server environment only, preferring the regular client for browser environment. For more details, see ${devMsg(\"avoid-write-client-in-browser\")}`,\n\t\t\t)\n\t\t}\n\n\t\tthis.writeToken = options.writeToken\n\n\t\tif (options.assetAPIEndpoint) {\n\t\t\tthis.assetAPIEndpoint = `${options.assetAPIEndpoint}/`\n\t\t}\n\n\t\tif (options.migrationAPIEndpoint) {\n\t\t\tthis.migrationAPIEndpoint = `${options.migrationAPIEndpoint}/`\n\t\t}\n\t}\n\n\t/**\n\t * Creates a migration release on the Prismic repository based on the provided\n\t * prepared migration.\n\t *\n\t * @param migration - A migration prepared with {@link createMigration}.\n\t * @param params - An event listener and additional fetch parameters.\n\t *\n\t * @see Prismic Migration API technical reference: {@link https://prismic.io/docs/migration-api-technical-reference}\n\t */\n\tasync migrate(\n\t\tmigration: Migration<TDocuments>,\n\t\tparams: {\n\t\t\treporter?: (event: MigrateReporterEvents) => void\n\t\t} & FetchParams = {},\n\t): Promise<void> {\n\t\tparams.reporter?.({\n\t\t\ttype: \"start\",\n\t\t\tdata: {\n\t\t\t\tpending: {\n\t\t\t\t\tdocuments: migration._documents.length,\n\t\t\t\t\tassets: migration._assets.size,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\n\t\tawait this.migrateCreateAssets(migration, params)\n\t\tawait this.migrateCreateDocuments(migration, params)\n\t\tawait this.migrateUpdateDocuments(migration, params)\n\n\t\tparams.reporter?.({\n\t\t\ttype: \"end\",\n\t\t\tdata: {\n\t\t\t\tmigrated: {\n\t\t\t\t\tdocuments: migration._documents.length,\n\t\t\t\t\tassets: migration._assets.size,\n\t\t\t\t},\n\t\t\t},\n\t\t})\n\t}\n\n\t/**\n\t * Creates assets in the Prismic repository's media library.\n\t *\n\t * @param migration - A migration prepared with {@link createMigration}.\n\t * @param params - An event listener and additional fetch parameters.\n\t *\n\t * @internal This method is one of the step performed by the {@link migrate} method.\n\t */\n\tprivate async migrateCreateAssets(\n\t\tmigration: Migration<TDocuments>,\n\t\t{\n\t\t\treporter,\n\t\t\t...fetchParams\n\t\t}: { reporter?: (event: MigrateReporterEvents) => void } & FetchParams = {},\n\t): Promise<void> {\n\t\tlet created = 0\n\t\tfor (const [_, migrationAsset] of migration._assets) {\n\t\t\treporter?.({\n\t\t\t\ttype: \"assets:creating\",\n\t\t\t\tdata: {\n\t\t\t\t\tcurrent: ++created,\n\t\t\t\t\tremaining: migration._assets.size - created,\n\t\t\t\t\ttotal: migration._assets.size,\n\t\t\t\t\tasset: migrationAsset,\n\t\t\t\t},\n\t\t\t})\n\n\t\t\tconst { file, filename, notes, credits, alt, tags } =\n\t\t\t\tmigrationAsset.config\n\n\t\t\tlet resolvedFile: PostAssetParams[\"file\"] | File\n\t\t\tif (typeof file === \"string\") {\n\t\t\t\tlet url: URL | undefined\n\t\t\t\ttry {\n\t\t\t\t\turl = new URL(file)\n\t\t\t\t} catch {\n\t\t\t\t\t// noop only on invalid URL, fetch errors will throw in the next if statement\n\t\t\t\t}\n\n\t\t\t\tif (url) {\n\t\t\t\t\t// File is a URL, fetch it\n\t\t\t\t\tresolvedFile = await this.fetchForeignAsset(\n\t\t\t\t\t\turl.toString(),\n\t\t\t\t\t\tfetchParams,\n\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\t// File is actual file content, use it as-is\n\t\t\t\t\tresolvedFile = file\n\t\t\t\t}\n\t\t\t} else if (file instanceof URL) {\n\t\t\t\t// File is a URL instance, fetch it\n\t\t\t\tresolvedFile = await this.fetchForeignAsset(\n\t\t\t\t\tfile.toString(),\n\t\t\t\t\tfetchParams,\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tresolvedFile = file\n\t\t\t}\n\n\t\t\tconst asset = await this.createAsset(resolvedFile, filename, {\n\t\t\t\tnotes,\n\t\t\t\tcredits,\n\t\t\t\talt,\n\t\t\t\ttags,\n\t\t\t\t...fetchParams,\n\t\t\t})\n\n\t\t\tmigrationAsset.asset = asset\n\t\t}\n\n\t\treporter?.({\n\t\t\ttype: \"assets:created\",\n\t\t\tdata: {\n\t\t\t\tcreated,\n\t\t\t},\n\t\t})\n\t}\n\n\t/**\n\t * Creates documents in the Prismic repository's migration release.\n\t *\n\t * @param migration - A migration prepared with {@link createMigration}.\n\t * @param params - An event listener and additional fetch parameters.\n\t *\n\t * @internal This method is one of the step performed by the {@link migrate} method.\n\t */\n\tprivate async migrateCreateDocuments(\n\t\tmigration: Migration<TDocuments>,\n\t\t{\n\t\t\treporter,\n\t\t\t...fetchParams\n\t\t}: { reporter?: (event: MigrateReporterEvents) => void } & FetchParams = {},\n\t): Promise<void> {\n\t\t// Resolve master locale\n\t\tconst repository = await this.getRepository(fetchParams)\n\t\tconst masterLocale = repository.languages[0].id\n\t\treporter?.({\n\t\t\ttype: \"documents:masterLocale\",\n\t\t\tdata: {\n\t\t\t\tmasterLocale,\n\t\t\t},\n\t\t})\n\n\t\tconst documentsToCreate: PrismicMigrationDocument<TDocuments>[] = []\n\t\t// We create an array with non-master locale documents last because\n\t\t// we need their master locale document to be created first.\n\t\tfor (const doc of migration._documents) {\n\t\t\tif (!doc.document.id) {\n\t\t\t\tif (doc.document.lang === masterLocale) {\n\t\t\t\t\tdocumentsToCreate.unshift(doc)\n\t\t\t\t} else {\n\t\t\t\t\tdocumentsToCreate.push(doc)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet created = 0\n\t\tfor (const doc of documentsToCreate) {\n\t\t\treporter?.({\n\t\t\t\ttype: \"documents:creating\",\n\t\t\t\tdata: {\n\t\t\t\t\tcurrent: ++created,\n\t\t\t\t\tremaining: documentsToCreate.length - created,\n\t\t\t\t\ttotal: documentsToCreate.length,\n\t\t\t\t\tdocument: doc,\n\t\t\t\t},\n\t\t\t})\n\n\t\t\t// Resolve master language document ID for non-master locale documents\n\t\t\tlet masterLanguageDocumentID: string | undefined\n\t\t\tif (doc.masterLanguageDocument) {\n\t\t\t\tconst masterLanguageDocument =\n\t\t\t\t\tawait resolveMigrationContentRelationship(doc.masterLanguageDocument)\n\n\t\t\t\tmasterLanguageDocumentID =\n\t\t\t\t\t\"id\" in masterLanguageDocument ? masterLanguageDocument.id : undefined\n\t\t\t} else if (doc.originalPrismicDocument) {\n\t\t\t\tconst maybeOriginalID =\n\t\t\t\t\tdoc.originalPrismicDocument.alternate_languages.find(\n\t\t\t\t\t\t({ lang }) => lang === masterLocale,\n\t\t\t\t\t)?.id\n\n\t\t\t\tif (maybeOriginalID) {\n\t\t\t\t\tmasterLanguageDocumentID =\n\t\t\t\t\t\tmigration._getByOriginalID(maybeOriginalID)?.document.id\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst { id } = await this.createDocument(\n\t\t\t\t// We'll upload documents data later on.\n\t\t\t\t{ ...doc.document, data: {} },\n\t\t\t\tdoc.title!,\n\t\t\t\t{\n\t\t\t\t\tmasterLanguageDocumentID,\n\t\t\t\t\t...fetchParams,\n\t\t\t\t},\n\t\t\t)\n\n\t\t\tdoc.document.id = id\n\t\t}\n\n\t\treporter?.({\n\t\t\ttype: \"documents:created\",\n\t\t\tdata: { created },\n\t\t})\n\t}\n\n\t/**\n\t * Updates documents in the Prismic repository's migration release with their\n\t * patched data.\n\t *\n\t * @param migration - A migration prepared with {@link createMigration}.\n\t * @param params - An event listener and additional fetch parameters.\n\t *\n\t * @internal This method is one of the step performed by the {@link migrate} method.\n\t */\n\tprivate async migrateUpdateDocuments(\n\t\tmigration: Migration<TDocuments>,\n\t\t{\n\t\t\treporter,\n\t\t\t...fetchParams\n\t\t}: { reporter?: (event: MigrateReporterEvents) => void } & FetchParams = {},\n\t): Promise<void> {\n\t\tlet i = 0\n\t\tfor (const doc of migration._documents) {\n\t\t\treporter?.({\n\t\t\t\ttype: \"documents:updating\",\n\t\t\t\tdata: {\n\t\t\t\t\tcurrent: ++i,\n\t\t\t\t\tremaining: migration._documents.length - i,\n\t\t\t\t\ttotal: migration._documents.length,\n\t\t\t\t\tdocument: doc,\n\t\t\t\t},\n\t\t\t})\n\n\t\t\tawait this.updateDocument(\n\t\t\t\tdoc.document.id!,\n\t\t\t\t// We need to forward again document name and tags to update them\n\t\t\t\t// in case the document already existed during the previous step.\n\t\t\t\t{\n\t\t\t\t\t...doc.document,\n\t\t\t\t\tdocumentTitle: doc.title,\n\t\t\t\t\tdata: await resolveMigrationDocumentData(\n\t\t\t\t\t\tdoc.document.data,\n\t\t\t\t\t\tmigration,\n\t\t\t\t\t),\n\t\t\t\t},\n\t\t\t\tfetchParams,\n\t\t\t)\n\t\t}\n\n\t\treporter?.({\n\t\t\ttype: \"documents:updated\",\n\t\t\tdata: {\n\t\t\t\tupdated: migration._documents.length,\n\t\t\t},\n\t\t})\n\t}\n\n\t/**\n\t * Creates an asset in the Prismic media library.\n\t *\n\t * @param file - The file to upload as an asset.\n\t * @param filename - The filename of the asset.\n\t * @param params - Additional asset data and fetch parameters.\n\t *\n\t * @returns The created asset.\n\t */\n\tprivate async createAsset(\n\t\tfile: PostAssetParams[\"file\"] | File,\n\t\tfilename: string,\n\t\t{\n\t\t\tnotes,\n\t\t\tcredits,\n\t\t\talt,\n\t\t\ttags,\n\t\t\t...params\n\t\t}: CreateAssetParams & FetchParams = {},\n\t): Promise<Asset> {\n\t\tconst url = new URL(\"assets\", this.assetAPIEndpoint)\n\n\t\tconst formData = new FormData()\n\t\tformData.append(\n\t\t\t\"file\",\n\t\t\tnew File([file], filename, {\n\t\t\t\ttype: file instanceof File ? file.type : undefined,\n\t\t\t}),\n\t\t)\n\n\t\tif (notes) {\n\t\t\tformData.append(\"notes\", notes)\n\t\t}\n\n\t\tif (credits) {\n\t\t\tformData.append(\"credits\", credits)\n\t\t}\n\n\t\tif (alt) {\n\t\t\tformData.append(\"alt\", alt)\n\t\t}\n\n\t\tconst response = await this.#request(url, params, {\n\t\t\tmethod: \"POST\",\n\t\t\tbody: formData,\n\t\t})\n\t\tswitch (response.status) {\n\t\t\tcase 200: {\n\t\t\t\tconst asset = (await response.json()) as PostAssetResult\n\n\t\t\t\tif (tags && tags.length) {\n\t\t\t\t\treturn this.updateAsset(asset.id, { tags })\n\t\t\t\t}\n\n\t\t\t\treturn asset\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\treturn await this.#handleAssetAPIError(response)\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Updates an asset in the Prismic media library.\n\t *\n\t * @param id - The ID of the asset to update.\n\t * @param params - The asset data to update and additional fetch parameters.\n\t *\n\t * @returns The updated asset.\n\t */\n\tprivate async updateAsset(\n\t\tid: string,\n\t\t{\n\t\t\tnotes,\n\t\t\tcredits,\n\t\t\talt,\n\t\t\tfilename,\n\t\t\ttags,\n\t\t\t...params\n\t\t}: PatchAssetParams & FetchParams = {},\n\t): Promise<Asset> {\n\t\tconst url = new URL(`assets/${id}`, this.assetAPIEndpoint)\n\n\t\t// Resolve tags if any and create missing ones\n\t\tif (tags && tags.length) {\n\t\t\ttags = await this.resolveAssetTagIDs(tags, {\n\t\t\t\tcreateTags: true,\n\t\t\t\t...params,\n\t\t\t})\n\t\t}\n\n\t\tconst response = await this.#request(url, params, {\n\t\t\tmethod: \"PATCH\",\n\t\t\tbody: JSON.stringify({\n\t\t\t\tnotes,\n\t\t\t\tcredits,\n\t\t\t\talt,\n\t\t\t\tfilename,\n\t\t\t\ttags,\n\t\t\t}),\n\t\t\theaders: {\n\t\t\t\t\"content-type\": \"application/json\",\n\t\t\t},\n\t\t})\n\t\tswitch (response.status) {\n\t\t\tcase 200: {\n\t\t\t\treturn (await response.json()) as Asset\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\treturn await this.#handleAssetAPIError(response)\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Fetches a foreign asset from a URL.\n\t *\n\t * @param url - The URL of the asset to fetch.\n\t * @param params - Additional fetch parameters.\n\t *\n\t * @returns A file representing the fetched asset.\n\t */\n\tprivate async fetchForeignAsset(\n\t\turl: string,\n\t\tparams: FetchParams = {},\n\t): Promise<Blob> {\n\t\tconst res = await this.#request(new URL(url), params)\n\n\t\tif (!res.ok) {\n\t\t\tthrow new PrismicError(\"Could not fetch foreign asset\", url, undefined)\n\t\t}\n\n\t\tconst blob = await res.blob()\n\n\t\t// Ensure a correct content type is attached to the blob.\n\t\treturn new File([blob], \"\", {\n\t\t\ttype: res.headers.get(\"content-type\") || undefined,\n\t\t})\n\t}\n\n\t/**\n\t * {@link resolveAssetTagIDs} rate limiter.\n\t */\n\tprivate _resolveAssetTagIDsLimit = pLimit()\n\n\t/**\n\t * Resolves asset tag IDs from tag names.\n\t *\n\t * @param tagNames - An array of tag names to resolve.\n\t * @param params - Whether or not missing tags should be created and\n\t *   additional fetch parameters.\n\t *\n\t * @returns An array of resolved tag IDs.\n\t */\n\tprivate async resolveAssetTagIDs(\n\t\ttagNames: string[] = [],\n\t\t{ createTags, ...params }: { createTags?: boolean } & FetchParams = {},\n\t): Promise<string[]> {\n\t\treturn this._resolveAssetTagIDsLimit(async () => {\n\t\t\tconst existingTags = await this.getAssetTags(params)\n\t\t\tconst existingTagMap: Record<string, AssetTag> = {}\n\t\t\tfor (const tag of existingTags) {\n\t\t\t\texistingTagMap[tag.name] = tag\n\t\t\t}\n\n\t\t\tconst resolvedTagIDs = []\n\t\t\tfor (const tagName of tagNames) {\n\t\t\t\t// Tag does not exists yet, we create it if `createTags` is set\n\t\t\t\tif (!existingTagMap[tagName] && createTags) {\n\t\t\t\t\texistingTagMap[tagName] = await this.createAssetTag(tagName, params)\n\t\t\t\t}\n\n\t\t\t\t// Add tag if found\n\t\t\t\tif (existingTagMap[tagName]) {\n\t\t\t\t\tresolvedTagIDs.push(existingTagMap[tagName].id)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn resolvedTagIDs\n\t\t})\n\t}\n\n\t/**\n\t * Creates a tag in the Asset API.\n\t *\n\t * @remarks\n\t * Tags should be at least 3 characters long and 20 characters at most.\n\t *\n\t * @param name - The name of the tag to create.\n\t * @param params - Additional fetch parameters.\n\t *\n\t * @returns The created tag.\n\t */\n\tprivate async createAssetTag(\n\t\tname: string,\n\t\tparams?: FetchParams,\n\t): Promise<AssetTag> {\n\t\tconst url = new URL(\"tags\", this.assetAPIEndpoint)\n\n\t\tconst response = await this.#request(url, params, {\n\t\t\tmethod: \"POST\",\n\t\t\tbody: JSON.stringify({ name }),\n\t\t\theaders: {\n\t\t\t\t\"content-type\": \"application/json\",\n\t\t\t},\n\t\t})\n\t\tswitch (response.status) {\n\t\t\tcase 201: {\n\t\t\t\treturn (await response.json()) as PostAssetTagResult\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\treturn await this.#handleAssetAPIError(response)\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Queries existing tags from the Asset API.\n\t *\n\t * @param params - Additional fetch parameters.\n\t *\n\t * @returns An array of existing tags.\n\t */\n\tprivate async getAssetTags(params?: FetchParams): Promise<AssetTag[]> {\n\t\tconst url = new URL(\"tags\", this.assetAPIEndpoint)\n\n\t\tconst response = await this.#request(url, params)\n\t\tswitch (response.status) {\n\t\t\tcase 200: {\n\t\t\t\tconst json = (await response.json()) as GetAssetTagsResult\n\n\t\t\t\treturn json.items\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\treturn await this.#handleAssetAPIError(response)\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates a document in the repository's migration release.\n\t *\n\t * @typeParam TType - Type of Prismic documents to create.\n\t *\n\t * @param document - The document to create.\n\t * @param documentTitle - The title of the document to create which will be\n\t *   displayed in the editor.\n\t * @param params - Document master language document ID and additional fetch\n\t *   parameters.\n\t *\n\t * @returns The ID of the created document.\n\t *\n\t * @see Prismic Migration API technical reference: {@link https://prismic.io/docs/migration-api-technical-reference}\n\t */\n\tprivate async createDocument<TType extends TDocuments[\"type\"]>(\n\t\tdocument: PendingPrismicDocument<ExtractDocumentType<TDocuments, TType>>,\n\t\tdocumentTitle: string,\n\t\t{\n\t\t\tmasterLanguageDocumentID,\n\t\t\t...params\n\t\t}: { masterLanguageDocumentID?: string } & FetchParams = {},\n\t): Promise<{ id: string }> {\n\t\tconst url = new URL(\"documents\", this.migrationAPIEndpoint)\n\n\t\tconst response = await this.#request(url, params, {\n\t\t\tmethod: \"POST\",\n\t\t\tbody: JSON.stringify({\n\t\t\t\ttitle: documentTitle,\n\t\t\t\ttype: document.type,\n\t\t\t\tuid: document.uid || undefined,\n\t\t\t\tlang: document.lang,\n\t\t\t\talternate_language_id: masterLanguageDocumentID,\n\t\t\t\ttags: document.tags,\n\t\t\t\tdata: document.data,\n\t\t\t}),\n\t\t\theaders: {\n\t\t\t\t\"content-type\": \"application/json\",\n\t\t\t\t\"x-client\": CLIENT_IDENTIFIER,\n\t\t\t},\n\t\t})\n\t\tswitch (response.status) {\n\t\t\tcase 201: {\n\t\t\t\tconst json = (await response.json()) as PostDocumentResult\n\n\t\t\t\treturn { id: json.id }\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\treturn await this.#handleMigrationAPIError(response)\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Updates an existing document in the repository's migration release.\n\t *\n\t * @typeParam TType - Type of Prismic documents to update.\n\t *\n\t * @param id - The ID of the document to update.\n\t * @param document - The document content to update.\n\t * @param params - Additional fetch parameters.\n\t *\n\t * @see Prismic Migration API technical reference: {@link https://prismic.io/docs/migration-api-technical-reference}\n\t */\n\tprivate async updateDocument<TType extends TDocuments[\"type\"]>(\n\t\tid: string,\n\t\tdocument: MigrationDocument<ExtractDocumentType<TDocuments, TType>> & {\n\t\t\tdocumentTitle?: string\n\t\t},\n\t\tparams?: FetchParams,\n\t): Promise<void> {\n\t\tconst url = new URL(`documents/${id}`, this.migrationAPIEndpoint)\n\n\t\tconst response = await this.#request(url, params, {\n\t\t\tmethod: \"PUT\",\n\t\t\tbody: JSON.stringify({\n\t\t\t\ttitle: document.documentTitle,\n\t\t\t\tuid: document.uid || undefined,\n\t\t\t\ttags: document.tags,\n\t\t\t\tdata: document.data,\n\t\t\t}),\n\t\t\theaders: {\n\t\t\t\t\"content-type\": \"application/json\",\n\t\t\t\t\"x-client\": CLIENT_IDENTIFIER,\n\t\t\t},\n\t\t})\n\t\tswitch (response.status) {\n\t\t\tcase 200: {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\tawait this.#handleMigrationAPIError(response)\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Makes an authenticated HTTP request for write operations using the client's\n\t * configured fetch function and options.\n\t *\n\t * @param url - The URL to request.\n\t * @param params - Fetch options from the user.\n\t * @param init - Additional fetch options to merge with the user-provided\n\t *   options.\n\t *\n\t * @returns The response from the fetch request.\n\t */\n\tasync #request(\n\t\turl: URL,\n\t\tparams?: FetchParams,\n\t\tinit?: RequestInitLike,\n\t): Promise<ResponseLike> {\n\t\treturn await request(\n\t\t\turl,\n\t\t\t{\n\t\t\t\t...this.fetchOptions,\n\t\t\t\t...params?.fetchOptions,\n\t\t\t\t...init,\n\t\t\t\theaders: {\n\t\t\t\t\t...this.fetchOptions?.headers,\n\t\t\t\t\t...params?.fetchOptions?.headers,\n\t\t\t\t\t...init?.headers,\n\t\t\t\t\trepository: this.repositoryName,\n\t\t\t\t\tauthorization: `Bearer ${this.writeToken}`,\n\t\t\t\t},\n\t\t\t\tsignal:\n\t\t\t\t\tparams?.fetchOptions?.signal ||\n\t\t\t\t\tparams?.signal ||\n\t\t\t\t\tthis.fetchOptions?.signal,\n\t\t\t},\n\t\t\tthis.fetchFn,\n\t\t)\n\t}\n\n\t/**\n\t * Handles error responses from the Asset API with comprehensive error\n\t * parsing.\n\t *\n\t * @param response - The HTTP response from the Asset API.\n\t *\n\t * @throws {@link InvalidDataError} For 400 errors.\n\t * @throws {@link ForbiddenError} For 401 and 403 errors.\n\t * @throws {@link NotFoundError} For 404 errors.\n\t * @throws {@link PrismicError} For 500, 503, and other unexpected errors.\n\t */\n\tasync #handleAssetAPIError(response: ResponseLike): Promise<never> {\n\t\tconst json = await response.json()\n\t\tswitch (response.status) {\n\t\t\tcase 401:\n\t\t\tcase 403:\n\t\t\t\tthrow new ForbiddenError(json.error, response.url, json)\n\n\t\t\tcase 404:\n\t\t\t\tthrow new NotFoundError(json.error, response.url, json)\n\n\t\t\tcase 400:\n\t\t\t\tthrow new InvalidDataError(json.error, response.url, json)\n\n\t\t\tcase 500:\n\t\t\tcase 503:\n\t\t\tdefault:\n\t\t\t\tthrow new PrismicError(json.error, response.url, json)\n\t\t}\n\t}\n\n\t/**\n\t * Handles error responses from the Migration API with comprehensive error\n\t * parsing.\n\t *\n\t * @param response - The HTTP response from the Migration API.\n\t *\n\t * @throws {@link InvalidDataError} For 400 errors.\n\t * @throws {@link ForbiddenError} For 401 and 403 errors.\n\t * @throws {@link NotFoundError} For 404 errors.\n\t * @throws {@link PrismicError} For 500, and other unexpected errors.\n\t */\n\tasync #handleMigrationAPIError(response: ResponseLike): Promise<never> {\n\t\tconst payload = (await response.json()) as unknown\n\n\t\t// Common message across all branches\n\t\tconst message = (payload as { message?: string }).message\n\n\t\tswitch (response.status) {\n\t\t\tcase 400: {\n\t\t\t\tthrow new InvalidDataError(message, response.url, payload)\n\t\t\t}\n\n\t\t\tcase 401: {\n\t\t\t\tthrow new ForbiddenError(message, response.url, payload)\n\t\t\t}\n\n\t\t\tcase 403: {\n\t\t\t\t// The lambda authorizer uses an uppercase key, remove this once it is fixed\n\t\t\t\tconst msg = message ?? (payload as { Message?: string }).Message\n\t\t\t\tthrow new ForbiddenError(msg, response.url, payload)\n\t\t\t}\n\n\t\t\tcase 404: {\n\t\t\t\tthrow new NotFoundError(message, response.url, payload)\n\t\t\t}\n\n\t\t\tcase 500:\n\t\t\tdefault: {\n\t\t\t\tthrow new PrismicError(message, response.url, payload)\n\t\t\t}\n\t\t}\n\t}\n}\n","import type { PrismicDocument } from \"./types/value/document\"\n\nimport type { WriteClientConfig } from \"./WriteClient\"\nimport { WriteClient } from \"./WriteClient\"\n\n/**\n * Type definitions for the `createWriteClient()` function. May be augmented by\n * third-party libraries.\n */\nexport interface CreateWriteClient {\n\t<TDocuments extends PrismicDocument>(\n\t\t...args: ConstructorParameters<typeof WriteClient>\n\t): WriteClient<TDocuments>\n}\n\n/**\n * Creates a Prismic client that can be used to query and write content to a\n * repository.\n *\n * @remarks\n * This client works in environments supporting File, Blob, and FormData,\n * including Node.js 20 and later.\n *\n * @example\n *\n * ```ts\n * createWriteClient(\"qwerty\", { writeToken: \"***\" })\n * ```\n *\n * @typeParam TDocuments - A union of Prismic document types for the repository.\n *\n * @param repositoryName - The Prismic repository name for the repository.\n * @param options - Configuration that determines how content will be queried\n *   from and written to the Prismic repository.\n *\n * @returns A client that can query and write content to the repository.\n */\nexport const createWriteClient: CreateWriteClient = <\n\tTDocuments extends PrismicDocument,\n>(\n\trepositoryName: string,\n\toptions: WriteClientConfig,\n) => new WriteClient<TDocuments>(repositoryName, options)\n","import { PrismicError } from \"../errors\"\n\nimport type { CreateAssetParams } from \"../WriteClient\"\n\n/**\n * Max length for asset notes accepted by the API.\n */\nconst ASSET_NOTES_MAX_LENGTH = 500\n\n/**\n * Max length for asset credits accepted by the API.\n */\nconst ASSET_CREDITS_MAX_LENGTH = 500\n\n/**\n * Max length for asset alt text accepted by the API.\n */\nconst ASSET_ALT_MAX_LENGTH = 500\n\n/**\n * Min length for asset tags accepted by the API.\n */\nconst ASSET_TAG_MIN_LENGTH = 3\n\n/**\n * Max length for asset tags accepted by the API.\n */\nconst ASSET_TAG_MAX_LENGTH = 20\n\n/**\n * Validates an asset's metadata, throwing an error if any of the metadata are\n * invalid.\n *\n * @param assetMetadata - The asset metadata to validate.\n *\n * @internal\n */\nexport const validateAssetMetadata = ({\n\tnotes,\n\tcredits,\n\talt,\n\ttags,\n}: CreateAssetParams): void => {\n\tconst errors: string[] = []\n\n\tif (notes && notes.length > ASSET_NOTES_MAX_LENGTH) {\n\t\terrors.push(\n\t\t\t`\\`notes\\` must be at most ${ASSET_NOTES_MAX_LENGTH} characters`,\n\t\t)\n\t}\n\n\tif (credits && credits.length > ASSET_CREDITS_MAX_LENGTH) {\n\t\terrors.push(\n\t\t\t`\\`credits\\` must be at most ${ASSET_CREDITS_MAX_LENGTH} characters`,\n\t\t)\n\t}\n\n\tif (alt && alt.length > ASSET_ALT_MAX_LENGTH) {\n\t\terrors.push(`\\`alt\\` must be at most ${ASSET_ALT_MAX_LENGTH} characters`)\n\t}\n\n\tif (\n\t\ttags &&\n\t\ttags.length &&\n\t\ttags.some(\n\t\t\t(tag) =>\n\t\t\t\ttag.length < ASSET_TAG_MIN_LENGTH || tag.length > ASSET_TAG_MAX_LENGTH,\n\t\t)\n\t) {\n\t\terrors.push(\n\t\t\t`tags must be at least 3 characters long and 20 characters at most`,\n\t\t)\n\t}\n\n\tif (errors.length) {\n\t\tthrow new PrismicError(\n\t\t\t`Errors validating asset metadata: ${errors.join(\", \")}`,\n\t\t\tundefined,\n\t\t\t{ notes, credits, alt, tags },\n\t\t)\n\t}\n}\n","import * as is from \"./lib/isValue\"\nimport { getOptionalLinkProperties } from \"./lib/getOptionalLinkProperties\"\nimport { validateAssetMetadata } from \"./lib/validateAssetMetadata\"\n\nimport type { Asset } from \"./types/api/asset/asset\"\nimport type {\n\tMigrationAssetConfig,\n\tMigrationImage,\n\tMigrationLinkToMedia,\n\tMigrationRTImageNode,\n} from \"./types/migration/Asset\"\nimport { PrismicMigrationAsset } from \"./types/migration/Asset\"\nimport type { MigrationContentRelationship } from \"./types/migration/ContentRelationship\"\nimport { PrismicMigrationDocument } from \"./types/migration/Document\"\nimport type {\n\tExistingPrismicDocument,\n\tPendingPrismicDocument,\n} from \"./types/migration/Document\"\nimport type { PrismicDocument } from \"./types/value/document\"\nimport type { FilledImageFieldImage } from \"./types/value/image\"\nimport { type FilledLinkToWebField, LinkType } from \"./types/value/link\"\nimport type { FilledLinkToMediaField } from \"./types/value/linkToMedia\"\nimport { RichTextNodeType } from \"./types/value/richText\"\n\n/**\n * Extracts one or more Prismic document types that match a given Prismic\n * document type. If no matches are found, no extraction is performed and the\n * union of all provided Prismic document types are returned.\n *\n * @typeParam TDocuments - Prismic document types from which to extract.\n * @typeParam TDocumentType - Type(s) to match `TDocuments` against.\n */\ntype ExtractDocumentType<\n\tTDocuments extends { type: string },\n\tTDocumentType extends TDocuments[\"type\"],\n> =\n\tExtract<TDocuments, { type: TDocumentType }> extends never\n\t\t? TDocuments\n\t\t: Extract<TDocuments, { type: TDocumentType }>\n\n/**\n * A helper that allows preparing your migration to Prismic.\n *\n * @typeParam TDocuments - Document types that are registered for the Prismic\n *   repository. Query methods will automatically be typed based on this type.\n */\nexport class Migration<TDocuments extends PrismicDocument = PrismicDocument> {\n\t/**\n\t * Assets registered in the migration.\n\t *\n\t * @internal\n\t */\n\t_assets: Map<MigrationAssetConfig[\"file\"], PrismicMigrationAsset> = new Map()\n\n\t/**\n\t * Documents registered in the migration.\n\t *\n\t * @internal\n\t */\n\t_documents: PrismicMigrationDocument<TDocuments>[] = []\n\n\t/**\n\t * Registers an asset to be created in the migration from an asset object.\n\t *\n\t * @remarks\n\t * This method does not create the asset in Prismic media library right away.\n\t * Instead, it registers it in your migration. The asset will be created when\n\t * the migration is executed through the `writeClient.migrate()` method.\n\t *\n\t * @param asset - An asset object from Prismic Asset API.\n\t *\n\t * @returns A migration asset field instance.\n\t *\n\t * @internal\n\t */\n\tcreateAsset(asset: Asset): PrismicMigrationAsset\n\n\t/**\n\t * Registers an asset to be created in the migration from an image or link to\n\t * media field.\n\t *\n\t * @remarks\n\t * This method does not create the asset in Prismic media library right away.\n\t * Instead, it registers it in your migration. The asset will be created when\n\t * the migration is executed through the `writeClient.migrate()` method.\n\t *\n\t * @param imageOrLinkToMediaField - An image or link to media field from\n\t *   Prismic Document API.\n\t *\n\t * @returns A migration asset field instance.\n\t *\n\t * @internal\n\t */\n\tcreateAsset(\n\t\timageOrLinkToMediaField: FilledImageFieldImage | FilledLinkToMediaField,\n\t): PrismicMigrationAsset\n\n\t/**\n\t * Registers an asset to be created in the migration from a file.\n\t *\n\t * @remarks\n\t * This method does not create the asset in Prismic media library right away.\n\t * Instead, it registers it in your migration. The asset will be created when\n\t * the migration is executed through the `writeClient.migrate()` method.\n\t *\n\t * @param file - The URL or content of the file to be created.\n\t * @param filename - The filename of the asset.\n\t * @param params - Additional asset data.\n\t *\n\t * @returns A migration asset field instance.\n\t */\n\tcreateAsset(\n\t\tfile: MigrationAssetConfig[\"file\"],\n\t\tfilename: MigrationAssetConfig[\"filename\"],\n\t\tparams?: {\n\t\t\tnotes?: string\n\t\t\tcredits?: string\n\t\t\talt?: string\n\t\t\ttags?: string[]\n\t\t},\n\t): PrismicMigrationAsset\n\n\t/**\n\t * Registers an asset to be created in the migration from a file, an asset\n\t * object, or an image or link to media field.\n\t *\n\t * @remarks\n\t * This method does not create the asset in Prismic media library right away.\n\t * Instead, it registers it in your migration. The asset will be created when\n\t * the migration is executed through the `writeClient.migrate()` method.\n\t *\n\t * @returns A migration asset field instance.\n\t */\n\tcreateAsset(\n\t\tfileOrAssetOrField:\n\t\t\t| MigrationAssetConfig[\"file\"]\n\t\t\t| Asset\n\t\t\t| FilledImageFieldImage\n\t\t\t| FilledLinkToMediaField,\n\t\tfilename?: MigrationAssetConfig[\"filename\"],\n\t\t{\n\t\t\tnotes,\n\t\t\tcredits,\n\t\t\talt,\n\t\t\ttags,\n\t\t}: {\n\t\t\tnotes?: string\n\t\t\tcredits?: string\n\t\t\talt?: string\n\t\t\ttags?: string[]\n\t\t} = {},\n\t): PrismicMigrationAsset {\n\t\tlet config: MigrationAssetConfig\n\t\tlet maybeInitialField: FilledImageFieldImage | undefined\n\t\tif (typeof fileOrAssetOrField === \"object\" && \"url\" in fileOrAssetOrField) {\n\t\t\tif (\n\t\t\t\t\"dimensions\" in fileOrAssetOrField ||\n\t\t\t\t\"link_type\" in fileOrAssetOrField\n\t\t\t) {\n\t\t\t\tconst url = fileOrAssetOrField.url.split(\"?\")[0]\n\t\t\t\tconst filename =\n\t\t\t\t\t\"name\" in fileOrAssetOrField\n\t\t\t\t\t\t? fileOrAssetOrField.name\n\t\t\t\t\t\t: url.split(\"/\").pop()!.split(\"_\").pop()!\n\t\t\t\tconst credits =\n\t\t\t\t\t\"copyright\" in fileOrAssetOrField && fileOrAssetOrField.copyright\n\t\t\t\t\t\t? fileOrAssetOrField.copyright\n\t\t\t\t\t\t: undefined\n\t\t\t\tconst alt =\n\t\t\t\t\t\"alt\" in fileOrAssetOrField && fileOrAssetOrField.alt\n\t\t\t\t\t\t? fileOrAssetOrField.alt\n\t\t\t\t\t\t: undefined\n\n\t\t\t\tif (\"dimensions\" in fileOrAssetOrField) {\n\t\t\t\t\tmaybeInitialField = fileOrAssetOrField\n\t\t\t\t}\n\n\t\t\t\tconfig = {\n\t\t\t\t\tid: fileOrAssetOrField.id,\n\t\t\t\t\tfile: url,\n\t\t\t\t\tfilename,\n\t\t\t\t\tnotes: undefined,\n\t\t\t\t\tcredits,\n\t\t\t\t\talt,\n\t\t\t\t\ttags: undefined,\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconfig = {\n\t\t\t\t\tid: fileOrAssetOrField.id,\n\t\t\t\t\tfile: fileOrAssetOrField.url,\n\t\t\t\t\tfilename: fileOrAssetOrField.filename,\n\t\t\t\t\tnotes: fileOrAssetOrField.notes,\n\t\t\t\t\tcredits: fileOrAssetOrField.credits,\n\t\t\t\t\talt: fileOrAssetOrField.alt,\n\t\t\t\t\ttags: fileOrAssetOrField.tags?.map(({ name }) => name),\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconfig = {\n\t\t\t\tid: fileOrAssetOrField,\n\t\t\t\tfile: fileOrAssetOrField,\n\t\t\t\tfilename: filename!,\n\t\t\t\tnotes,\n\t\t\t\tcredits,\n\t\t\t\talt,\n\t\t\t\ttags,\n\t\t\t}\n\t\t}\n\n\t\tvalidateAssetMetadata(config)\n\n\t\t// We create a detached instance of the asset each time to serialize it properly\n\t\tconst migrationAsset = new PrismicMigrationAsset(config, maybeInitialField)\n\n\t\tconst maybeAsset = this._assets.get(config.id)\n\t\tif (maybeAsset) {\n\t\t\t// Consolidate existing asset with new asset value if possible\n\t\t\tmaybeAsset.config.notes = maybeAsset.config.notes || config.notes\n\t\t\tmaybeAsset.config.credits = maybeAsset.config.credits || config.credits\n\t\t\tmaybeAsset.config.alt = maybeAsset.config.alt || config.alt\n\t\t\tmaybeAsset.config.tags = Array.from(\n\t\t\t\tnew Set([...(maybeAsset.config.tags || []), ...(config.tags || [])]),\n\t\t\t)\n\t\t} else {\n\t\t\tthis._assets.set(config.id, migrationAsset)\n\t\t}\n\n\t\treturn migrationAsset\n\t}\n\n\t/**\n\t * Registers a document to be created in the migration.\n\t *\n\t * @remarks\n\t * This method does not create the document in Prismic right away. Instead, it\n\t * registers it in your migration. The document will be created when the\n\t * migration is executed through the `writeClient.migrate()` method.\n\t *\n\t * @typeParam TType - Type of the Prismic document to create.\n\t *\n\t * @param document - The document to create.\n\t * @param title - The title of the document to create which will be displayed\n\t *   in the editor.\n\t * @param params - Document master language document ID.\n\t *\n\t * @returns A migration document instance.\n\t */\n\tcreateDocument<TType extends TDocuments[\"type\"]>(\n\t\tdocument: ExtractDocumentType<PendingPrismicDocument<TDocuments>, TType>,\n\t\ttitle: string,\n\t\tparams?: {\n\t\t\tmasterLanguageDocument?: MigrationContentRelationship\n\t\t},\n\t): PrismicMigrationDocument<ExtractDocumentType<TDocuments, TType>> {\n\t\tconst doc = new PrismicMigrationDocument<\n\t\t\tExtractDocumentType<TDocuments, TType>\n\t\t>(document, title, params)\n\n\t\tthis._documents.push(doc)\n\n\t\treturn doc\n\t}\n\n\t/**\n\t * Registers an existing document to be updated in the migration.\n\t *\n\t * @remarks\n\t * This method does not update the document in Prismic right away. Instead, it\n\t * registers it in your migration. The document will be updated when the\n\t * migration is executed through the `writeClient.migrate()` method.\n\t *\n\t * @typeParam TType - Type of Prismic documents to update.\n\t *\n\t * @param document - The document to update.\n\t * @param title - The title of the document to update which will be displayed\n\t *   in the editor.\n\t *\n\t * @returns A migration document instance.\n\t */\n\tupdateDocument<TType extends TDocuments[\"type\"]>(\n\t\tdocument: ExtractDocumentType<ExistingPrismicDocument<TDocuments>, TType>,\n\t\t// Title is optional for existing documents as we might not want to update it.\n\t\ttitle?: string,\n\t): PrismicMigrationDocument<ExtractDocumentType<TDocuments, TType>> {\n\t\tconst doc = new PrismicMigrationDocument<\n\t\t\tExtractDocumentType<TDocuments, TType>\n\t\t>(document, title)\n\n\t\tthis._documents.push(doc)\n\n\t\treturn doc\n\t}\n\n\t/**\n\t * Registers a document from another Prismic repository to be created in the\n\t * migration.\n\t *\n\t * @remarks\n\t * This method does not create the document in Prismic right away. Instead, it\n\t * registers it in your migration. The document will be created when the\n\t * migration is executed through the `writeClient.migrate()` method.\n\t *\n\t * @param document - The document from Prismic to create.\n\t * @param title - The title of the document to create which will be displayed\n\t *   in the editor.\n\t *\n\t * @returns A migration document instance.\n\t */\n\tcreateDocumentFromPrismic<TType extends TDocuments[\"type\"]>(\n\t\tdocument: ExtractDocumentType<ExistingPrismicDocument<TDocuments>, TType>,\n\t\ttitle: string,\n\t): PrismicMigrationDocument<ExtractDocumentType<TDocuments, TType>> {\n\t\tconst doc = new PrismicMigrationDocument(\n\t\t\tthis.#migratePrismicDocumentData({\n\t\t\t\ttype: document.type,\n\t\t\t\tlang: document.lang,\n\t\t\t\tuid: document.uid,\n\t\t\t\ttags: document.tags,\n\t\t\t\tdata: document.data,\n\t\t\t}) as PendingPrismicDocument<ExtractDocumentType<TDocuments, TType>>,\n\t\t\ttitle,\n\t\t\t{ originalPrismicDocument: document },\n\t\t)\n\n\t\tthis._documents.push(doc)\n\n\t\treturn doc\n\t}\n\n\t/**\n\t * Queries a document from the migration instance with a specific UID and\n\t * custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const contentRelationship = migration.createContentRelationship(() =>\n\t * \tmigration.getByUID(\"blog_post\", \"my-first-post\"),\n\t * )\n\t * ```\n\t *\n\t * @typeParam TType - Type of the Prismic document returned.\n\t *\n\t * @param type - The API ID of the document's custom type.\n\t * @param uid - The UID of the document.\n\t *\n\t * @returns The migration document instance with a UID matching the `uid`\n\t *   parameter, if a matching document is found.\n\t */\n\tgetByUID<TType extends TDocuments[\"type\"]>(\n\t\ttype: TType,\n\t\tuid: string,\n\t):\n\t\t| PrismicMigrationDocument<ExtractDocumentType<TDocuments, TType>>\n\t\t| undefined {\n\t\treturn this._documents.find(\n\t\t\t(\n\t\t\t\tdoc,\n\t\t\t): doc is PrismicMigrationDocument<\n\t\t\t\tExtractDocumentType<TDocuments, TType>\n\t\t\t> => doc.document.type === type && doc.document.uid === uid,\n\t\t)\n\t}\n\n\t/**\n\t * Queries a singleton document from the migration instance for a specific\n\t * custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const contentRelationship = migration.createContentRelationship(() =>\n\t * \tmigration.getSingle(\"settings\"),\n\t * )\n\t * ```\n\t *\n\t * @typeParam TType - Type of the Prismic document returned.\n\t *\n\t * @param type - The API ID of the singleton custom type.\n\t *\n\t * @returns The migration document instance for the custom type, if a matching\n\t *   document is found.\n\t */\n\tgetSingle<TType extends TDocuments[\"type\"]>(\n\t\ttype: TType,\n\t):\n\t\t| PrismicMigrationDocument<ExtractDocumentType<TDocuments, TType>>\n\t\t| undefined {\n\t\treturn this._documents.find(\n\t\t\t(\n\t\t\t\tdoc,\n\t\t\t): doc is PrismicMigrationDocument<\n\t\t\t\tExtractDocumentType<TDocuments, TType>\n\t\t\t> => doc.document.type === type,\n\t\t)\n\t}\n\n\t/**\n\t * Migrates a Prismic document data from another repository so that it can be\n\t * created through the current repository's Migration API.\n\t *\n\t * @param input - The Prismic document data to migrate.\n\t *\n\t * @returns The migrated Prismic document data.\n\t */\n\t#migratePrismicDocumentData(input: unknown): unknown {\n\t\tif (is.filledContentRelationship(input)) {\n\t\t\tconst optionalLinkProperties = getOptionalLinkProperties(input)\n\n\t\t\tif (input.isBroken) {\n\t\t\t\treturn {\n\t\t\t\t\t...optionalLinkProperties,\n\t\t\t\t\tlink_type: LinkType.Document,\n\t\t\t\t\t// ID needs to be 16 characters long to be considered valid by the API\n\t\t\t\t\tid: \"_____broken_____\",\n\t\t\t\t\tisBroken: true,\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\t...optionalLinkProperties,\n\t\t\t\tlink_type: LinkType.Document,\n\t\t\t\tid: () => this._getByOriginalID(input.id),\n\t\t\t}\n\t\t}\n\n\t\tif (is.filledLinkToMedia(input)) {\n\t\t\tconst optionalLinkProperties = getOptionalLinkProperties(input)\n\n\t\t\treturn {\n\t\t\t\t...optionalLinkProperties,\n\t\t\t\tlink_type: LinkType.Media,\n\t\t\t\tid: this.createAsset(input),\n\t\t\t}\n\t\t}\n\n\t\tif (is.rtImageNode(input)) {\n\t\t\t// Rich text image nodes\n\t\t\tconst rtImageNode: MigrationRTImageNode = {\n\t\t\t\ttype: RichTextNodeType.image,\n\t\t\t\tid: this.createAsset(input),\n\t\t\t}\n\n\t\t\tif (input.linkTo) {\n\t\t\t\trtImageNode.linkTo = this.#migratePrismicDocumentData(input.linkTo) as\n\t\t\t\t\t| MigrationContentRelationship\n\t\t\t\t\t| MigrationLinkToMedia\n\t\t\t\t\t| FilledLinkToWebField\n\t\t\t}\n\n\t\t\treturn rtImageNode\n\t\t}\n\n\t\tif (is.filledImage(input)) {\n\t\t\tconst image: MigrationImage = {\n\t\t\t\tid: this.createAsset(input),\n\t\t\t}\n\n\t\t\tconst {\n\t\t\t\tid: _id,\n\t\t\t\turl: _url,\n\t\t\t\tdimensions: _dimensions,\n\t\t\t\tedit: _edit,\n\t\t\t\talt: _alt,\n\t\t\t\tcopyright: _copyright,\n\t\t\t\t...thumbnails\n\t\t\t} = input\n\n\t\t\tfor (const name in thumbnails) {\n\t\t\t\tif (is.filledImage(thumbnails[name])) {\n\t\t\t\t\timage[name] = this.createAsset(thumbnails[name])\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn image\n\t\t}\n\n\t\tif (Array.isArray(input)) {\n\t\t\treturn input.map((element) => this.#migratePrismicDocumentData(element))\n\t\t}\n\n\t\tif (input && typeof input === \"object\") {\n\t\t\tconst res: Record<PropertyKey, unknown> = {}\n\n\t\t\tfor (const key in input) {\n\t\t\t\tres[key] = this.#migratePrismicDocumentData(\n\t\t\t\t\tinput[key as keyof typeof input],\n\t\t\t\t)\n\t\t\t}\n\n\t\t\treturn res\n\t\t}\n\n\t\treturn input\n\t}\n\n\t/**\n\t * Queries a document from the migration instance for a specific original ID.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const contentRelationship = migration.createContentRelationship(() =>\n\t * \tmigration._getByOriginalID(\"YhdrDxIAACgAcp_b\"),\n\t * )\n\t * ```\n\t *\n\t * @typeParam TType - Type of the Prismic document returned.\n\t *\n\t * @param id - The original ID of the Prismic document.\n\t *\n\t * @returns The migration document instance for the original ID, if a matching\n\t *   document is found.\n\t *\n\t * @internal\n\t */\n\t_getByOriginalID<TType extends TDocuments[\"type\"]>(\n\t\tid: string,\n\t):\n\t\t| PrismicMigrationDocument<ExtractDocumentType<TDocuments, TType>>\n\t\t| undefined {\n\t\treturn this._documents.find(\n\t\t\t(\n\t\t\t\tdoc,\n\t\t\t): doc is PrismicMigrationDocument<\n\t\t\t\tExtractDocumentType<TDocuments, TType>\n\t\t\t> => doc.originalPrismicDocument?.id === id,\n\t\t)\n\t}\n}\n","import type { PrismicDocument } from \"./types/value/document\"\n\nimport { Migration } from \"./Migration\"\n\n/**\n * Type definitions for the `createMigration()` function. May be augmented by\n * third-party libraries.\n */\nexport interface CreateMigration {\n\t<TDocuments extends PrismicDocument>(\n\t\t...args: ConstructorParameters<typeof Migration>\n\t): Migration<TDocuments>\n}\n\n/**\n * Creates a Prismic migration instance that can be used to prepare your\n * migration to Prismic.\n *\n * @example\n *\n * ```ts\n * createMigration()\n * ```\n *\n * @typeParam TDocuments - A union of Prismic document types for the repository.\n *\n * @returns A migration instance to prepare your migration.\n */\nexport const createMigration: CreateMigration = <\n\tTDocuments extends PrismicDocument,\n>() => new Migration<TDocuments>()\n","import { PrismicError } from \"./errors\"\n\nimport { isRepositoryName } from \"./isRepositoryName\"\n\n/**\n * Get a repository's Prismic GraphQL endpoint.\n *\n * @typeParam RepositoryName - Name of the Prismic repository.\n *\n * @param repositoryName - Name of the repository.\n *\n * @returns The repository's Prismic REST API V2 endpoint\n */\nexport const getGraphQLEndpoint = <RepositoryName extends string>(\n\trepositoryName: RepositoryName,\n): `https://${RepositoryName}.cdn.prismic.io/graphql` => {\n\tif (isRepositoryName(repositoryName)) {\n\t\treturn `https://${repositoryName}.cdn.prismic.io/graphql` as const\n\t} else {\n\t\tthrow new PrismicError(\n\t\t\t`An invalid Prismic repository name was given: ${repositoryName}`,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t)\n\t}\n}\n","import { PrismicError } from \"./errors\"\n\nimport { isRepositoryName } from \"./isRepositoryName\"\n\n/**\n * Returns the URL for a Prismic repository's Prismic Toolbar script. Use the\n * URL to inject the script into your app.\n *\n * @example\n *\n * ```typescriptreact\n * // In Next.js apps, use `next/script` in your `app/layout.tsx` file.\n *\n * import Script from \"next/script\";\n * import * as prismic from \"@prismicio/client\";\n *\n * export default function RootLayout({\n * \tchildren,\n * }: {\n * \tchildren: React.ReactNode,\n * }) {\n * \tconst toolbarSrc = prismic.getToolbarSrc(\"my-repo\");\n *\n * \treturn (\n * \t\t<html lang=\"en\">\n * \t\t\t<body>{children}</body>\n * \t\t\t<Script src={toolbarSrc} />\n * \t\t</html>\n * \t);\n * }\n * ```\n *\n * @param repositoryName - The name of the Prismic repository. For example,\n *   `\"my-repo\"` if the repository URL is `my-repo.prismic.io`.\n *\n * @returns The URL for the given Prismic repository's Prismic Toolbar script.\n */\nexport const getToolbarSrc = <TRepositoryName extends string>(\n\trepositoryName: TRepositoryName,\n): `https://static.cdn.prismic.io/prismic.js?new=true&repo=${TRepositoryName}` => {\n\tif (isRepositoryName(repositoryName)) {\n\t\treturn `https://static.cdn.prismic.io/prismic.js?new=true&repo=${repositoryName}` as const\n\t} else {\n\t\tthrow new PrismicError(\n\t\t\t`An invalid Prismic repository name was given: ${repositoryName}`,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t)\n\t}\n}\n","import type { DateField } from \"../types/value/date\"\nimport type { TimestampField } from \"../types/value/timestamp\"\n\n/**\n * The return type of `asDate()`.\n */\ntype AsDateReturnType<\n\tField extends DateField | TimestampField | null | undefined,\n> = Field extends DateField<\"filled\"> | TimestampField<\"filled\"> ? Date : null\n\n/**\n * Converts a date or timestamp field to a JavaScript Date object.\n *\n * @example\n *\n * ```ts\n * const date = asDate(document.data.release_date)\n * // => Date object or null\n * ```\n *\n * @param dateOrTimestampField - A date or timestamp field from Prismic.\n *\n * @returns A Date object, or `null` if the field is empty.\n *\n * @see Learn about date and timestamp fields: {@link https://prismic.io/docs/fields/date}\n */\nexport const asDate = <\n\tField extends DateField | TimestampField | null | undefined,\n>(\n\tdateOrTimestampField: Field,\n): AsDateReturnType<Field> => {\n\tif (!dateOrTimestampField) {\n\t\treturn null as AsDateReturnType<Field>\n\t}\n\n\t// If field is a timestamp field...\n\tif (dateOrTimestampField.length === 24) {\n\t\t/**\n\t\t * Converts basic ISO 8601 to ECMAScript simplified ISO 8601 format for\n\t\t * browser compatibility issues\n\t\t *\n\t\t * From: YYYY-MM-DDTHH:mm:ssZ To: YYYY-MM-DDTHH:mm:ss.sssZ\n\t\t *\n\t\t * @see MDN documentation: {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/Date#timestamp_string}\n\t\t * @see ECMAScript 2020 language specification: {@link https://262.ecma-international.org/11.0/#sec-date-time-string-format}\n\t\t * @see Related forum issue: {@link https://community.prismic.io/t/prismics-date-api/2520}\n\t\t * @see Regex101 expression: {@link https://regex101.com/r/jxyETT/1}\n\t\t */\n\t\treturn new Date(\n\t\t\tdateOrTimestampField.replace(/(\\+|-)(\\d{2})(\\d{2})$/, \".000$1$2:$3\"),\n\t\t) as AsDateReturnType<Field>\n\t} else {\n\t\t// ...else field is a date field\n\t\treturn new Date(dateOrTimestampField) as AsDateReturnType<Field>\n\t}\n}\n","/**\n * Determines if a URL is internal or external.\n *\n * @param url - The URL to check if internal or external.\n *\n * @returns `true` if `url` is internal, `false` otherwise.\n */\n// TODO: This does not detect all relative URLs as internal such as `about` or `./about`. This function assumes relative URLs start with a \"/\" or \"#\"`.\nexport const isInternalURL = (url: string): boolean => {\n\tconst isInternal = /^(\\/(?!\\/)|#)/.test(url)\n\tconst isSpecialLink = !isInternal && !/^https?:\\/\\//.test(url)\n\n\treturn isInternal && !isSpecialLink\n}\n","import { isInternalURL } from \"../lib/isInternalURL\"\n\nimport type { FilledContentRelationshipField } from \"../types/value/contentRelationship\"\nimport type { PrismicDocument } from \"../types/value/document\"\nimport type { FilledLinkToWebField, LinkField } from \"../types/value/link\"\nimport type { FilledLinkToMediaField } from \"../types/value/linkToMedia\"\n\nimport type { AsLinkReturnType, LinkResolverFunction } from \"./asLink\"\nimport { asLink } from \"./asLink\"\nimport { link as isFilledLink } from \"./isFilled\"\n\ntype AsLinkAttrsConfigRelArgs<\n\tLinkResolverFunctionReturnType = ReturnType<LinkResolverFunction>,\n\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t| LinkField\n\t\t| PrismicDocument\n\t\t| null\n\t\t| undefined,\n> = {\n\thref:\n\t\t| NonNullable<AsLinkReturnType<LinkResolverFunctionReturnType, Field>>\n\t\t| undefined\n\tisExternal: boolean\n\ttarget?: string\n}\n\nexport type AsLinkAttrsConfig<\n\tLinkResolverFunctionReturnType = ReturnType<LinkResolverFunction>,\n\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t| LinkField\n\t\t| PrismicDocument\n\t\t| null\n\t\t| undefined,\n> = {\n\tlinkResolver?: LinkResolverFunction<LinkResolverFunctionReturnType>\n\trel?: (\n\t\targs: AsLinkAttrsConfigRelArgs<LinkResolverFunctionReturnType, Field>,\n\t) => string | undefined | void\n}\n\n/**\n * The return type of `asLinkAttrs()`.\n */\ntype AsLinkAttrsReturnType<\n\tLinkResolverFunctionReturnType = ReturnType<LinkResolverFunction>,\n\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t| LinkField\n\t\t| PrismicDocument\n\t\t| null\n\t\t| undefined,\n> = Field extends\n\t| FilledLinkToWebField\n\t| FilledLinkToMediaField\n\t| FilledContentRelationshipField\n\t| PrismicDocument\n\t? {\n\t\t\thref:\n\t\t\t\t| NonNullable<AsLinkReturnType<LinkResolverFunctionReturnType, Field>>\n\t\t\t\t| undefined\n\t\t\ttarget?: string\n\t\t\trel?: string\n\t\t}\n\t: {\n\t\t\thref?: undefined\n\t\t\ttarget?: undefined\n\t\t\trel?: undefined\n\t\t}\n\n/**\n * Resolves any type of link field or Prismic page to a set of link attributes.\n * The attributes are designed to be passed to link HTML elements, like `<a>`.\n *\n * If a resolved URL is external (i.e. starts with a protocol like `https://`),\n * `rel` is returned as `\"noreferrer\"`.\n *\n * @typeParam LinkResolverFunctionReturnType - link resolver function return\n *   type\n * @typeParam Field - Link field or Prismic page to resolve to link attributes\n *\n * @param linkFieldOrDocument - Any kind of link field or a page to resolve\n * @param config - Configuration that determines the output of `asLinkAttrs()`\n *\n * @returns Resolved set of link attributes or, if the provided link field or\n *   page is empty, and empty object\n *\n * @see Learn about route resolvers and link resolvers: {@link https://prismic.io/docs/routes}\n */\nexport const asLinkAttrs = <\n\tLinkResolverFunctionReturnType = ReturnType<LinkResolverFunction>,\n\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t| LinkField\n\t\t| PrismicDocument\n\t\t| null\n\t\t| undefined,\n>(\n\tlinkFieldOrDocument: Field,\n\tconfig: AsLinkAttrsConfig<LinkResolverFunctionReturnType> = {},\n): AsLinkAttrsReturnType<LinkResolverFunctionReturnType> => {\n\tif (\n\t\tlinkFieldOrDocument &&\n\t\t(\"link_type\" in linkFieldOrDocument\n\t\t\t? isFilledLink(linkFieldOrDocument)\n\t\t\t: linkFieldOrDocument)\n\t) {\n\t\tconst target =\n\t\t\t\"target\" in linkFieldOrDocument ? linkFieldOrDocument.target : undefined\n\n\t\tconst rawHref = asLink(linkFieldOrDocument, config.linkResolver)\n\t\tconst href =\n\t\t\trawHref == null ? undefined : (rawHref as NonNullable<typeof rawHref>)\n\n\t\tconst isExternal = typeof href === \"string\" ? !isInternalURL(href) : false\n\n\t\tconst rel = config.rel\n\t\t\t? config.rel({ href, isExternal, target })\n\t\t\t: isExternal\n\t\t\t\t? \"noreferrer\"\n\t\t\t\t: undefined\n\n\t\treturn {\n\t\t\thref,\n\t\t\ttarget,\n\t\t\trel: rel == null ? undefined : rel,\n\t\t}\n\t}\n\n\treturn {}\n}\n","import type { RTTextNode, RichTextField } from \"../types/value/richText\"\n\n/**\n * Converts a rich text field to a plain text string.\n *\n * @param richTextField - A rich text field from Prismic.\n * @param separator - Separator used to join each element. Defaults to a space.\n *\n * @returns Plain text equivalent of the rich text field.\n *\n * @see Learn how to work with rich text fields: {@link https://prismic.io/docs/fields/rich-text}\n */\nexport const asText = (\n\trichTextField: RichTextField,\n\tseparator = \" \",\n): string => {\n\tlet result = \"\"\n\n\tfor (let i = 0; i < richTextField.length; i++) {\n\t\tif (\"text\" in richTextField[i]) {\n\t\t\tresult +=\n\t\t\t\t(result ? separator : \"\") + (richTextField[i] as RTTextNode).text\n\t\t}\n\t}\n\n\treturn result\n}\n","import type { RichTextField } from \"../types/value/richText\"\n\nimport { asText as baseAsText } from \"../richtext/asText\"\n\n/**\n * Configuration that determines the output of `asText()`.\n */\ntype AsTextConfig = {\n\t/**\n\t * Separator used to join each element.\n\t *\n\t * @defaultValue ` ` (a space)\n\t */\n\tseparator?: string\n}\n\n// TODO: Remove when we remove support for deprecated tuple-style configuration.\n/**\n * @deprecated Use object-style configuration instead.\n */\ntype AsTextDeprecatedTupleConfig = [separator?: string]\n\n/**\n * The return type of `asText()`.\n */\ntype AsTextReturnType<Field extends RichTextField | null | undefined> =\n\tField extends RichTextField ? string : null\n\nexport const asText: {\n\t/**\n\t * Converts a rich text field to a plain text string.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const text = asText(document.data.content)\n\t * // => \"Hello world\"\n\t * ```\n\t *\n\t * @param richTextField - A rich text field from Prismic.\n\t * @param config - Configuration that determines the output of `asText()`.\n\t *\n\t * @returns Plain text equivalent of the rich text field, or `null` if the\n\t *   field is empty.\n\t *\n\t * @see Learn how to work with rich text fields: {@link https://prismic.io/docs/fields/rich-text}\n\t */\n\t<Field extends RichTextField | null | undefined>(\n\t\trichTextField: Field,\n\t\tconfig?: AsTextConfig,\n\t): AsTextReturnType<Field>\n\n\t/**\n\t * Converts a rich text field to a plain text string.\n\t *\n\t * @deprecated Use object-style configuration instead.\n\t *\n\t * @param richTextField - A rich text field from Prismic.\n\t * @param separator - Separator used to join each element. Defaults to a\n\t *   space.\n\t *\n\t * @returns Plain text equivalent of the rich text field, or `null` if the\n\t *   field is empty.\n\t *\n\t * @see Learn how to work with rich text fields: {@link https://prismic.io/docs/fields/rich-text}\n\t */\n\t<Field extends RichTextField | null | undefined>(\n\t\trichTextField: Field,\n\t\t...config: AsTextDeprecatedTupleConfig\n\t): AsTextReturnType<Field>\n} = <Field extends RichTextField | null | undefined>(\n\trichTextField: Field,\n\t// TODO: Rename to `config` when we remove support for deprecated tuple-style configuration.\n\t...configObjectOrTuple: [config?: AsTextConfig] | AsTextDeprecatedTupleConfig\n): AsTextReturnType<Field> => {\n\tif (richTextField) {\n\t\t// TODO: Remove when we remove support for deprecated tuple-style configuration.\n\t\tconst [configObjectOrSeparator] = configObjectOrTuple\n\t\tlet config: AsTextConfig\n\t\tif (typeof configObjectOrSeparator === \"string\") {\n\t\t\tconfig = {\n\t\t\t\tseparator: configObjectOrSeparator,\n\t\t\t}\n\t\t} else {\n\t\t\tconfig = { ...configObjectOrSeparator }\n\t\t}\n\n\t\treturn baseAsText(\n\t\t\trichTextField,\n\t\t\tconfig.separator,\n\t\t) as AsTextReturnType<Field>\n\t} else {\n\t\treturn null as AsTextReturnType<Field>\n\t}\n}\n","/*\n ** Core logic from https://github.com/component/escape-html\n ** Many thanks to @component\n */\n\nconst matchHtmlRegExp = /[\"'&<>]/\n\nexport const escapeHTML = (string?: string | null): string => {\n\tconst str = \"\" + string\n\tconst match = matchHtmlRegExp.exec(str)\n\n\tif (!match) {\n\t\treturn str\n\t}\n\n\tlet escape\n\tlet html = \"\"\n\tlet index = 0\n\tlet lastIndex = 0\n\n\tfor (index = match.index; index < str.length; index++) {\n\t\tswitch (str.charCodeAt(index)) {\n\t\t\tcase 34: // \"\n\t\t\t\tescape = \"&quot;\"\n\t\t\t\tbreak\n\t\t\tcase 38: // &\n\t\t\t\tescape = \"&amp;\"\n\t\t\t\tbreak\n\t\t\tcase 39: // '\n\t\t\t\tescape = \"&#39;\"\n\t\t\t\tbreak\n\t\t\tcase 60: // <\n\t\t\t\tescape = \"&lt;\"\n\t\t\t\tbreak\n\t\t\tcase 62: // >\n\t\t\t\tescape = \"&gt;\"\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tcontinue\n\t\t}\n\n\t\tif (lastIndex !== index) {\n\t\t\thtml += str.substring(lastIndex, index)\n\t\t}\n\n\t\tlastIndex = index + 1\n\t\thtml += escape\n\t}\n\n\treturn lastIndex !== index ? html + str.substring(lastIndex, index) : html\n}\n","import type { RichTextMapSerializer } from \"../richtext/types\"\nimport { LinkType } from \"../types/value/link\"\nimport type { RTAnyNode } from \"../types/value/richText\"\n\nimport type {\n\tHTMLRichTextMapSerializer,\n\tHTMLStrictRichTextMapSerializer,\n} from \"../helpers/asHTML\"\nimport type { LinkResolverFunction } from \"../helpers/asLink\"\nimport { asLink } from \"../helpers/asLink\"\n\nimport { escapeHTML } from \"./escapeHTML\"\n\ntype Attributes = Record<string, string | boolean | null | undefined>\nconst formatAttributes = (node: RTAnyNode, attributes: Attributes): string => {\n\tconst _attributes = { ...attributes }\n\n\t// Respect `ltr` and `rtl` direction\n\tif (\"direction\" in node && node.direction === \"rtl\") {\n\t\t_attributes.dir = node.direction\n\t}\n\n\t// Add label to attributes\n\tif (\"data\" in node && \"label\" in node.data && node.data.label) {\n\t\t_attributes.class = _attributes.class\n\t\t\t? `${_attributes.class} ${node.data.label}`\n\t\t\t: node.data.label\n\t}\n\n\tconst result = []\n\n\tfor (const key in _attributes) {\n\t\tconst value = _attributes[key]\n\n\t\tif (value) {\n\t\t\tif (typeof value === \"boolean\") {\n\t\t\t\tresult.push(key)\n\t\t\t} else {\n\t\t\t\tresult.push(`${key}=\"${escapeHTML(value)}\"`)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Add a space at the beginning if there's any result\n\tif (result.length) {\n\t\tresult.unshift(\"\")\n\t}\n\n\treturn result.join(\" \")\n}\n\nconst getGeneralAttributes = (\n\tserializerOrShorthand?: HTMLRichTextMapSerializer[keyof HTMLRichTextMapSerializer],\n): Attributes => {\n\treturn serializerOrShorthand && typeof serializerOrShorthand !== \"function\"\n\t\t? serializerOrShorthand\n\t\t: {}\n}\n\nexport const serializeStandardTag = <\n\tBlockType extends keyof RichTextMapSerializer<string>,\n>(\n\ttag: string,\n\tserializerOrShorthand?: HTMLRichTextMapSerializer[BlockType],\n): NonNullable<HTMLStrictRichTextMapSerializer[BlockType]> => {\n\tconst generalAttributes = getGeneralAttributes(serializerOrShorthand)\n\n\treturn (({ node, children }) => {\n\t\treturn `<${tag}${formatAttributes(\n\t\t\tnode,\n\t\t\tgeneralAttributes,\n\t\t)}>${children}</${tag}>`\n\t}) as NonNullable<HTMLStrictRichTextMapSerializer[BlockType]>\n}\n\nexport const serializePreFormatted = (\n\tserializerOrShorthand?: HTMLRichTextMapSerializer[\"preformatted\"],\n): NonNullable<HTMLStrictRichTextMapSerializer[\"preformatted\"]> => {\n\tconst generalAttributes = getGeneralAttributes(serializerOrShorthand)\n\n\treturn ({ node }) => {\n\t\treturn `<pre${formatAttributes(node, generalAttributes)}>${escapeHTML(\n\t\t\tnode.text,\n\t\t)}</pre>`\n\t}\n}\n\nexport const serializeImage = (\n\tlinkResolver:\n\t\t| LinkResolverFunction<string | null | undefined>\n\t\t| undefined\n\t\t| null,\n\tserializerOrShorthand?: HTMLRichTextMapSerializer[\"image\"],\n): NonNullable<HTMLStrictRichTextMapSerializer[\"image\"]> => {\n\tconst generalAttributes = getGeneralAttributes(serializerOrShorthand)\n\n\treturn ({ node }) => {\n\t\tconst attributes = {\n\t\t\t...generalAttributes,\n\t\t\tsrc: node.url,\n\t\t\talt: node.alt,\n\t\t\tcopyright: node.copyright,\n\t\t}\n\n\t\tlet imageTag = `<img${formatAttributes(node, attributes)} />`\n\n\t\t// If the image has a link, we wrap it with an anchor tag\n\t\tif (node.linkTo) {\n\t\t\timageTag = serializeHyperlink(linkResolver)({\n\t\t\t\ttype: \"hyperlink\",\n\t\t\t\tnode: {\n\t\t\t\t\ttype: \"hyperlink\",\n\t\t\t\t\tdata: node.linkTo,\n\t\t\t\t\tstart: 0,\n\t\t\t\t\tend: 0,\n\t\t\t\t},\n\t\t\t\ttext: \"\",\n\t\t\t\tchildren: imageTag,\n\t\t\t\tkey: \"\",\n\t\t\t})!\n\t\t}\n\n\t\treturn `<p class=\"block-img\">${imageTag}</p>`\n\t}\n}\n\nexport const serializeEmbed = (\n\tserializerOrShorthand?: HTMLRichTextMapSerializer[\"embed\"],\n): NonNullable<HTMLStrictRichTextMapSerializer[\"embed\"]> => {\n\tconst generalAttributes = getGeneralAttributes(serializerOrShorthand)\n\n\treturn ({ node }) => {\n\t\tconst attributes = {\n\t\t\t...generalAttributes,\n\t\t\t[\"data-oembed\"]: node.oembed.embed_url,\n\t\t\t[\"data-oembed-type\"]: node.oembed.type,\n\t\t\t[\"data-oembed-provider\"]: node.oembed.provider_name,\n\t\t}\n\n\t\treturn `<div${formatAttributes(node, attributes)}>${node.oembed.html}</div>`\n\t}\n}\n\nexport const serializeHyperlink = (\n\tlinkResolver:\n\t\t| LinkResolverFunction<string | null | undefined>\n\t\t| undefined\n\t\t| null,\n\tserializerOrShorthand?: HTMLRichTextMapSerializer[\"hyperlink\"],\n): NonNullable<HTMLStrictRichTextMapSerializer[\"hyperlink\"]> => {\n\tconst generalAttributes = getGeneralAttributes(serializerOrShorthand)\n\n\treturn ({ node, children }): string => {\n\t\tconst attributes = {\n\t\t\t...generalAttributes,\n\t\t}\n\n\t\tif (node.data.link_type === LinkType.Web) {\n\t\t\tattributes.href = node.data.url\n\t\t\tattributes.target = node.data.target\n\t\t\tattributes.rel = \"noopener noreferrer\"\n\t\t} else if (node.data.link_type === LinkType.Document) {\n\t\t\tattributes.href = asLink(node.data, { linkResolver })\n\t\t} else if (node.data.link_type === LinkType.Media) {\n\t\t\tattributes.href = node.data.url\n\t\t}\n\n\t\treturn `<a${formatAttributes(node, attributes)}>${children}</a>`\n\t}\n}\n\nexport const serializeSpan = (): NonNullable<\n\tHTMLStrictRichTextMapSerializer[\"span\"]\n> => {\n\treturn ({ text }): string => {\n\t\treturn text ? escapeHTML(text).replace(/\\n/g, \"<br />\") : \"\"\n\t}\n}\n","import type {\n\tRTAnyNode,\n\tRTBlockNode,\n\tRTInlineNode,\n\tRTListItemNode,\n\tRTNode,\n\tRTOListItemNode,\n\tRTTextNode,\n} from \"../types/value/richText\"\nimport { RichTextNodeType } from \"../types/value/richText\"\nimport type { Tree, TreeNode } from \"./types\"\n\nconst uuid = (): string => {\n\treturn (++uuid.i).toString()\n}\nuuid.i = 0\n\n/**\n * Parses a rich text or title field into a tree\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages. Most users aren't expected to this function directly.\n *\n * @param nodes - A rich text or title field from Prismic\n *\n * @returns Tree from given rich text or title field\n */\nexport const asTree = (nodes: RTNode[]): Tree => {\n\tconst preparedNodes = prepareNodes(nodes)\n\n\tconst children: TreeNode[] = []\n\tfor (let i = 0; i < preparedNodes.length; i++) {\n\t\tchildren.push(nodeToTreeNode(preparedNodes[i]))\n\t}\n\n\treturn {\n\t\tkey: uuid(),\n\t\tchildren,\n\t}\n}\n\nconst createTreeNode = (\n\tnode: RTAnyNode,\n\tchildren: TreeNode[] = [],\n): TreeNode => {\n\treturn {\n\t\tkey: uuid(),\n\t\ttype: node.type,\n\t\ttext: \"text\" in node ? node.text : undefined,\n\t\tnode,\n\t\tchildren,\n\t}\n}\n\nconst createTextTreeNode = (text: string): TreeNode => {\n\treturn createTreeNode({\n\t\ttype: RichTextNodeType.span,\n\t\ttext,\n\t\tspans: [],\n\t})\n}\n\nconst prepareNodes = (nodes: RTNode[]): RTBlockNode[] => {\n\tconst mutNodes: RTBlockNode[] = nodes.slice(0)\n\n\tfor (let i = 0; i < mutNodes.length; i++) {\n\t\tconst node = mutNodes[i]\n\n\t\tif (\n\t\t\tnode.type === RichTextNodeType.listItem ||\n\t\t\tnode.type === RichTextNodeType.oListItem\n\t\t) {\n\t\t\tconst items: (RTListItemNode | RTOListItemNode)[] = [\n\t\t\t\tnode as RTListItemNode | RTOListItemNode,\n\t\t\t]\n\n\t\t\twhile (mutNodes[i + 1] && mutNodes[i + 1].type === node.type) {\n\t\t\t\titems.push(mutNodes[i + 1] as RTListItemNode | RTOListItemNode)\n\t\t\t\tmutNodes.splice(i, 1)\n\t\t\t}\n\n\t\t\tif (node.type === RichTextNodeType.listItem) {\n\t\t\t\tmutNodes[i] = {\n\t\t\t\t\ttype: RichTextNodeType.list,\n\t\t\t\t\titems: items as RTListItemNode[],\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmutNodes[i] = {\n\t\t\t\t\ttype: RichTextNodeType.oList,\n\t\t\t\t\titems: items as RTOListItemNode[],\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn mutNodes\n}\n\nconst nodeToTreeNode = (node: RTBlockNode): TreeNode => {\n\tif (\"text\" in node) {\n\t\treturn createTreeNode(\n\t\t\tnode,\n\t\t\ttextNodeSpansToTreeNodeChildren(node.spans, node),\n\t\t)\n\t}\n\n\tif (\"items\" in node) {\n\t\tconst children: TreeNode[] = []\n\t\tfor (let i = 0; i < node.items.length; i++) {\n\t\t\tchildren.push(nodeToTreeNode(node.items[i]))\n\t\t}\n\n\t\treturn createTreeNode(node, children)\n\t}\n\n\treturn createTreeNode(node)\n}\n\nconst textNodeSpansToTreeNodeChildren = (\n\tspans: RTInlineNode[],\n\tnode: RTTextNode,\n\tparentSpan?: RTInlineNode,\n): TreeNode[] => {\n\tif (!spans.length) {\n\t\treturn [createTextTreeNode(node.text)]\n\t}\n\n\tconst mutSpans: RTInlineNode[] = spans.slice(0)\n\n\t// Sort spans using the following criteria:\n\t//\n\t//   1. By start index (ascending)\n\t//   2. If start indices are equal, by end index (descending)\n\t//\n\t// If start and end indices of more than one span are equal, use what\n\t// the API gives without modifications.\n\t//\n\t// Sorting using this algorithm ensures proper detection of child\n\t// spans.\n\tmutSpans.sort((a, b) => a.start - b.start || b.end - a.end)\n\n\tconst children: TreeNode[] = []\n\n\tfor (let i = 0; i < mutSpans.length; i++) {\n\t\tconst span = mutSpans[i]\n\t\tconst parentSpanStart = (parentSpan && parentSpan.start) || 0\n\t\tconst spanStart = span.start - parentSpanStart\n\t\tconst spanEnd = span.end - parentSpanStart\n\t\tconst text = node.text.slice(spanStart, spanEnd)\n\n\t\tconst childSpans: RTInlineNode[] = []\n\t\tfor (let j = i; j < mutSpans.length; j++) {\n\t\t\tconst siblingSpan = mutSpans[j]\n\n\t\t\tif (siblingSpan !== span) {\n\t\t\t\tif (siblingSpan.start >= span.start && siblingSpan.end <= span.end) {\n\t\t\t\t\tchildSpans.push(siblingSpan)\n\t\t\t\t\tmutSpans.splice(j, 1)\n\t\t\t\t\tj--\n\t\t\t\t} else if (\n\t\t\t\t\tsiblingSpan.start < span.end &&\n\t\t\t\t\tsiblingSpan.end > span.start\n\t\t\t\t) {\n\t\t\t\t\tchildSpans.push({\n\t\t\t\t\t\t...siblingSpan,\n\t\t\t\t\t\tend: span.end,\n\t\t\t\t\t})\n\t\t\t\t\tmutSpans[j] = {\n\t\t\t\t\t\t...siblingSpan,\n\t\t\t\t\t\tstart: span.end,\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (i === 0 && spanStart > 0) {\n\t\t\tchildren.push(createTextTreeNode(node.text.slice(0, spanStart)))\n\t\t}\n\n\t\tconst spanWithText = { ...span, text }\n\t\tchildren.push(\n\t\t\tcreateTreeNode(\n\t\t\t\tspanWithText,\n\t\t\t\ttextNodeSpansToTreeNodeChildren(\n\t\t\t\t\tchildSpans,\n\t\t\t\t\t{\n\t\t\t\t\t\t...node,\n\t\t\t\t\t\ttext,\n\t\t\t\t\t},\n\t\t\t\t\tspan,\n\t\t\t\t),\n\t\t\t),\n\t\t)\n\n\t\tif (spanEnd < node.text.length) {\n\t\t\tchildren.push(\n\t\t\t\tcreateTextTreeNode(\n\t\t\t\t\tnode.text.slice(\n\t\t\t\t\t\tspanEnd,\n\t\t\t\t\t\tmutSpans[i + 1]\n\t\t\t\t\t\t\t? mutSpans[i + 1].start - parentSpanStart\n\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t)\n\t\t}\n\t}\n\n\treturn children\n}\n","import type { RichTextField } from \"../types/value/richText\"\nimport type { RichTextFunctionSerializer, TreeNode } from \"./types\"\n\nimport { asTree } from \"./asTree\"\n\n/**\n * Serializes a rich text field with a given serializer.\n *\n * @remarks\n * This is a low-level helper mainly intended to be used by higher-level\n * packages. Most users aren't expected to use this function directly.\n *\n * @typeParam SerializerReturnType - Return type of the serializer.\n *\n * @param richTextField - A rich text field from Prismic.\n * @param serializer - A function serializer to apply.\n *\n * @returns An array of serialized nodes.\n *\n * @see Learn how to work with rich text fields: {@link https://prismic.io/docs/fields/rich-text}\n */\nexport const serialize = <SerializerReturnType>(\n\trichTextField: RichTextField,\n\tserializer: RichTextFunctionSerializer<SerializerReturnType>,\n): SerializerReturnType[] => {\n\treturn serializeTreeNodes<SerializerReturnType>(\n\t\tasTree(richTextField).children,\n\t\tserializer,\n\t)\n}\n\nconst serializeTreeNodes = <T>(\n\tnodes: TreeNode[],\n\tserializer: RichTextFunctionSerializer<T>,\n): T[] => {\n\tconst serializedTreeNodes: T[] = []\n\n\tfor (let i = 0; i < nodes.length; i++) {\n\t\tconst treeNode = nodes[i]\n\t\tconst serializedTreeNode = serializer(\n\t\t\ttreeNode.type,\n\t\t\ttreeNode.node,\n\t\t\ttreeNode.text,\n\t\t\tserializeTreeNodes(treeNode.children, serializer),\n\t\t\ttreeNode.key,\n\t\t)\n\n\t\tif (serializedTreeNode != null) {\n\t\t\tserializedTreeNodes.push(serializedTreeNode)\n\t\t}\n\t}\n\n\treturn serializedTreeNodes\n}\n","import type {\n\tRTAnyNode,\n\tRTEmNode,\n\tRTEmbedNode,\n\tRTHeading1Node,\n\tRTHeading2Node,\n\tRTHeading3Node,\n\tRTHeading4Node,\n\tRTHeading5Node,\n\tRTHeading6Node,\n\tRTImageNode,\n\tRTLabelNode,\n\tRTLinkNode,\n\tRTListItemNode,\n\tRTListNode,\n\tRTOListItemNode,\n\tRTOListNode,\n\tRTParagraphNode,\n\tRTPreformattedNode,\n\tRTSpanNode,\n\tRTStrongNode,\n\tRichTextNodeTypes,\n} from \"../types/value/richText\"\nimport { RichTextNodeType } from \"../types/value/richText\"\n\n// Serializers\n\n/**\n * Serializes a node from a rich text or title field with a function\n *\n * @typeParam ReturnType - Return type of the function serializer.\n *\n * @see Learn how to work with rich text fields: {@link https://prismic.io/docs/fields/rich-text}\n */\nexport type RichTextFunctionSerializer<ReturnType> = (\n\ttype: RichTextNodeTypes,\n\tnode: RTAnyNode,\n\ttext: string | undefined,\n\tchildren: ReturnType[],\n\tkey: string,\n) => ReturnType | null | undefined\n\n/**\n * Map serializer's tag function serializer, can be helpful for typing those\n * handlers\n *\n * @typeParam ReturnType - Return type of the tag serializer\n */\nexport type RichTextMapSerializerFunction<\n\tReturnType,\n\tNode extends RTAnyNode = RTAnyNode,\n\tTextType = string | undefined,\n> = (payload: {\n\ttype: Node[\"type\"]\n\tnode: Node\n\ttext: TextType\n\tchildren: ReturnType[]\n\tkey: string\n}) => ReturnType | null | undefined\n\n/**\n * Serializes a node from a rich text field with a map.\n *\n * @remarks\n * This type of serializer needs to be processed through\n * {@link wrapMapSerializer} before being used with {@link serialize}.\n *\n * @typeParam ReturnType - Return type of the map serializer.\n *\n * @see Learn how to work with rich text fields: {@link https://prismic.io/docs/fields/rich-text}\n */\nexport type RichTextMapSerializer<ReturnType> = {\n\theading1?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading1Node,\n\t\tundefined\n\t>\n\theading2?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading2Node,\n\t\tundefined\n\t>\n\theading3?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading3Node,\n\t\tundefined\n\t>\n\theading4?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading4Node,\n\t\tundefined\n\t>\n\theading5?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading5Node,\n\t\tundefined\n\t>\n\theading6?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTHeading6Node,\n\t\tundefined\n\t>\n\tparagraph?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTParagraphNode,\n\t\tundefined\n\t>\n\tpreformatted?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTPreformattedNode,\n\t\tundefined\n\t>\n\tstrong?: RichTextMapSerializerFunction<ReturnType, RTStrongNode, string>\n\tem?: RichTextMapSerializerFunction<ReturnType, RTEmNode, string>\n\tlistItem?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTListItemNode,\n\t\tundefined\n\t>\n\toListItem?: RichTextMapSerializerFunction<\n\t\tReturnType,\n\t\tRTOListItemNode,\n\t\tundefined\n\t>\n\tlist?: RichTextMapSerializerFunction<ReturnType, RTListNode, undefined>\n\toList?: RichTextMapSerializerFunction<ReturnType, RTOListNode, undefined>\n\timage?: RichTextMapSerializerFunction<ReturnType, RTImageNode, undefined>\n\tembed?: RichTextMapSerializerFunction<ReturnType, RTEmbedNode, undefined>\n\thyperlink?: RichTextMapSerializerFunction<ReturnType, RTLinkNode, string>\n\tlabel?: RichTextMapSerializerFunction<ReturnType, RTLabelNode, string>\n\tspan?: RichTextMapSerializerFunction<ReturnType, RTSpanNode, string>\n}\n\n// Tree\nexport interface Tree {\n\tkey: string\n\tchildren: TreeNode[]\n}\n\nexport interface TreeNode {\n\tkey: string\n\ttype: RichTextNodeTypes\n\ttext?: string\n\tnode: RTAnyNode\n\tchildren: TreeNode[]\n}\n\n// Helpers\nexport const RichTextReversedNodeType = {\n\t[RichTextNodeType.listItem]: \"listItem\",\n\t[RichTextNodeType.oListItem]: \"oListItem\",\n\t[RichTextNodeType.list]: \"list\",\n\t[RichTextNodeType.oList]: \"oList\",\n} as const\n","import type { RichTextFunctionSerializer, RichTextMapSerializer } from \"./types\"\nimport { RichTextReversedNodeType } from \"./types\"\n\n/**\n * Wraps a map serializer into a regular function serializer\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages Most users aren't expected to this function directly\n *\n * @typeParam SerializerReturnType - Return type of the map serializer\n *\n * @param mapSerializer - Map serializer to wrap\n *\n * @returns A regular function serializer\n */\nexport const wrapMapSerializer = <SerializerReturnType>(\n\tmapSerializer: RichTextMapSerializer<SerializerReturnType>,\n): RichTextFunctionSerializer<SerializerReturnType> => {\n\treturn (type, node, text, children, key) => {\n\t\tconst tagSerializer: RichTextMapSerializer<SerializerReturnType>[keyof RichTextMapSerializer<SerializerReturnType>] =\n\t\t\tmapSerializer[\n\t\t\t\t(RichTextReversedNodeType[\n\t\t\t\t\ttype as keyof typeof RichTextReversedNodeType\n\t\t\t\t] || type) as keyof RichTextMapSerializer<SerializerReturnType>\n\t\t\t]\n\n\t\tif (tagSerializer) {\n\t\t\treturn tagSerializer({\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\ttype,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\tnode,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\ttext,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\tchildren,\n\t\t\t\t// @ts-expect-error cannot type check here\n\t\t\t\tkey,\n\t\t\t})\n\t\t}\n\t}\n}\n","import type { RichTextFunctionSerializer } from \"./types\"\n\n/**\n * Takes an array of serializers and returns a serializer applying provided\n * serializers sequentially until a result is returned\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages Most users aren't expected to this function directly\n *\n * @typeParam SerializerReturnType - Return type of serializers\n *\n * @param serializers - Serializers to compose\n *\n * @returns Composed serializer\n */\nexport const composeSerializers = <SerializerReturnType>(\n\t...serializers: (\n\t\t| RichTextFunctionSerializer<SerializerReturnType>\n\t\t| undefined\n\t)[]\n): RichTextFunctionSerializer<SerializerReturnType> => {\n\treturn (...args) => {\n\t\tfor (let i = 0; i < serializers.length; i++) {\n\t\t\tconst serializer = serializers[i]\n\n\t\t\tif (serializer) {\n\t\t\t\tconst res = serializer(...args)\n\n\t\t\t\tif (res != null) {\n\t\t\t\t\treturn res\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import {\n\tserializeEmbed,\n\tserializeHyperlink,\n\tserializeImage,\n\tserializePreFormatted,\n\tserializeSpan,\n\tserializeStandardTag,\n} from \"../lib/serializerHelpers\"\n\nimport type { RichTextField } from \"../types/value/richText\"\n\nimport type {\n\tRichTextFunctionSerializer,\n\tRichTextMapSerializer,\n\tRichTextMapSerializerFunction,\n} from \"../richtext\"\nimport { composeSerializers, serialize, wrapMapSerializer } from \"../richtext\"\n\nimport type { LinkResolverFunction } from \"./asLink\"\n\n/**\n * Serializes a node from a rich text field with a function to HTML.\n *\n * Unlike a typical `@prismicio/client/richtext` function serializer, this\n * serializer converts the `children` argument to a single string rather than an\n * array of strings.\n *\n * @see Learn how to style rich text and customize rendering: {@link https://prismic.io/docs/fields/rich-text}\n */\nexport type HTMLRichTextFunctionSerializer = (\n\ttype: Parameters<RichTextFunctionSerializer<string>>[0],\n\tnode: Parameters<RichTextFunctionSerializer<string>>[1],\n\ttext: Parameters<RichTextFunctionSerializer<string>>[2],\n\tchildren: Parameters<RichTextFunctionSerializer<string>>[3][number],\n\tkey: Parameters<RichTextFunctionSerializer<string>>[4],\n) => string | null | undefined\n\n/**\n * Serializes a node from a rich text field with a map to HTML.\n *\n * Unlike a typical `@prismicio/client/richtext` map serializer, this serializer\n * converts the `children` property to a single string rather than an array of\n * strings and accepts shorthand declarations.\n *\n * @see Learn how to style rich text and customize rendering: {@link https://prismic.io/docs/fields/rich-text}\n */\nexport type HTMLRichTextMapSerializer = {\n\t[P in keyof RichTextMapSerializer<string>]: P extends RichTextMapSerializer<string>[\"span\"]\n\t\t? HTMLStrictRichTextMapSerializer[P]\n\t\t: HTMLStrictRichTextMapSerializer[P] | HTMLRichTextMapSerializerShorthand\n}\n\n/**\n * Serializes a node from a rich text field with a map to HTML.\n *\n * Unlike a typical `@prismicio/client/richtext` map serializer, this serializer\n * converts the `children` property to a single string rather than an array of\n * strings but doesn't accept shorthand declarations.\n *\n * @see Learn how to style rich text and customize rendering: {@link https://prismic.io/docs/fields/rich-text}\n */\nexport type HTMLStrictRichTextMapSerializer = {\n\t[P in keyof RichTextMapSerializer<string>]: (payload: {\n\t\ttype: Parameters<HTMLRichTextMapSerializerFunction<P>>[0][\"type\"]\n\t\tnode: Parameters<HTMLRichTextMapSerializerFunction<P>>[0][\"node\"]\n\t\ttext: Parameters<HTMLRichTextMapSerializerFunction<P>>[0][\"text\"]\n\t\tchildren: Parameters<\n\t\t\tHTMLRichTextMapSerializerFunction<P>\n\t\t>[0][\"children\"][number]\n\t\tkey: Parameters<HTMLRichTextMapSerializerFunction<P>>[0][\"key\"]\n\t}) => string | null | undefined\n}\n\n/**\n * A {@link RichTextMapSerializerFunction} type specifically for\n * {@link HTMLRichTextMapSerializer}.\n *\n * @typeParam BlockName - The serializer's rich text block type.\n */\ntype HTMLRichTextMapSerializerFunction<\n\tBlockType extends keyof RichTextMapSerializer<string>,\n> = RichTextMapSerializerFunction<\n\tstring,\n\tExtractNodeGeneric<RichTextMapSerializer<string>[BlockType]>,\n\tExtractTextTypeGeneric<RichTextMapSerializer<string>[BlockType]>\n>\n\n/**\n * Returns the `Node` generic from {@link RichTextMapSerializerFunction}.\n *\n * @typeParam T - The `RichTextMapSerializerFunction` containing the needed\n *   `Node` generic.\n */\ntype ExtractNodeGeneric<T> =\n\tT extends RichTextMapSerializerFunction<\n\t\t// oxlint-disable-next-line no-explicit-any\n\t\tany,\n\t\tinfer U,\n\t\t// oxlint-disable-next-line no-explicit-any\n\t\tany\n\t>\n\t\t? U\n\t\t: never\n\n/**\n * Returns the `TextType` generic from {@link RichTextMapSerializerFunction}.\n *\n * @typeParam T - The `RichTextMapSerializerFunction` containing the needed\n *   `TextType` generic.\n */\ntype ExtractTextTypeGeneric<T> =\n\tT extends RichTextMapSerializerFunction<\n\t\t// oxlint-disable-next-line no-explicit-any\n\t\tany,\n\t\t// oxlint-disable-next-line no-explicit-any\n\t\tany,\n\t\tinfer U\n\t>\n\t\t? U\n\t\t: never\n\n/**\n * A shorthand definition for {@link HTMLRichTextMapSerializer} element types.\n */\nexport type HTMLRichTextMapSerializerShorthand = {\n\t/**\n\t * Classes to apply to the element type.\n\t */\n\tclass?: string\n\n\t/**\n\t * Other attributes to apply to the element type.\n\t */\n\t[Attribute: string]: string | boolean | null | undefined\n}\n\n/**\n * Serializes a node from a rich text field with a map or a function to HTML.\n *\n * @see {@link HTMLRichTextMapSerializer} and {@link HTMLRichTextFunctionSerializer}\n * @see Learn how to style rich text and customize rendering: {@link https://prismic.io/docs/fields/rich-text}\n */\nexport type HTMLRichTextSerializer =\n\t| HTMLRichTextMapSerializer\n\t| HTMLRichTextFunctionSerializer\n\n/**\n * Creates a HTML rich text serializer with a given link resolver and provide\n * sensible and safe defaults for every node type\n *\n * @internal\n */\nconst createHTMLRichTextSerializer = (\n\tlinkResolver: LinkResolverFunction | undefined | null,\n\tserializer?: HTMLRichTextMapSerializer | null,\n): RichTextFunctionSerializer<string> => {\n\tconst useSerializerOrDefault = <\n\t\tBlockType extends keyof RichTextMapSerializer<string>,\n\t>(\n\t\tnodeSerializerOrShorthand: HTMLRichTextMapSerializer[BlockType],\n\t\tdefaultWithShorthand: NonNullable<\n\t\t\tHTMLStrictRichTextMapSerializer[BlockType]\n\t\t>,\n\t): NonNullable<HTMLStrictRichTextMapSerializer[BlockType]> => {\n\t\tif (typeof nodeSerializerOrShorthand === \"function\") {\n\t\t\treturn ((payload) => {\n\t\t\t\treturn (\n\t\t\t\t\t(\n\t\t\t\t\t\tnodeSerializerOrShorthand as HTMLStrictRichTextMapSerializer[BlockType]\n\t\t\t\t\t)?.(payload) || defaultWithShorthand(payload)\n\t\t\t\t)\n\t\t\t}) as NonNullable<HTMLStrictRichTextMapSerializer[BlockType]>\n\t\t}\n\n\t\treturn defaultWithShorthand\n\t}\n\n\tconst mapSerializer: Required<HTMLStrictRichTextMapSerializer> = {\n\t\theading1: useSerializerOrDefault<\"heading1\">(\n\t\t\tserializer?.heading1,\n\t\t\tserializeStandardTag<\"heading1\">(\"h1\", serializer?.heading1),\n\t\t),\n\t\theading2: useSerializerOrDefault<\"heading2\">(\n\t\t\tserializer?.heading2,\n\t\t\tserializeStandardTag<\"heading2\">(\"h2\", serializer?.heading2),\n\t\t),\n\t\theading3: useSerializerOrDefault<\"heading3\">(\n\t\t\tserializer?.heading3,\n\t\t\tserializeStandardTag<\"heading3\">(\"h3\", serializer?.heading3),\n\t\t),\n\t\theading4: useSerializerOrDefault<\"heading4\">(\n\t\t\tserializer?.heading4,\n\t\t\tserializeStandardTag<\"heading4\">(\"h4\", serializer?.heading4),\n\t\t),\n\t\theading5: useSerializerOrDefault<\"heading5\">(\n\t\t\tserializer?.heading5,\n\t\t\tserializeStandardTag<\"heading5\">(\"h5\", serializer?.heading5),\n\t\t),\n\t\theading6: useSerializerOrDefault<\"heading6\">(\n\t\t\tserializer?.heading6,\n\t\t\tserializeStandardTag<\"heading6\">(\"h6\", serializer?.heading6),\n\t\t),\n\t\tparagraph: useSerializerOrDefault<\"paragraph\">(\n\t\t\tserializer?.paragraph,\n\t\t\tserializeStandardTag<\"paragraph\">(\"p\", serializer?.paragraph),\n\t\t),\n\t\tpreformatted: useSerializerOrDefault<\"preformatted\">(\n\t\t\tserializer?.preformatted,\n\t\t\tserializePreFormatted(serializer?.preformatted),\n\t\t),\n\t\tstrong: useSerializerOrDefault<\"strong\">(\n\t\t\tserializer?.strong,\n\t\t\tserializeStandardTag<\"strong\">(\"strong\", serializer?.strong),\n\t\t),\n\t\tem: useSerializerOrDefault<\"em\">(\n\t\t\tserializer?.em,\n\t\t\tserializeStandardTag<\"em\">(\"em\", serializer?.em),\n\t\t),\n\t\tlistItem: useSerializerOrDefault<\"listItem\">(\n\t\t\tserializer?.listItem,\n\t\t\tserializeStandardTag<\"listItem\">(\"li\", serializer?.listItem),\n\t\t),\n\t\toListItem: useSerializerOrDefault<\"oListItem\">(\n\t\t\tserializer?.oListItem,\n\t\t\tserializeStandardTag<\"oListItem\">(\"li\", serializer?.oListItem),\n\t\t),\n\t\tlist: useSerializerOrDefault<\"list\">(\n\t\t\tserializer?.list,\n\t\t\tserializeStandardTag<\"list\">(\"ul\", serializer?.list),\n\t\t),\n\t\toList: useSerializerOrDefault<\"oList\">(\n\t\t\tserializer?.oList,\n\t\t\tserializeStandardTag<\"oList\">(\"ol\", serializer?.oList),\n\t\t),\n\t\timage: useSerializerOrDefault<\"image\">(\n\t\t\tserializer?.image,\n\t\t\tserializeImage(linkResolver, serializer?.image),\n\t\t),\n\t\tembed: useSerializerOrDefault<\"embed\">(\n\t\t\tserializer?.embed,\n\t\t\tserializeEmbed(serializer?.embed),\n\t\t),\n\t\thyperlink: useSerializerOrDefault<\"hyperlink\">(\n\t\t\tserializer?.hyperlink,\n\t\t\tserializeHyperlink(linkResolver, serializer?.hyperlink),\n\t\t),\n\t\tlabel: useSerializerOrDefault<\"label\">(\n\t\t\tserializer?.label,\n\t\t\tserializeStandardTag<\"label\">(\"span\", serializer?.label),\n\t\t),\n\t\tspan: useSerializerOrDefault<\"span\">(serializer?.span, serializeSpan()),\n\t}\n\n\treturn wrapMapSerializerWithStringChildren(mapSerializer)\n}\n\n/**\n * Wraps a map serializer into a regular function serializer. The given map\n * serializer should accept children as a string, not as an array of strings\n * like `@prismicio/client/richtext`'s `wrapMapSerializer`.\n *\n * @param mapSerializer - Map serializer to wrap\n *\n * @returns A regular function serializer\n */\nconst wrapMapSerializerWithStringChildren = (\n\tmapSerializer: HTMLStrictRichTextMapSerializer,\n): RichTextFunctionSerializer<string> => {\n\tconst modifiedMapSerializer = {} as RichTextMapSerializer<string>\n\n\tfor (const tag in mapSerializer) {\n\t\tconst tagSerializer = mapSerializer[tag as keyof typeof mapSerializer]\n\n\t\tif (tagSerializer) {\n\t\t\tmodifiedMapSerializer[tag as keyof typeof mapSerializer] = (payload) => {\n\t\t\t\treturn tagSerializer({\n\t\t\t\t\t...payload,\n\t\t\t\t\t// @ts-expect-error - merging blockSerializer types causes TS to bail to a never type\n\t\t\t\t\tchildren: payload.children.join(\"\"),\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\treturn wrapMapSerializer(modifiedMapSerializer)\n}\n\n/**\n * Configuration that determines the output of `asHTML()`.\n */\ntype AsHTMLConfig = {\n\t/**\n\t * An optional link resolver function to resolve links. Without it, you're\n\t * expected to use the `routes` option from the API.\n\t */\n\tlinkResolver?: LinkResolverFunction | null\n\n\t/**\n\t * An optional rich text serializer. Unhandled cases will fall back to the\n\t * default serializer.\n\t */\n\tserializer?: HTMLRichTextSerializer | null\n}\n\n// TODO: Remove when we remove support for deprecated tuple-style configuration.\n/**\n * @deprecated Use object-style configuration instead.\n */\ntype AsHTMLDeprecatedTupleConfig = [\n\tlinkResolver?: LinkResolverFunction | null,\n\tserializer?: HTMLRichTextSerializer | null,\n]\n\n/**\n * The return type of `asHTML()`.\n */\ntype AsHTMLReturnType<Field extends RichTextField | null | undefined> =\n\tField extends RichTextField ? string : null\n\n// TODO: Remove overload when we remove support for deprecated tuple-style configuration.\nexport const asHTML: {\n\t/**\n\t * Converts a rich text field to an HTML string.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const html = asHTML(document.data.content)\n\t * // => \"<p>Hello world</p>\"\n\t * ```\n\t *\n\t * @param richTextField - A rich text field from Prismic.\n\t * @param config - Configuration that determines the output of `asHTML()`.\n\t *\n\t * @returns HTML equivalent of the rich text field, or `null` if the field is\n\t *   empty.\n\t *\n\t * @see Learn how to style rich text and customize rendering: {@link https://prismic.io/docs/fields/rich-text}\n\t */\n\t<Field extends RichTextField | null | undefined>(\n\t\trichTextField: Field,\n\t\tconfig?: AsHTMLConfig,\n\t): AsHTMLReturnType<Field>\n\n\t/**\n\t * Converts a rich text field to an HTML string.\n\t *\n\t * @deprecated Use object-style configuration instead.\n\t *\n\t * @param richTextField - A rich text field from Prismic.\n\t * @param linkResolver - An optional link resolver function to resolve links.\n\t *   Without it, you're expected to use the `routes` option from the API.\n\t * @param serializer - An optional rich text serializer. Unhandled cases will\n\t *   fall back to the default serializer.\n\t *\n\t * @returns HTML equivalent of the rich text field, or `null` if the field is\n\t *   empty.\n\t *\n\t * @see Learn how to style rich text and customize rendering: {@link https://prismic.io/docs/fields/rich-text}\n\t */\n\t<Field extends RichTextField | null | undefined>(\n\t\trichTextField: Field,\n\t\t...config: AsHTMLDeprecatedTupleConfig\n\t): AsHTMLReturnType<Field>\n} = <Field extends RichTextField | null | undefined>(\n\trichTextField: Field,\n\t// TODO: Rename to `config` when we remove support for deprecated tuple-style configuration.\n\t...configObjectOrTuple: [config?: AsHTMLConfig] | AsHTMLDeprecatedTupleConfig\n): AsHTMLReturnType<Field> => {\n\tif (richTextField) {\n\t\t// TODO: Remove when we remove support for deprecated tuple-style configuration.\n\t\tconst [configObjectOrLinkResolver, maybeSerializer] = configObjectOrTuple\n\t\tlet config: AsHTMLConfig\n\t\tif (\n\t\t\ttypeof configObjectOrLinkResolver === \"function\" ||\n\t\t\tconfigObjectOrLinkResolver == null\n\t\t) {\n\t\t\tconfig = {\n\t\t\t\tlinkResolver: configObjectOrLinkResolver,\n\t\t\t\tserializer: maybeSerializer,\n\t\t\t}\n\t\t} else {\n\t\t\tconfig = { ...configObjectOrLinkResolver }\n\t\t}\n\n\t\tlet serializer: RichTextFunctionSerializer<string>\n\t\tif (config.serializer) {\n\t\t\tif (typeof config.serializer === \"function\") {\n\t\t\t\tserializer = composeSerializers(\n\t\t\t\t\t(type, node, text, children, key) =>\n\t\t\t\t\t\t// TypeScript doesn't narrow the type correctly here since it is now in a callback function, so we have to cast it here.\n\t\t\t\t\t\t(config.serializer as HTMLRichTextFunctionSerializer)(\n\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\tnode,\n\t\t\t\t\t\t\ttext,\n\t\t\t\t\t\t\tchildren.join(\"\"),\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t),\n\t\t\t\t\tcreateHTMLRichTextSerializer(config.linkResolver),\n\t\t\t\t)\n\t\t\t} else {\n\t\t\t\tserializer = createHTMLRichTextSerializer(\n\t\t\t\t\tconfig.linkResolver,\n\t\t\t\t\tconfig.serializer,\n\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tserializer = createHTMLRichTextSerializer(config.linkResolver)\n\t\t}\n\n\t\treturn serialize(richTextField, serializer).join(\n\t\t\t\"\",\n\t\t) as AsHTMLReturnType<Field>\n\t} else {\n\t\treturn null as AsHTMLReturnType<Field>\n\t}\n}\n","import type { ImgixURLParams } from \"./types.generated\";\n\n/**\n * Converts a camel case string to a param case string.\n *\n * @example\n *\n * ```ts\n * camelCaseToParamCase(\"fooBar\");\n * // => 'foo-bar'\n * ```\n *\n * @param input - Camel case string to convert.\n *\n * @returns Param case version of `input`.\n */\nconst camelCaseToParamCase = (input: string): string => {\n\treturn input.replace(/[A-Z]/g, (match) => {\n\t\treturn `-${match.toLowerCase()}`;\n\t});\n};\n\n/**\n * Builds a URL to an Imgix image with Imgix URL API parameters.\n *\n * The given URL must be a full absolute URL containing the protocol and domain.\n *\n * URL parameters already applied to the image will be retained. To remove\n * existing parameters, set the parameter to `undefined` in the `params`\n * argument.\n *\n * @example\n *\n * ```ts\n * const url = buildURL(\"https://example.imgix.net/image.png\", {\n * \twidth: 400,\n * });\n * // => https://example.imgix.net/image.png?width=400\n * ```\n *\n * @example\n *\n * ```ts\n * const url = buildURL(\"https://example.imgix.net/image.png?width=400\", {\n * \theight: 300,\n * });\n * // => https://example.imgix.net/image.png?width=400&height=300\n * ```\n *\n * @param url - Full absolute URL to the Imgix image.\n * @param params - An object of Imgix URL API parameters.\n *\n * @returns `url` with the given Imgix URL API parameters applied.\n *\n * @see Imgix URL API reference: https://docs.imgix.com/apis/rendering\n */\nexport const buildURL = (url: string, params: ImgixURLParams): string => {\n\tconst instance = new URL(url);\n\n\tfor (const camelCasedParamKey in params) {\n\t\tconst paramKey = camelCaseToParamCase(camelCasedParamKey);\n\t\tconst paramValue = params[camelCasedParamKey as keyof typeof params];\n\n\t\tif (paramValue === undefined) {\n\t\t\tinstance.searchParams.delete(paramKey);\n\t\t} else if (Array.isArray(paramValue)) {\n\t\t\tinstance.searchParams.set(paramKey, paramValue.join(\",\"));\n\t\t} else {\n\t\t\tinstance.searchParams.set(paramKey, `${paramValue}`);\n\t\t}\n\t}\n\n\t// Ensure the `s` parameter is the last parameter, if it exists.\n\t// @see https://github.com/imgix/imgix-blueprint#securing-urls\n\tconst s = instance.searchParams.get(\"s\");\n\tif (s) {\n\t\tinstance.searchParams.delete(\"s\");\n\t\tinstance.searchParams.append(\"s\", s);\n\t}\n\n\treturn instance.toString();\n};\n","import type { ImgixURLParams } from \"./types.generated\";\nimport { buildURL } from \"./buildURL\";\n\n/**\n * Parameters for `buildPixelDensitySrcSet`.\n */\nexport type BuildPixelDensitySrcSetParams = Omit<ImgixURLParams, \"dpr\"> & {\n\t/**\n\t * The pixel densities to include in the resulting `srcset` value.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * [1, 2, 3];\n\t * ```\n\t */\n\tpixelDensities: number[];\n};\n\n/**\n * Builds an `<img>` `srcset` attribute value for a given set of pixel\n * densities. It can also optinally apply Imgix URL API parameters to the URLs.\n *\n * The `dpr` URL parameter will be applied for each `srcset` entry. If a `dpr`\n * parameter is provided to the `params` parameter, it will be ignored.\n *\n * @example\n *\n * ```ts\n * const srcset = buildPixelDensitySrcSet(\n * \t\"https://example.imgix.net/image.png\",\n * \t{ pixelDensities: [1, 2, 3] },\n * );\n * // => https://example.imgix.net/image.png?dpr=1 1x,\n * //    https://example.imgix.net/image.png?dpr=2 2x,\n * //    https://example.imgix.net/image.png?dpr=3 3x\n * ```\n *\n * @example\n *\n * ```ts\n * const srcset = buildPixelDensitySrcSet(\n * \t\"https://example.imgix.net/image.png\",\n * \t{\n * \t\tpixelDensities: [1, 2, 3],\n * \t\tsat: -100,\n * \t},\n * );\n * // => https://example.imgix.net/image.png?dpr=1&sat=-100 1x,\n * //    https://example.imgix.net/image.png?dpr=2&sat=-100 2x,\n * //    https://example.imgix.net/image.png?dpr=3&sat=-100 3x\n * ```\n *\n * @param url - Full absolute URL to the Imgix image.\n * @param params - An object of Imgix URL API parameters. The `pixelDensities`\n *   parameter defines the resulting `srcset` widths.\n *\n * @returns A `srcset` attribute value for `url` with the given Imgix URL API\n *   parameters applied.\n */\nexport const buildPixelDensitySrcSet = (\n\turl: string,\n\t{ pixelDensities, ...params }: BuildPixelDensitySrcSetParams,\n): string => {\n\treturn pixelDensities\n\t\t.map((dpr) => {\n\t\t\treturn `${buildURL(url, { ...params, dpr })} ${dpr}x`;\n\t\t})\n\t\t.join(\", \");\n};\n","import type { ImgixURLParams } from \"./types.generated\";\nimport { buildURL } from \"./buildURL\";\n\n/**\n * Parameters for `buildWidthSrcSet`.\n */\nexport type BuildWidthSrcSetParams = Omit<\n\tImgixURLParams,\n\t\"width\" | \"w\" | \"height\" | \"h\"\n> & {\n\t/**\n\t * The pixel widths to include in the resulting `srcset` value.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * [400, 800, 1600];\n\t * ```\n\t */\n\twidths: number[];\n};\n\n/**\n * Builds an `<img>` `srcset` attribute value for a given set of widths. It can\n * also optinally apply Imgix URL API parameters to the URLs.\n *\n * The `width` URL parameter will be applied for each `srcset` entry. If a\n * `width` or `w` parameter is provided to the `params` parameter, it will be\n * ignored. Similarly, if a `height` or `h` parameter is provided to the\n * `params` parameter, it will be ignored to prevent unexpected aspect ratio.\n *\n * @example\n *\n * ```ts\n * const srcset = buildWidthSrcSet(\"https://example.imgix.net/image.png\", {\n * \twidths: [400, 800, 1600],\n * });\n * // => https://example.imgix.net/image.png?width=400 400w,\n * //    https://example.imgix.net/image.png?width=800 800w,\n * //    https://example.imgix.net/image.png?width=1600 1600w\n * ```\n *\n * @example\n *\n * ```ts\n * const srcset = buildWidthSrcSet(\"https://example.imgix.net/image.png\", {\n * \twidths: [400, 800, 1600],\n * \tsat: -100,\n * });\n * // => https://example.imgix.net/image.png?width=400&sat=-100 400w,\n * //    https://example.imgix.net/image.png?width=800&sat=-100 800w,\n * //    https://example.imgix.net/image.png?width=1600&sat=-100 1600w\n * ```\n *\n * @param url - Full absolute URL to the Imgix image.\n * @param params - An object of Imgix URL API parameters. The `widths` parameter\n *   defines the resulting `srcset` widths.\n *\n * @returns A `srcset` attribute value for `url` with the given Imgix URL API\n *   parameters applied.\n */\nexport const buildWidthSrcSet = (\n\turl: string,\n\t{ widths, ...params }: BuildWidthSrcSetParams,\n): string => {\n\treturn widths\n\t\t.map((width) => {\n\t\t\treturn `${buildURL(url, { ...params, w: undefined, h: undefined, height: undefined, width })} ${width}w`;\n\t\t})\n\t\t.join(\", \");\n};\n","import { Client } from \"./Client.js\";\nimport { buildURL } from \"./buildURL.js\";\nimport { buildWidthSrcSet } from \"./buildWidthSrcSet.js\";\nimport { buildPixelDensitySrcSet } from \"./buildPixelDensitySrcSet.js\";\nexport {\n  Client,\n  buildPixelDensitySrcSet,\n  buildURL,\n  buildWidthSrcSet\n};\n//# sourceMappingURL=index.js.map\n","import type { ImgixURLParams } from \"imgix-url-builder\"\nimport { buildURL } from \"imgix-url-builder\"\n\nimport type { ImageFieldImage } from \"../types/value/image\"\n\nimport { imageThumbnail as isImageThumbnailFilled } from \"./isFilled\"\n\n/**\n * The return type of `asImageSrc()`.\n */\ntype AsImageSrcReturnType<Field extends ImageFieldImage | null | undefined> =\n\tField extends ImageFieldImage<\"filled\"> ? string : null\n\n/**\n * Returns the URL of an image field with optional image transformations via\n * imgix URL parameters.\n *\n * @example\n *\n * ```ts\n * const src = asImageSrc(document.data.photo, { sat: -100 })\n * // => \"https://images.prismic.io/repo/image.png?sat=-100\"\n * ```\n *\n * @param field - An image field (or one of its responsive views) from which to\n *   get an image URL.\n * @param config - An object of imgix URL API parameters to transform the image.\n *\n * @returns The image field's URL with transformations applied, or `null` if the\n *   field is empty.\n *\n * @see Learn how to optimize images with imgix: {@link https://prismic.io/docs/fields/image}\n * @see imgix URL parameters reference: {@link https://docs.imgix.com/apis/rendering}\n */\nexport const asImageSrc = <Field extends ImageFieldImage | null | undefined>(\n\tfield: Field,\n\tconfig: ImgixURLParams = {},\n): AsImageSrcReturnType<Field> => {\n\tif (field && isImageThumbnailFilled(field)) {\n\t\treturn buildURL(field.url, config) as AsImageSrcReturnType<Field>\n\t} else {\n\t\treturn null as AsImageSrcReturnType<Field>\n\t}\n}\n","import type { BuildWidthSrcSetParams } from \"imgix-url-builder\"\nimport { buildURL, buildWidthSrcSet } from \"imgix-url-builder\"\n\nimport type { ImageFieldImage } from \"../types/value/image\"\n\nimport * as isFilled from \"./isFilled\"\n\n/**\n * The default widths used to generate a `srcset` value.\n */\nconst DEFAULT_WIDTHS = [640, 828, 1200, 2048, 3840]\n\n/**\n * The return type of `asImageWidthSrcSet()`.\n */\ntype AsImageWidthSrcSetReturnType<\n\tField extends ImageFieldImage | null | undefined,\n> =\n\tField extends ImageFieldImage<\"filled\">\n\t\t? {\n\t\t\t\t/**\n\t\t\t\t * The image field's URL with imgix URL parameters (if given).\n\t\t\t\t */\n\t\t\t\tsrc: string\n\n\t\t\t\t/**\n\t\t\t\t * A width-based `srcset` attribute value for the image field with imgix\n\t\t\t\t * URL parameters (if given).\n\t\t\t\t */\n\t\t\t\tsrcset: string\n\t\t\t}\n\t\t: null\n\n/**\n * Configuration for `asImageWidthSrcSet()`.\n */\ntype AsImageWidthSrcSetConfig = Omit<BuildWidthSrcSetParams, \"widths\"> & {\n\twidths?: \"thumbnails\" | BuildWidthSrcSetParams[\"widths\"]\n}\n\n/**\n * Creates a width-based `srcset` from an image field with optional image\n * transformations via imgix URL parameters.\n *\n * If a `widths` parameter is not given, the following widths (in pixels) will\n * be used by default: 640, 750, 828, 1080, 1200, 1920, 2048, 3840.\n *\n * If the image field contains responsive views, each responsive view can be\n * used as a width in the resulting `srcset` by passing `\"thumbnails\"` as the\n * `widths` parameter.\n *\n * @example\n *\n * ```ts\n * const srcset = asImageWidthSrcSet(document.data.photo, {\n * \twidths: [400, 800, 1600],\n * \tsat: -100,\n * })\n * // => {\n * //   src: \"https://images.prismic.io/repo/image.png?sat=-100\",\n * //   srcset: \"https://images.prismic.io/repo/image.png?sat=-100&width=400 400w, \" +\n * //           \"https://images.prismic.io/repo/image.png?sat=-100&width=800 800w, \" +\n * //           \"https://images.prismic.io/repo/image.png?sat=-100&width=1600 1600w\"\n * // }\n * ```\n *\n * @param field - An image field (or one of its responsive views) from which to\n *   get an image URL.\n * @param config - An object of imgix URL API parameters. The `widths` parameter\n *   defines the resulting `srcset` widths. Pass `\"thumbnails\"` to automatically\n *   use the field's responsive views.\n *\n * @returns A `srcset` attribute value for the image field with imgix URL\n *   parameters, or `null` if the field is empty.\n *\n * @see Learn how to optimize images with imgix: {@link https://prismic.io/docs/fields/image}\n * @see imgix URL parameters reference: {@link https://docs.imgix.com/apis/rendering}\n */\nexport const asImageWidthSrcSet = <\n\tField extends ImageFieldImage | null | undefined,\n>(\n\tfield: Field,\n\tconfig: AsImageWidthSrcSetConfig = {},\n): AsImageWidthSrcSetReturnType<Field> => {\n\tif (field && isFilled.imageThumbnail(field)) {\n\t\t// We are using destructuring to omit `widths` from the object\n\t\t// we will pass to `buildURL()`.\n\t\tlet { widths = DEFAULT_WIDTHS, ...imgixParams } = config\n\t\tconst {\n\t\t\turl,\n\t\t\tdimensions,\n\t\t\tid: _id,\n\t\t\talt: _alt,\n\t\t\tcopyright: _copyright,\n\t\t\tedit: _edit,\n\t\t\t...responsiveViews\n\t\t} = field\n\n\t\t// The Prismic Rest API will always return thumbnail values if\n\t\t// the base size is filled.\n\t\tconst responsiveViewObjects: ImageFieldImage<\"filled\">[] =\n\t\t\tObject.values(responsiveViews)\n\n\t\t// If this `asImageWidthSrcSet()` call is configured to use\n\t\t// thumbnail widths, but the field does not have thumbnails, we\n\t\t// fall back to the default set of widths.\n\t\tif (widths === \"thumbnails\" && responsiveViewObjects.length < 1) {\n\t\t\twidths = DEFAULT_WIDTHS\n\t\t}\n\n\t\treturn {\n\t\t\tsrc: buildURL(url, imgixParams),\n\t\t\tsrcset:\n\t\t\t\t// By this point, we know `widths` can only be\n\t\t\t\t// `\"thubmanils\"` if the field has thumbnails.\n\t\t\t\twidths === \"thumbnails\"\n\t\t\t\t\t? [\n\t\t\t\t\t\t\tbuildWidthSrcSet(url, {\n\t\t\t\t\t\t\t\t...imgixParams,\n\t\t\t\t\t\t\t\twidths: [dimensions.width],\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\t...responsiveViewObjects.map((thumbnail) => {\n\t\t\t\t\t\t\t\treturn buildWidthSrcSet(thumbnail.url, {\n\t\t\t\t\t\t\t\t\t...imgixParams,\n\t\t\t\t\t\t\t\t\twidths: [thumbnail.dimensions.width],\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t].join(\", \")\n\t\t\t\t\t: buildWidthSrcSet(field.url, {\n\t\t\t\t\t\t\t...imgixParams,\n\t\t\t\t\t\t\twidths,\n\t\t\t\t\t\t}),\n\t\t} as AsImageWidthSrcSetReturnType<Field>\n\t} else {\n\t\treturn null as AsImageWidthSrcSetReturnType<Field>\n\t}\n}\n","import type { BuildPixelDensitySrcSetParams } from \"imgix-url-builder\"\nimport { buildPixelDensitySrcSet, buildURL } from \"imgix-url-builder\"\n\nimport type { ImageFieldImage } from \"../types/value/image\"\n\nimport { imageThumbnail as isImageThumbnailFilled } from \"./isFilled\"\n\n/**\n * The default pixel densities used to generate a `srcset` value.\n */\nconst DEFAULT_PIXEL_DENSITIES = [1, 2, 3]\n\n/**\n * Configuration for `asImagePixelDensitySrcSet()`.\n */\ntype AsImagePixelDensitySrcSetConfig = Omit<\n\tBuildPixelDensitySrcSetParams,\n\t\"pixelDensities\"\n> &\n\tPartial<Pick<BuildPixelDensitySrcSetParams, \"pixelDensities\">>\n\n/**\n * The return type of `asImagePixelDensitySrcSet()`.\n */\ntype AsImagePixelDensitySrcSetReturnType<\n\tField extends ImageFieldImage | null | undefined,\n> =\n\tField extends ImageFieldImage<\"filled\">\n\t\t? {\n\t\t\t\t/**\n\t\t\t\t * The image field's URL with imgix URL parameters (if given).\n\t\t\t\t */\n\t\t\t\tsrc: string\n\n\t\t\t\t/**\n\t\t\t\t * A pixel-density-based `srcset` attribute value for the image field\n\t\t\t\t * with imgix URL parameters (if given).\n\t\t\t\t */\n\t\t\t\tsrcset: string\n\t\t\t}\n\t\t: null\n\n/**\n * Creates a pixel-density-based `srcset` from an image field with optional\n * image transformations via imgix URL parameters.\n *\n * If a `pixelDensities` parameter is not given, the following pixel densities\n * will be used by default: 1, 2, 3.\n *\n * @example\n *\n * ```ts\n * const srcset = asImagePixelDensitySrcSet(document.data.photo, {\n * \tpixelDensities: [1, 2],\n * \tsat: -100,\n * })\n * // => {\n * //   src: \"https://images.prismic.io/repo/image.png?sat=-100\",\n * //   srcset: \"https://images.prismic.io/repo/image.png?sat=-100&dpr=1 1x, \" +\n * //           \"https://images.prismic.io/repo/image.png?sat=-100&dpr=2 2x\"\n * // }\n * ```\n *\n * @param field - An image field (or one of its responsive views) from which to\n *   get an image URL.\n * @param config - An object of imgix URL API parameters. The `pixelDensities`\n *   parameter defines the resulting `srcset` pixel densities.\n *\n * @returns A `srcset` attribute value for the image field with imgix URL\n *   parameters, or `null` if the field is empty.\n *\n * @see Learn how to optimize images with imgix: {@link https://prismic.io/docs/fields/image}\n * @see imgix URL parameters reference: {@link https://docs.imgix.com/apis/rendering}\n */\nexport const asImagePixelDensitySrcSet = <\n\tField extends ImageFieldImage | null | undefined,\n>(\n\tfield: Field,\n\tconfig: AsImagePixelDensitySrcSetConfig = {},\n): AsImagePixelDensitySrcSetReturnType<Field> => {\n\tif (field && isImageThumbnailFilled(field)) {\n\t\t// We are using destructuring to omit `pixelDensities` from the\n\t\t// object we will pass to `buildURL()`.\n\t\tconst { pixelDensities = DEFAULT_PIXEL_DENSITIES, ...imgixParams } = config\n\n\t\treturn {\n\t\t\tsrc: buildURL(field.url, imgixParams),\n\t\t\tsrcset: buildPixelDensitySrcSet(field.url, {\n\t\t\t\t...imgixParams,\n\t\t\t\tpixelDensities,\n\t\t\t}),\n\t\t} as AsImagePixelDensitySrcSetReturnType<Field>\n\t} else {\n\t\treturn null as AsImagePixelDensitySrcSetReturnType<Field>\n\t}\n}\n","import type { EmptyObjectField, FieldState } from \"./types\"\n\n/**\n * oEmbed 1.0 possible types.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\nexport const OEmbedType = {\n\tPhoto: \"photo\",\n\tVideo: \"video\",\n\tLink: \"link\",\n\tRich: \"rich\",\n} as const\n\n/**\n * oEmbed response base fields. Those are every mandatory fields an oEmbed\n * response must feature.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\ntype OEmbedBase<TType extends (typeof OEmbedType)[keyof typeof OEmbedType]> = {\n\t/**\n\t * oEmbed resource type.\n\t */\n\ttype: TType\n\n\t/**\n\t * oEmbed version number, this must be \"1.0\".\n\t */\n\tversion: string\n}\n\n/**\n * oEmbed response extra fields. Those are every non-mandatory and unknown\n * fields an oEmbed response can feature.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\nexport type OEmbedExtra = {\n\t/**\n\t * oEmbed text title, describing the resource.\n\t */\n\ttitle?: string | null\n\n\t/**\n\t * oEmbed resource author/owner name.\n\t */\n\tauthor_name?: string | null\n\n\t/**\n\t * oEmbed resource author/owner URL.\n\t */\n\tauthor_url?: string | null\n\n\t/**\n\t * oEmbed resource provider name.\n\t */\n\tprovider_name?: string | null\n\n\t/**\n\t * oEmbed resource provider URL.\n\t */\n\tprovider_url?: string | null\n\n\t/**\n\t * oEmbed suggested cache lifetime for the resource, in seconds.\n\t */\n\tcache_age?: number | null\n\n\t/**\n\t * oEmbed resource thumbnail URL.\n\t */\n\tthumbnail_url?: string | null\n\n\t/**\n\t * oEmbed resource thumbnail width.\n\t */\n\tthumbnail_width?: number | null\n\n\t/**\n\t * oEmbed resource thumbnail height.\n\t */\n\tthumbnail_height?: number | null\n\n\t/**\n\t * Providers may optionally include any parameters not specified in this\n\t * document (so long as they use the same key-value format) and consumers may\n\t * choose to ignore these. Consumers must ignore parameters they do not\n\t * understand.\n\t *\n\t * @see oEmbed specification: {@link https://oembed.com}\n\t */\n\t[key: string]: unknown | null\n}\n\n/**\n * oEmbed photo type. Those are every mandatory fields an oEmbed photo response\n * must feature.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\nexport type PhotoOEmbed = OEmbedBase<typeof OEmbedType.Photo> & {\n\t/**\n\t * oEmbed source URL of the image.\n\t */\n\turl: string\n\n\t/**\n\t * oEmbed width in pixels of the image.\n\t */\n\twidth: number\n\n\t/**\n\t * oEmbed height in pixels of the image.\n\t */\n\theight: number\n}\n\n/**\n * oEmbed video type. Those are every mandatory fields an oEmbed video response\n * must feature.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\nexport type VideoOEmbed = OEmbedBase<typeof OEmbedType.Video> & {\n\t/**\n\t * oEmbed HTML required to embed a video player.\n\t */\n\thtml: string\n\n\t/**\n\t * oEmbed width in pixels required to display the HTML.\n\t */\n\twidth: number\n\n\t/**\n\t * oEmbed height in pixels required to display the HTML.\n\t */\n\theight: number\n}\n\n/**\n * oEmbed link type. Those are every mandatory fields an oEmbed link response\n * must feature.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\nexport type LinkOEmbed = OEmbedBase<typeof OEmbedType.Link>\n\n/**\n * oEmbed rich type. Those are every mandatory fields an oEmbed rich response\n * must feature.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\nexport type RichOEmbed = OEmbedBase<typeof OEmbedType.Rich> & {\n\t/**\n\t * oEmbed HTML required to display the resource.\n\t */\n\thtml: string\n\n\t/**\n\t * oEmbed width in pixels required to display the HTML.\n\t */\n\twidth: number\n\n\t/**\n\t * oEmbed height in pixels required to display the HTML.\n\t */\n\theight: number\n}\n\n/**\n * Any of the possible types of oEmbed response. Those contains only mandatory\n * fields their respective oEmbed response type must feature.\n *\n * @see oEmbed specification: {@link https://oembed.com}\n */\nexport type AnyOEmbed = PhotoOEmbed | VideoOEmbed | LinkOEmbed | RichOEmbed\n\n/**\n * An embed field.\n *\n * @typeParam Data - Data provided by the URL's oEmbed provider.\n * @typeParam State - State of the field which determines its shape.\n *\n * @see More details: {@link https://prismic.io/docs/embed}\n */\nexport type EmbedField<\n\tData extends AnyOEmbed = AnyOEmbed & OEmbedExtra,\n\tState extends FieldState = FieldState,\n> = State extends \"empty\"\n\t? EmptyObjectField\n\t: Data & {\n\t\t\tembed_url: string\n\t\t\thtml: string | null\n\t\t}\n","import type { CustomTypeModelBooleanField } from \"./boolean\"\nimport type { CustomTypeModelColorField } from \"./color\"\nimport type { CustomTypeModelContentRelationshipField } from \"./contentRelationship\"\nimport type { CustomTypeModelDateField } from \"./date\"\nimport type { CustomTypeModelEmbedField } from \"./embed\"\nimport type { CustomTypeModelGeoPointField } from \"./geoPoint\"\nimport type {\n\tCustomTypeModelGroupField,\n\tCustomTypeModelNestedGroupField,\n} from \"./group\"\nimport type { CustomTypeModelImageField } from \"./image\"\nimport type { CustomTypeModelIntegrationField } from \"./integration\"\nimport type { CustomTypeModelKeyTextField } from \"./keyText\"\nimport type { CustomTypeModelLinkField } from \"./link\"\nimport type { CustomTypeModelLinkToMediaField } from \"./linkToMedia\"\nimport type { CustomTypeModelNumberField } from \"./number\"\nimport type { CustomTypeModelRangeField } from \"./range\"\nimport type { CustomTypeModelRichTextField } from \"./richText\"\nimport type { CustomTypeModelSelectField } from \"./select\"\nimport type { CustomTypeModelSeparatorField } from \"./separator\"\nimport type { CustomTypeModelSliceZoneField } from \"./sliceZone\"\nimport type { CustomTypeModelTableField } from \"./table\"\nimport type { CustomTypeModelTimestampField } from \"./timestamp\"\nimport type { CustomTypeModelTitleField } from \"./title\"\nimport type { CustomTypeModelUIDField } from \"./uid\"\n\n/**\n * Type identifier for a custom type field.\n */\nexport const CustomTypeModelFieldType = {\n\tBoolean: \"Boolean\",\n\tColor: \"Color\",\n\tDate: \"Date\",\n\tEmbed: \"Embed\",\n\tGeoPoint: \"GeoPoint\",\n\tGroup: \"Group\",\n\tImage: \"Image\",\n\tIntegration: \"IntegrationFields\",\n\tLink: \"Link\",\n\tNumber: \"Number\",\n\tSelect: \"Select\",\n\tSlices: \"Slices\",\n\tStructuredText: \"StructuredText\",\n\tTable: \"Table\",\n\tText: \"Text\",\n\tTimestamp: \"Timestamp\",\n\tUID: \"UID\",\n\t/**\n\t * @deprecated - Renamed to `Integration`.\n\t */\n\tIntegrationFields: \"IntegrationFields\",\n\t/**\n\t * @deprecated - Legacy field type. Use `Number` instead.\n\t */\n\tRange: \"Range\",\n\t/**\n\t * @deprecated - Legacy field type. Do not use.\n\t */\n\tSeparator: \"Separator\",\n\t/**\n\t * @deprecated - Legacy field type. Use `Slices` instead.\n\t */\n\tLegacySlices: \"Choice\",\n} as const\n\n/**\n * A custom type field.\n */\nexport type CustomTypeModelField =\n\t| CustomTypeModelUIDField\n\t| CustomTypeModelGroupField\n\t| CustomTypeModelSliceZoneField\n\t| CustomTypeModelFieldForNestedGroup\n\n/**\n * Any custom type field that is valid for a slice's primary section.\n */\nexport type CustomTypeModelFieldForSlicePrimary =\n\t| CustomTypeModelGroupField\n\t| CustomTypeModelFieldForNestedGroup\n\n/**\n * Any custom type field that is valid for a group field.\n */\nexport type CustomTypeModelFieldForGroup =\n\t| CustomTypeModelNestedGroupField\n\t| CustomTypeModelFieldForNestedGroup\n\n/**\n * Any custom type field that is valid for a nested group field.\n */\nexport type CustomTypeModelFieldForNestedGroup =\n\t| CustomTypeModelBooleanField\n\t| CustomTypeModelColorField\n\t| CustomTypeModelDateField\n\t| CustomTypeModelEmbedField\n\t| CustomTypeModelGeoPointField\n\t| CustomTypeModelImageField\n\t| CustomTypeModelIntegrationField\n\t| CustomTypeModelContentRelationshipField\n\t| CustomTypeModelLinkField\n\t| CustomTypeModelLinkToMediaField\n\t| CustomTypeModelNumberField\n\t| CustomTypeModelRangeField\n\t| CustomTypeModelSelectField\n\t| CustomTypeModelRichTextField\n\t| CustomTypeModelTableField\n\t| CustomTypeModelTitleField\n\t| CustomTypeModelKeyTextField\n\t| CustomTypeModelTimestampField\n\t| CustomTypeModelSeparatorField\n","import type { CustomTypeModelFieldType } from \"./types\"\n\n/**\n * A link custom type field.\n *\n * More details: {@link https://prismic.io/docs/link}\n */\nexport interface CustomTypeModelLinkField {\n\ttype: typeof CustomTypeModelFieldType.Link\n\tconfig?: {\n\t\tlabel?: string | null\n\t\tplaceholder?: string\n\t\tselect?:\n\t\t\t| null\n\t\t\t| (typeof CustomTypeModelLinkSelectType)[keyof typeof CustomTypeModelLinkSelectType]\n\t\tallowText?: boolean\n\t\tallowTargetBlank?: boolean\n\t\trepeat?: boolean\n\t\tvariants?: string[]\n\t}\n}\n\n/**\n * Type of a link custom type field.\n *\n * More details: {@link https://prismic.io/docs/link}\n */\nexport const CustomTypeModelLinkSelectType = {\n\tDocument: \"document\",\n\tMedia: \"media\",\n\tWeb: \"web\",\n} as const\n","import type { CustomTypeModelFieldType } from \"./types\"\n\nimport type { CustomTypeModelLegacySlice, CustomTypeModelSlice } from \"./slice\"\n\n/**\n * A Slice Zone custom type field.\n *\n * More details: {@link https://prismic.io/docs/slice}\n */\nexport interface CustomTypeModelSliceZoneField<\n\tSlices extends Record<\n\t\tstring,\n\t\t| CustomTypeModelSlice\n\t\t| CustomTypeModelSharedSlice\n\t\t| CustomTypeModelLegacySlice\n\t> = Record<\n\t\tstring,\n\t\t| CustomTypeModelSlice\n\t\t| CustomTypeModelSharedSlice\n\t\t| CustomTypeModelLegacySlice\n\t>,\n> {\n\ttype:\n\t\t| typeof CustomTypeModelFieldType.Slices\n\t\t| typeof CustomTypeModelFieldType.LegacySlices\n\tfieldset?: string | null\n\tconfig?: {\n\t\tlabels?: Record<string, readonly CustomTypeModelSliceLabel[]> | null\n\t\tchoices?: Slices\n\t}\n}\n\n/**\n * Label for a Slice.\n *\n * More details: {@link https://prismic.io/docs/slice}\n */\nexport interface CustomTypeModelSliceLabel {\n\tname: string\n\tdisplay?: string\n}\n\n/**\n * Type identifier for a Slice.\n *\n * More details: {@link https://prismic.io/docs/slice}\n */\nexport const CustomTypeModelSliceType = {\n\tSlice: \"Slice\",\n\tSharedSlice: \"SharedSlice\",\n} as const\n\n/**\n * A shared Slice for a custom type.\n *\n * More details: {@link https://prismic.io/docs/slice}\n */\nexport interface CustomTypeModelSharedSlice {\n\ttype: typeof CustomTypeModelSliceType.SharedSlice\n}\n","import type { CustomTypeModelFieldForNestedGroup } from \"./types\"\n\nimport type { CustomTypeModelNestedGroupField } from \"./group\"\nimport type { CustomTypeModelSliceType } from \"./sliceZone\"\n\n/**\n * A Slice for a custom type.\n *\n * More details: {@link https://prismic.io/docs/slice}\n *\n * @typeParam NonRepeatFields - A record of fields that cannnot be repeated.\n * @typeParam RepeatFields - A record of fields that can be repeated.\n */\nexport interface CustomTypeModelSlice<\n\tNonRepeatFields extends Record<\n\t\tstring,\n\t\tCustomTypeModelFieldForNestedGroup\n\t> = Record<string, CustomTypeModelFieldForNestedGroup>,\n\tRepeatFields extends Record<\n\t\tstring,\n\t\tCustomTypeModelFieldForNestedGroup\n\t> = Record<string, CustomTypeModelFieldForNestedGroup>,\n> {\n\ttype: typeof CustomTypeModelSliceType.Slice\n\tfieldset?: string | null\n\tdescription?: string\n\ticon?: string\n\tdisplay?:\n\t\t| (typeof CustomTypeModelSliceDisplay)[keyof typeof CustomTypeModelSliceDisplay]\n\t\t| string\n\t\"non-repeat\"?: NonRepeatFields\n\trepeat?: RepeatFields\n}\n\n/**\n * Display type for a Slice.\n *\n * More details: {@link https://prismic.io/docs/slice}\n */\nexport const CustomTypeModelSliceDisplay = {\n\tList: \"list\",\n\tGrid: \"grid\",\n} as const\n\n/**\n * @deprecated - Legacy slice type. Do not use.\n */\nexport type CustomTypeModelLegacySlice =\n\t| CustomTypeModelNestedGroupField\n\t| CustomTypeModelFieldForNestedGroup\n","import type { WebhookBodyAPIUpdate } from \"./apiUpdate\"\nimport type { WebhookBodyTestTrigger } from \"./testTrigger\"\n\nexport type WebhookBody = WebhookBodyAPIUpdate | WebhookBodyTestTrigger\n\n/**\n * Types of Prismic Webhooks.\n *\n * @see More details: {@link https://prismic.io/docs/webhooks}\n */\nexport const WebhookType = {\n\tAPIUpdate: \"api-update\",\n\tTestTrigger: \"test-trigger\",\n} as const\n\nexport interface WebhookBodyBase {\n\ttype: (typeof WebhookType)[keyof typeof WebhookType]\n\tdomain: string\n\tapiUrl: string\n\tsecret: string | null\n}\n","// Imports are used for deprecations.\nimport type { CustomTypeModelIntegrationField } from \"./types/model/integration\"\nimport type { IntegrationField } from \"./types/value/integration\"\nimport { RichTextNodeType } from \"./types/value/richText\"\n\nimport type {\n\tHTMLRichTextFunctionSerializer,\n\tHTMLRichTextMapSerializer,\n} from \"./helpers/asHTML\"\nimport { mapSliceZone } from \"./helpers/mapSliceZone\"\n\nimport { filter } from \"./filter\"\n\n//=============================================================================\n// Client - Query content from Prismic.\n//=============================================================================\n\n// Primary Client API.\nexport { createClient } from \"./createClient\"\nexport { Client } from \"./Client\"\n\n// Write Client API.\nexport { createWriteClient } from \"./createWriteClient\"\nexport { WriteClient } from \"./WriteClient\"\n\n// Migration helper.\nexport { createMigration } from \"./createMigration\"\nexport { Migration } from \"./Migration\"\n\n// API endpoint helpers.\nexport { getRepositoryEndpoint } from \"./getRepositoryEndpoint\"\nexport { getRepositoryName } from \"./getRepositoryName\"\nexport { getGraphQLEndpoint } from \"./getGraphQLEndpoint\"\nexport { isRepositoryName } from \"./isRepositoryName\"\nexport { isRepositoryEndpoint } from \"./isRepositoryEndpoint\"\nexport { buildQueryURL } from \"./buildQueryURL\"\n\n// Toolbar helpers.\nexport { getToolbarSrc } from \"./getToolbarSrc\"\n\n// Query filters API.\n/**\n * @deprecated Renamed to `filter`\n */\n// TODO: Remove when we remove support for deprecated `predicate` export.\nconst predicate = filter\nexport { filter, predicate }\n\n// A collection of well-known cookie names shared between Prismic libraries and systems.\nexport * as cookie from \"./cookie\"\n\n// General types used to query content from Prismic. These are made public to allow users to better type their projects.\nexport type { CreateClient } from \"./createClient\"\nexport type { ClientConfig, HttpRequestLike } from \"./Client\"\nexport type { CreateWriteClient } from \"./createWriteClient\"\nexport type { WriteClientConfig, MigrateReporterEvents } from \"./WriteClient\"\nexport type {\n\tBuildQueryURLArgs,\n\tOrdering,\n\tQueryParams,\n\tRoute,\n} from \"./buildQueryURL\"\nexport type { CreateMigration } from \"./createMigration\"\nexport type {\n\tAbortSignalLike,\n\tFetchLike,\n\tRequestInitLike,\n\tResponseLike,\n} from \"./lib/request\"\n\n//=============================================================================\n// Helpers - Manipulate content from Prismic.\n//=============================================================================\n\n// Primary Helpers API.\nexport { asDate } from \"./helpers/asDate\"\nexport { asLink } from \"./helpers/asLink\"\nexport { asLinkAttrs } from \"./helpers/asLinkAttrs\"\nexport { asText } from \"./helpers/asText\"\nexport { asHTML } from \"./helpers/asHTML\"\nexport { asImageSrc } from \"./helpers/asImageSrc\"\nexport { asImageWidthSrcSet } from \"./helpers/asImageWidthSrcSet\"\nexport { asImagePixelDensitySrcSet } from \"./helpers/asImagePixelDensitySrcSet\"\nexport * as isFilled from \"./helpers/isFilled\"\n\n/**\n * @deprecated Renamed to `mapSliceZone`\n */\nconst unstable_mapSliceZone = mapSliceZone\nexport { mapSliceZone, unstable_mapSliceZone }\n\n// Conversion helper.\nexport { documentToLinkField } from \"./helpers/documentToLinkField\"\n\nexport type { LinkResolverFunction } from \"./helpers/asLink\"\nexport type { AsLinkAttrsConfig } from \"./helpers/asLinkAttrs\"\nexport type { SliceMapper } from \"./helpers/mapSliceZone\"\n\n/**\n * @deprecated Renamed to `HTMLRichTextMapSerializer`\n */\ntype HTMLMapSerializer = HTMLRichTextMapSerializer\n/**\n * @deprecated Renamed to `HTMLRichTextFunctionSerializer`\n */\ntype HTMLFunctionSerializer = HTMLRichTextFunctionSerializer\nexport type {\n\tHTMLRichTextMapSerializer,\n\tHTMLRichTextFunctionSerializer,\n\tHTMLMapSerializer,\n\tHTMLFunctionSerializer,\n}\nexport type { HTMLRichTextSerializer } from \"./helpers/asHTML\"\n\n//=============================================================================\n// Errors - Custom errors for Prismic APIs.\n//=============================================================================\n\n// Client Errors\nexport {\n\tForbiddenError,\n\tInvalidDataError,\n\tNotFoundError,\n\tParsingError,\n\tPreviewTokenExpiredError,\n\tPrismicError,\n\tRefExpiredError,\n\tRefNotFoundError,\n\tRepositoryNotFoundError,\n} from \"./errors\"\n\n//=============================================================================\n// Types - Types representing Prismic content, models, and API payloads.\n//=============================================================================\n\n// Values - Types representing Prismic content.\n/**\n * @deprecated Use {@link RichTextNodeType} instead.\n */\n// TODO: Remove in v8.\nconst Element = RichTextNodeType\nexport { RichTextNodeType, Element }\nexport { LinkType } from \"./types/value/link\"\nexport { OEmbedType } from \"./types/value/embed\"\n\nexport type {\n\tPrismicDocument,\n\tPrismicDocumentWithUID,\n\tPrismicDocumentWithoutUID,\n\tPrismicDocumentHeader,\n\tAlternateLanguage,\n} from \"./types/value/document\"\n\nexport type {\n\t// RichText & Title\n\tRichTextField,\n\t// RichText & Title (block nodes)\n\tRTTextNodeBase,\n\tRTHeading1Node,\n\tRTHeading2Node,\n\tRTHeading3Node,\n\tRTHeading4Node,\n\tRTHeading5Node,\n\tRTHeading6Node,\n\tRTParagraphNode,\n\tRTPreformattedNode,\n\tRTListItemNode,\n\tRTOListItemNode,\n\t// RichText & Title (span nodes)\n\tRTSpanNodeBase,\n\tRTStrongNode,\n\tRTEmNode,\n\tRTLabelNode,\n\t// RichText & Title (media nodes)\n\tRTImageNode,\n\tRTEmbedNode,\n\t// RichText & Title (link nodes)\n\tRTLinkNode,\n\t// RichText & Title (serialization related nodes)\n\tRTListNode,\n\tRTOListNode,\n\tRTSpanNode,\n\t// RichText & Title (helpers)\n\tRTNode,\n\tRTTextNode,\n\tRTBlockNode,\n\tRTInlineNode,\n\tRTAnyNode,\n\tRichTextNodeTypes,\n} from \"./types/value/richText\"\nexport type { TitleField } from \"./types/value/title\"\n\nexport type {\n\tImageField,\n\tImageFieldImage,\n\tFilledImageFieldImage,\n\tEmptyImageFieldImage,\n} from \"./types/value/image\"\n\nexport type {\n\tEmptyLinkField,\n\tLinkField,\n\tFilledLinkToWebField,\n} from \"./types/value/link\"\nexport type {\n\tContentRelationshipField,\n\tFilledContentRelationshipField,\n} from \"./types/value/contentRelationship\"\nexport type {\n\tLinkToMediaField,\n\tFilledLinkToMediaField,\n} from \"./types/value/linkToMedia\"\n\nexport type {\n\tOEmbedExtra,\n\tPhotoOEmbed,\n\tVideoOEmbed,\n\tLinkOEmbed,\n\tRichOEmbed,\n\tAnyOEmbed,\n\tEmbedField,\n} from \"./types/value/embed\"\n\nexport type {\n\tTableField,\n\tTableFieldHead,\n\tTableFieldHeadRow,\n\tTableFieldBody,\n\tTableFieldBodyRow,\n\tTableFieldHeaderCell,\n\tTableFieldDataCell,\n} from \"./types/value/table\"\n\nexport type { BooleanField } from \"./types/value/boolean\"\nexport type { ColorField } from \"./types/value/color\"\nexport type { DateField } from \"./types/value/date\"\nexport type { KeyTextField } from \"./types/value/keyText\"\nexport type { NumberField } from \"./types/value/number\"\nexport type { SelectField } from \"./types/value/select\"\nexport type { TimestampField } from \"./types/value/timestamp\"\nexport type { GeoPointField } from \"./types/value/geoPoint\"\n\n/**\n * @deprecated Renamed to `IntegrationField`\n */\n// TODO: Remove when we remove support for deprecated `IntegrationFields` export.\ntype IntegrationFields = IntegrationField\nexport type { IntegrationField, IntegrationFields }\nexport type { IntegrationFieldData } from \"./types/value/integration\"\n\nexport type { GroupField, NestedGroupField } from \"./types/value/group\"\n\nexport type { SliceZone } from \"./types/value/sliceZone\"\nexport type { Slice } from \"./types/value/slice\"\nexport type { SharedSlice } from \"./types/value/sharedSlice\"\nexport type { SharedSliceVariation } from \"./types/value/sharedSliceVariation\"\n\nexport type {\n\tFieldState,\n\tAnyRegularField,\n\tAnySlicePrimaryField,\n\tRepeatable,\n} from \"./types/value/types\"\n\n// Models - Types representing Prismic content models.\nexport { CustomTypeModelFieldType } from \"./types/model/types\"\nexport { CustomTypeModelLinkSelectType } from \"./types/model/link\"\nexport { CustomTypeModelSliceType } from \"./types/model/sliceZone\"\nexport { CustomTypeModelSliceDisplay } from \"./types/model/slice\"\n\nexport type {\n\tCustomTypeModel,\n\tCustomTypeModelDefinition,\n\tCustomTypeModelTab,\n} from \"./types/model/customType\"\n\nexport type {\n\tCustomTypeModelRichTextField,\n\tCustomTypeModelRichTextMultiField,\n\tCustomTypeModelRichTextSingleField,\n} from \"./types/model/richText\"\nexport type { CustomTypeModelTitleField } from \"./types/model/title\"\n\nexport type {\n\tCustomTypeModelImageField,\n\tCustomTypeModelImageConstraint,\n\tCustomTypeModelImageThumbnail,\n} from \"./types/model/image\"\n\nexport type {\n\tCustomTypeModelFetchCustomTypeLevel1,\n\tCustomTypeModelFetchContentRelationshipLevel1,\n\tCustomTypeModelFetchGroupLevel1,\n\tCustomTypeModelFetchCustomTypeLevel2,\n\tCustomTypeModelFetchGroupLevel2,\n\tCustomTypeModelContentRelationshipField,\n} from \"./types/model/contentRelationship\"\nexport type { CustomTypeModelLinkField } from \"./types/model/link\"\nexport type { CustomTypeModelLinkToMediaField } from \"./types/model/linkToMedia\"\n\nexport type { CustomTypeModelEmbedField } from \"./types/model/embed\"\n\nexport type { CustomTypeModelBooleanField } from \"./types/model/boolean\"\nexport type { CustomTypeModelColorField } from \"./types/model/color\"\nexport type { CustomTypeModelDateField } from \"./types/model/date\"\nexport type { CustomTypeModelKeyTextField } from \"./types/model/keyText\"\nexport type { CustomTypeModelNumberField } from \"./types/model/number\"\nexport type { CustomTypeModelSelectField } from \"./types/model/select\"\nexport type { CustomTypeModelTimestampField } from \"./types/model/timestamp\"\nexport type { CustomTypeModelGeoPointField } from \"./types/model/geoPoint\"\nexport type { CustomTypeModelTableField } from \"./types/model/table\"\n\n/**\n * @deprecated Renamed to `CustomTypeModelIntegrationField`.\n */\n// TODO: Remove when we remove support for deprecated `CustomTypeModelIntegrationField` export.\ntype CustomTypeModelIntegrationFieldsField = CustomTypeModelIntegrationField\nexport {\n\tCustomTypeModelIntegrationField,\n\tCustomTypeModelIntegrationFieldsField,\n}\nexport type {\n\tCustomTypeModelGroupField,\n\tCustomTypeModelNestedGroupField,\n} from \"./types/model/group\"\nexport type {\n\tCustomTypeModelSliceZoneField,\n\tCustomTypeModelSliceLabel,\n\tCustomTypeModelSharedSlice,\n} from \"./types/model/sliceZone\"\nexport type {\n\tCustomTypeModelSlice,\n\tCustomTypeModelLegacySlice,\n} from \"./types/model/slice\"\nexport type { SharedSliceModel } from \"./types/model/sharedSlice\"\nexport type { SharedSliceModelVariation } from \"./types/model/sharedSliceVariation\"\n\nexport type { CustomTypeModelUIDField } from \"./types/model/uid\"\n\nexport type { CustomTypeModelRangeField } from \"./types/model/range\"\nexport type { CustomTypeModelSeparatorField } from \"./types/model/separator\"\n\nexport type {\n\tCustomTypeModelField,\n\tCustomTypeModelFieldForGroup,\n\tCustomTypeModelFieldForNestedGroup,\n\tCustomTypeModelFieldForSlicePrimary,\n} from \"./types/model/types\"\n\n// Migrations - Types representing Prismic Migration API content values.\nexport { PrismicMigrationDocument } from \"./types/migration/Document\"\nexport type {\n\tPendingPrismicDocument,\n\tExistingPrismicDocument,\n\tInjectMigrationSpecificTypes,\n} from \"./types/migration/Document\"\n\nexport { PrismicMigrationAsset } from \"./types/migration/Asset\"\nexport type {\n\tMigrationImage,\n\tMigrationLinkToMedia,\n\tMigrationRTImageNode,\n} from \"./types/migration/Asset\"\nexport type { MigrationContentRelationship } from \"./types/migration/ContentRelationship\"\n\n// API - Types representing Prismic Content API responses.\nexport type { Query } from \"./types/api/query\"\n\nexport type { Ref } from \"./types/api/ref\"\n\nexport type { Release } from \"./types/api/release\"\n\nexport type {\n\tRepository,\n\tLanguage,\n\tForm,\n\tFormField,\n} from \"./types/api/repository\"\n\nexport type { Tags } from \"./types/api/tags\"\n\n// Integration - Types representing Prismic's integration API.\nexport type {\n\tIntegrationAPIItem,\n\tIntegrationAPIResults,\n} from \"./types/api/integration\"\n\n// Webhook - Types representing Prismic webhooks.\nexport { WebhookType } from \"./types/webhook/types\"\n\nexport type { WebhookBody } from \"./types/webhook/types\"\n\nexport type { WebhookBodyAPIUpdate } from \"./types/webhook/apiUpdate\"\n\nexport type { WebhookBodyTestTrigger } from \"./types/webhook/testTrigger\"\n","/**\n * Shared types for prompt building\n */\n\nexport interface EssayContext {\n  title?: string\n  subtitle?: string\n  markdown?: string\n}\n\nexport interface StyleContext {\n  rules?: string\n  chatRules?: string\n  rewriteRules?: string\n  planRules?: string\n  styleExamples?: string\n}\n","/**\n * Default template for essay generation.\n * Placeholders: {{RULES}}, {{STYLE_EXAMPLES}}, {{WORD_COUNT}}\n */\nexport const DEFAULT_GENERATE_TEMPLATE = `<system>\n<role>Expert essay writer creating engaging, thoughtful content</role>\n\n<critical>\nALWAYS output a complete essay. NEVER respond conversationally.\n- Do NOT ask questions or request clarification\n- Do NOT say \"Here is your essay\" or similar preamble\n- Do NOT explain what you're going to write\n- If the prompt is vague, make creative choices and proceed\n- Output ONLY the essay in markdown format\n</critical>\n\n<rules>\n{{RULES}}\n</rules>\n\n<style_reference>\n{{STYLE_EXAMPLES}}\n</style_reference>\n\n<constraints>\n<word_count>{{WORD_COUNT}}</word_count>\n</constraints>\n\n<output_format>\nCRITICAL: Your response MUST start with exactly this format:\n\nLine 1: # [Your Title Here]\nLine 2: *[Your subtitle here]*\nLine 3: (blank line)\nLine 4+: Essay body in markdown\n\n<title_guidelines>\n- Be SPECIFIC, not generic (avoid \"The Power of\", \"Why X Matters\", \"A Guide to\")\n- Include a concrete detail, angle, or unexpected element\n- Create curiosity or make a bold claim\n- 5-12 words ideal\n</title_guidelines>\n\n<subtitle_guidelines>\n- One sentence that hooks the reader\n- Tease the main argument or reveal a key insight\n- Create tension, curiosity, or promise value\n- Make readers want to continue reading\n</subtitle_guidelines>\n</output_format>\n</system>`\n","/**\n * Default template for chat interactions.\n * Placeholders: {{CHAT_RULES}}, {{RULES}}, {{STYLE_EXAMPLES}}, {{ESSAY_CONTEXT}}\n */\nexport const DEFAULT_CHAT_TEMPLATE = `<system>\n<role>Helpful writing assistant for essay creation and editing</role>\n\n<chat_rules>\n{{CHAT_RULES}}\n</chat_rules>\n\n<writing_rules>\n{{RULES}}\n</writing_rules>\n\n<style_reference>\n{{STYLE_EXAMPLES}}\n</style_reference>\n\n<context>\n{{ESSAY_CONTEXT}}\n</context>\n\n<behavior>\n- Be concise and actionable\n- When suggesting edits, be specific about what to change\n- Match the author's voice and style when writing\n- Ask clarifying questions if the request is ambiguous\n</behavior>\n</system>`\n","/**\n * Default template for text rewriting.\n * Placeholders: {{REWRITE_RULES}}, {{RULES}}, {{STYLE_EXAMPLES}}\n */\nexport const DEFAULT_REWRITE_TEMPLATE = `<system>\n<role>Writing assistant that improves text quality</role>\n\n<rewrite_rules>\n{{REWRITE_RULES}}\n</rewrite_rules>\n\n<writing_rules>\n{{RULES}}\n</writing_rules>\n\n<style_reference>\n{{STYLE_EXAMPLES}}\n</style_reference>\n\n<behavior>\n- Preserve the original meaning exactly\n- Improve clarity, flow, and readability\n- Fix grammar and punctuation issues\n- Maintain the author's voice and tone\n- Output only the improved text, no explanations\n</behavior>\n</system>`\n","/**\n * Default template for auto-drafting from news articles.\n * Placeholders: {{AUTO_DRAFT_RULES}}, {{RULES}}, {{STYLE_EXAMPLES}}, {{TOPIC_NAME}}, {{ARTICLE_TITLE}}, {{ARTICLE_SUMMARY}}, {{ARTICLE_URL}}, {{AUTO_DRAFT_WORD_COUNT}}\n */\nexport const DEFAULT_AUTO_DRAFT_TEMPLATE = `<system>\n<role>Expert essay writer creating engaging content from news articles</role>\n\n<auto_draft_rules>\n{{AUTO_DRAFT_RULES}}\n</auto_draft_rules>\n\n<writing_rules>\n{{RULES}}\n</writing_rules>\n\n<style_reference>\n{{STYLE_EXAMPLES}}\n</style_reference>\n\n<source_article>\n<topic>{{TOPIC_NAME}}</topic>\n<title>{{ARTICLE_TITLE}}</title>\n<summary>{{ARTICLE_SUMMARY}}</summary>\n<url>{{ARTICLE_URL}}</url>\n</source_article>\n\n<constraints>\n<word_count>{{AUTO_DRAFT_WORD_COUNT}}</word_count>\n</constraints>\n\n<output_format>\nCRITICAL: Your response MUST start with exactly this format:\n\nLine 1: # [Your Title Here]\nLine 2: *[Your subtitle here]*\nLine 3: (blank line)\nLine 4+: Essay body in markdown\n\n<title_guidelines>\n- Be SPECIFIC about the news angle, not generic\n- Include a concrete detail or unexpected element\n- Create curiosity or make a bold claim\n- 5-12 words ideal\n</title_guidelines>\n\n<subtitle_guidelines>\n- One sentence that hooks the reader\n- Tease the main argument or unique perspective\n- Create tension, curiosity, or promise value\n</subtitle_guidelines>\n</output_format>\n</system>`\n","/**\n * Default template for essay outline generation.\n * Placeholders: {{PLAN_RULES}}, {{STYLE_EXAMPLES}}\n */\nexport const DEFAULT_PLAN_TEMPLATE = `<system>\n<role>Essay outline generator - you ONLY output plans, never conversation</role>\n\n<critical>\nYOU ARE A PLAN GENERATOR. Every response must be a complete essay outline.\n\nABSOLUTE RULES:\n1. ALWAYS output a plan wrapped in <plan> tags\n2. NEVER have conversational responses outside the plan\n3. If user asks a question â†’ answer by generating/revising a plan\n4. If user gives feedback â†’ output the revised plan\n5. If user gives a topic â†’ output a new plan for that topic\n6. Your ENTIRE response is ONLY the <plan>...</plan> block\n\nNO EXCEPTIONS. Every message you send is a plan.\n</critical>\n\n<rules>\n{{PLAN_RULES}}\n</rules>\n\n<style_reference>\n{{STYLE_EXAMPLES}}\n</style_reference>\n</system>`\n\n/**\n * Default rules for plan generation format.\n */\nexport const DEFAULT_PLAN_RULES = `<format>\nEXACT OUTPUT FORMAT - copy this structure precisely:\n\n<plan>\n# Essay Title\n*One-line subtitle*\n\n## Section Name\n- Key point\n\n## Section Name\n- Key point\n- Another point\n\n## Section Name\n- Key point\n</plan>\n</format>\n\n<syntax_requirements>\n- Title: \"# \" (hash + space) then title text\n- Subtitle: \"*\" + text + \"*\" (asterisks for italics)\n- Sections: \"## \" (double hash + space) then section name  \n- Points: \"- \" (dash + space) then point text\n</syntax_requirements>\n\n<constraints>\n- 4-6 section headings (## lines)\n- 1-3 bullets per section â€” NEVER 4 or more\n- Bullets are short phrases, not full sentences\n- NO prose, NO paragraphs, NO explanations outside the plan\n- When revising, output the COMPLETE updated plan\n- NEVER output anything outside the <plan> tags\n</constraints>\n\n<title_guidelines>\n- Be SPECIFIC about the essay's angle\n- Include a concrete detail or unexpected element\n- Avoid generic patterns like \"The Power of\", \"Why X Matters\"\n- 5-12 words ideal\n</title_guidelines>\n\n<subtitle_guidelines>\n- One sentence that previews the main argument\n- Create curiosity or make a bold claim\n</subtitle_guidelines>`\n","/**\n * Default template for agent mode (direct editing).\n * No placeholders - this is appended to chat prompt when in agent mode.\n */\nexport const DEFAULT_AGENT_TEMPLATE = `<agent_mode>\nCRITICAL: You are in AGENT MODE. You MUST make edits to the essay using edit commands.\n\nDO NOT respond conversationally. DO NOT just describe what you would do. DO NOT ask clarifying questions.\nYou MUST output :::edit blocks to make the requested changes.\n\nEDIT COMMANDS (wrap each in :::edit and ::: tags with valid JSON):\n\n1. Replace specific text:\n:::edit\n{\"type\": \"replace_section\", \"find\": \"exact text to find\", \"replace\": \"replacement text\"}\n:::\n\n2. Replace entire essay:\n:::edit\n{\"type\": \"replace_all\", \"title\": \"New Title\", \"subtitle\": \"New subtitle\", \"markdown\": \"Full essay content...\"}\n:::\n\n3. Insert text:\n:::edit\n{\"type\": \"insert\", \"position\": \"after\", \"find\": \"text to find\", \"replace\": \"text to insert\"}\n:::\n(position can be: \"before\", \"after\", \"start\", \"end\")\n\n4. Delete text:\n:::edit\n{\"type\": \"delete\", \"find\": \"text to delete\"}\n:::\n\nRULES:\n- ALWAYS output at least one :::edit block - this is REQUIRED in agent mode\n- Use EXACT text matches for \"find\" - copy precisely from the essay\n- One edit block per change, but you can include multiple edit blocks\n- Keep explanatory text minimal - focus on the edits\n- Edits are applied automatically when you output the :::edit blocks\n</agent_mode>`\n","/**\n * Default template for ask mode (conversational Q&A).\n * No placeholders - this is appended to chat prompt when in ask mode.\n */\nexport const DEFAULT_ASK_TEMPLATE = `<ask_mode>\nYou are in ASK MODE. You can write, discuss, and create content freely in your responses.\n\nThe ONLY restriction: you cannot push changes directly to the editor document.\n\nPROHIBITED (these modify the document):\n- :::edit blocks\n- JSON with \"type\": \"replace_all\", \"replace_section\", \"insert\", or \"delete\"\n\nALLOWED (do these freely):\n- Write full essays, articles, drafts in your response\n- Use markdown formatting (headers, bold, lists, etc.)\n- Answer questions, give feedback, brainstorm ideas\n- Create any content the user asks for\n\nWhen you write content in Ask mode, it stays in the chat. The user can copy it if they want.\nIf the user wants content inserted directly into their document, tell them to switch to Agent mode.\n</ask_mode>`\n","/**\n * Default template for expanding outlines into full essays.\n * Placeholders: {{RULES}}, {{STYLE_EXAMPLES}}, {{PLAN}}\n */\nexport const DEFAULT_EXPAND_PLAN_TEMPLATE = `<system>\n<role>Writing assistant that expands essay outlines into full drafts</role>\n\n<writing_rules>\n{{RULES}}\n</writing_rules>\n\n<style_reference>\n{{STYLE_EXAMPLES}}\n</style_reference>\n\n<plan_to_expand>\n{{PLAN}}\n</plan_to_expand>\n\n<output_format>\nCRITICAL: Your response MUST start with exactly this format:\n\nLine 1: # [Title from plan, refined if needed]\nLine 2: *[Subtitle from plan, refined if needed]*\nLine 3: (blank line)\nLine 4+: Essay body with ## section headings\n\n<requirements>\n- Use the section headers from the plan as H2 headings\n- Expand each section's bullet points into full paragraphs\n- Match the author's voice and style from the examples\n- Output ONLY markdown â€” no preamble, no \"Here is...\", no explanations\n</requirements>\n\n<title_refinement>\nIf the plan title is generic, improve it to be:\n- More specific and concrete\n- Curiosity-inducing or bold\n- 5-12 words\n</title_refinement>\n</output_format>\n</system>`\n","/**\n * Default template for search-only mode (fact-finding).\n * Used when user wants to research a topic before writing.\n */\nexport const DEFAULT_SEARCH_ONLY_PROMPT = `You are a research assistant helping a writer gather facts and information.\n\nYour task is to provide accurate, well-sourced information to help with essay writing.\n\nGuidelines:\n- Focus on facts, data, and specific examples\n- Include dates, names, and sources when relevant\n- Present information clearly and concisely\n- Note any conflicting information or debates\n- Suggest interesting angles or perspectives the writer might explore\n\nDo NOT write the essay - just provide research findings.`\n","/**\n * Prompt builder functions\n */\n\nimport type { EssayContext, StyleContext } from './types'\nimport { DEFAULT_GENERATE_TEMPLATE } from './templates/generate'\nimport { DEFAULT_CHAT_TEMPLATE } from './templates/chat'\nimport { DEFAULT_REWRITE_TEMPLATE } from './templates/rewrite'\nimport { DEFAULT_PLAN_TEMPLATE, DEFAULT_PLAN_RULES } from './templates/plan'\nimport { DEFAULT_AGENT_TEMPLATE } from './templates/agent'\nimport { DEFAULT_EXPAND_PLAN_TEMPLATE } from './templates/expand-plan'\nimport { DEFAULT_SEARCH_ONLY_PROMPT } from './templates/search'\n\n/**\n * Format essay context for inclusion in prompts.\n */\nfunction formatEssayContext(essayContext: EssayContext): string {\n  const parts: string[] = []\n  \n  if (essayContext.title) {\n    parts.push(`Title: ${essayContext.title}`)\n  }\n  if (essayContext.subtitle) {\n    parts.push(`Subtitle: ${essayContext.subtitle}`)\n  }\n  if (essayContext.markdown) {\n    parts.push(`Content:\\n${essayContext.markdown}`)\n  }\n  \n  return parts.join('\\n') || 'Empty essay'\n}\n\n/**\n * Build the search-only prompt for fact-finding queries.\n */\nexport function buildSearchOnlyPrompt(query: string): string {\n  return `${DEFAULT_SEARCH_ONLY_PROMPT}\n\nResearch Topic: ${query}`\n}\n\n/**\n * Build the full plan prompt with context and essay state.\n */\nexport function buildPlanPrompt(\n  context: StyleContext,\n  essayContext?: EssayContext | null\n): string {\n  let prompt = DEFAULT_PLAN_TEMPLATE\n    .replace('{{PLAN_RULES}}', context.planRules || DEFAULT_PLAN_RULES)\n    .replace('{{STYLE_EXAMPLES}}', context.styleExamples || 'No style examples provided.')\n\n  if (essayContext) {\n    const currentState = formatEssayContext(essayContext)\n    prompt += `\\n\\n<current_essay>\\n${currentState}\\n</current_essay>`\n  }\n\n  return prompt\n}\n\n/**\n * Build the chat prompt with essay context.\n */\nexport function buildChatPrompt(\n  context: StyleContext,\n  essayContext?: EssayContext | null\n): string {\n  let essayContextStr = 'No essay currently open.'\n  if (essayContext) {\n    essayContextStr = formatEssayContext(essayContext)\n  }\n\n  return DEFAULT_CHAT_TEMPLATE\n    .replace('{{CHAT_RULES}}', context.chatRules || 'Be helpful and concise.')\n    .replace('{{ESSAY_CONTEXT}}', essayContextStr)\n}\n\n/**\n * Build the agent chat prompt for direct editing mode.\n */\nexport function buildAgentChatPrompt(\n  context: StyleContext,\n  essayContext?: EssayContext | null\n): string {\n  const basePrompt = buildChatPrompt(context, essayContext)\n  return basePrompt + '\\n\\n' + DEFAULT_AGENT_TEMPLATE\n}\n\n/**\n * Build the generate prompt for essay creation.\n */\nexport function buildGeneratePrompt(\n  context: StyleContext,\n  wordCount: number = 800\n): string {\n  return DEFAULT_GENERATE_TEMPLATE\n    .replace('{{RULES}}', context.rules || '')\n    .replace('{{WORD_COUNT}}', wordCount.toString())\n}\n\n/**\n * Build the rewrite prompt.\n */\nexport function buildRewritePrompt(context: StyleContext): string {\n  return DEFAULT_REWRITE_TEMPLATE\n    .replace('{{REWRITE_RULES}}', context.rewriteRules || 'Improve clarity and flow.')\n}\n\n/**\n * Build the expand plan prompt.\n */\nexport function buildExpandPlanPrompt(\n  context: StyleContext,\n  plan: string\n): string {\n  return DEFAULT_EXPAND_PLAN_TEMPLATE\n    .replace('{{RULES}}', context.rules || '')\n    .replace('{{STYLE_EXAMPLES}}', context.styleExamples || 'No style examples provided.')\n    .replace('{{PLAN}}', plan)\n}\n","/**\n * AI Prompts - Templates and Builders\n * \n * This module provides prompt templates and builder functions for AI interactions.\n * Templates are organized by purpose (generate, chat, rewrite, etc.)\n * Builders combine templates with context to create complete prompts.\n */\n\n// Types\nexport * from './types'\n\n// Templates\nexport { DEFAULT_GENERATE_TEMPLATE } from './templates/generate'\nexport { DEFAULT_CHAT_TEMPLATE } from './templates/chat'\nexport { DEFAULT_REWRITE_TEMPLATE } from './templates/rewrite'\nexport { DEFAULT_AUTO_DRAFT_TEMPLATE } from './templates/auto-draft'\nexport { DEFAULT_PLAN_TEMPLATE, DEFAULT_PLAN_RULES } from './templates/plan'\nexport { DEFAULT_AGENT_TEMPLATE } from './templates/agent'\nexport { DEFAULT_ASK_TEMPLATE } from './templates/ask'\nexport { DEFAULT_EXPAND_PLAN_TEMPLATE } from './templates/expand-plan'\nexport { DEFAULT_SEARCH_ONLY_PROMPT } from './templates/search'\n\n// Builders\nexport {\n  buildSearchOnlyPrompt,\n  buildPlanPrompt,\n  buildChatPrompt,\n  buildAgentChatPrompt,\n  buildGeneratePrompt,\n  buildRewritePrompt,\n  buildExpandPlanPrompt,\n} from './builders'\n","/** Word count options for essay generation */\nexport const LENGTH_OPTIONS = [300, 500, 800, 1000] as const\nexport type LengthOption = (typeof LENGTH_OPTIONS)[number]\n\n/** Full model definition with provider details */\nexport interface AIModel {\n  id: string\n  name: string\n  provider: 'anthropic' | 'openai'\n  modelId: string\n  description?: string\n  searchModel: 'native' | null // 'native' for GPT (uses tools), null for Claude (uses 2-call flow)\n}\n\nexport const AI_MODELS: AIModel[] = [\n  {\n    id: 'claude-sonnet',\n    name: 'Sonnet 4.5',\n    provider: 'anthropic',\n    modelId: 'claude-sonnet-4-5-20250929',\n    description: 'Fast, capable, best value',\n    searchModel: null, // No native search, uses search-first flow\n  },\n  {\n    id: 'claude-opus',\n    name: 'Opus 4.5',\n    provider: 'anthropic',\n    modelId: 'claude-opus-4-5-20251101',\n    description: 'Highest quality, slower',\n    searchModel: null,\n  },\n  {\n    id: 'gpt-5.2',\n    name: 'GPT-5.2',\n    provider: 'openai',\n    modelId: 'gpt-5.2',\n    description: 'Latest OpenAI flagship',\n    searchModel: 'native', // Uses tools-based web search\n  },\n  {\n    id: 'gpt-5-mini',\n    name: 'GPT-5 Mini',\n    provider: 'openai',\n    modelId: 'gpt-5-mini',\n    description: 'Fast and cost-efficient',\n    searchModel: 'native', // Uses tools-based web search\n  },\n]\n\nexport type ModelId = (typeof AI_MODELS)[number]['id']\n\n/** Subset of AIModel for UI dropdowns */\nexport interface AIModelOption {\n  id: string\n  name: string\n  description?: string\n  hasNativeSearch: boolean\n}\n\nexport function getModel(id: string): AIModel | undefined {\n  return AI_MODELS.find(m => m.id === id)\n}\n\nexport function getDefaultModel(): AIModel {\n  return AI_MODELS[0]\n}\n\n/** Check if a model has native search (via tools, not a separate model) */\nexport function modelHasNativeSearch(id: string): boolean {\n  return AI_MODELS.find(m => m.id === id)?.searchModel === 'native'\n}\n\n/** Get the search model variant for a model, or null if it uses 2-call flow */\nexport function getSearchModel(id: string): string | null {\n  return AI_MODELS.find(m => m.id === id)?.searchModel ?? null\n}\n\n/**\n * Resolve a model ID, falling back to database default or hardcoded default.\n * Used by AI API routes to avoid duplicating model resolution logic.\n * \n * @param providedModelId - Optional model ID from request\n * @param getDefaultModelId - Async function to get default from DB (avoids Prisma import here)\n * @returns Resolved AIModel\n * @throws Error if model not found\n */\nexport async function resolveModel(\n  providedModelId: string | undefined,\n  getDefaultModelId: () => Promise<string | null>\n): Promise<AIModel> {\n  let modelId = providedModelId\n  \n  if (!modelId) {\n    modelId = (await getDefaultModelId()) || 'claude-sonnet'\n  }\n  \n  const model = getModel(modelId)\n  if (!model) {\n    throw new Error(`Unknown model: ${modelId}. Available: ${AI_MODELS.map(m => m.id).join(', ')}`)\n  }\n  \n  return model\n}\n\n/** Convert AIModel to AIModelOption for UI */\nexport function toModelOption(model: AIModel): AIModelOption {\n  return {\n    id: model.id,\n    name: model.name,\n    description: model.description,\n    hasNativeSearch: model.searchModel === 'native',\n  }\n}\n\n/** Get all models as options for UI dropdowns */\nexport function getModelOptions(): AIModelOption[] {\n  return AI_MODELS.map(toModelOption)\n}\n","import Anthropic from '@anthropic-ai/sdk'\nimport OpenAI from 'openai'\nimport { getModel } from './models'\n\n/** Message format for chat conversations */\nexport interface ChatMessage {\n  role: 'user' | 'assistant' | 'system'\n  content: string\n}\n\ninterface StreamOptions {\n  model: string\n  messages: ChatMessage[]\n  anthropicKey?: string\n  openaiKey?: string\n  maxTokens?: number\n  useThinking?: boolean\n  useWebSearch?: boolean\n}\n\ninterface GenerateResult {\n  text: string\n  inputTokens?: number\n  outputTokens?: number\n}\n\n/**\n * Get API key for a provider, checking DB first then falling back to env var.\n * Accepts a prisma client to avoid importing it directly.\n */\nexport async function getApiKey(\n  provider: 'anthropic' | 'openai',\n  prisma?: { aISettings?: { findUnique: (args: any) => Promise<any> } }\n): Promise<string | null> {\n  // Try AISettings DB first if prisma is provided\n  if (prisma?.aISettings) {\n    try {\n      const settings = await prisma.aISettings.findUnique({\n        where: { id: 'default' },\n      })\n      \n      if (provider === 'anthropic' && settings?.anthropicKey) {\n        return settings.anthropicKey\n      }\n      if (provider === 'openai' && settings?.openaiKey) {\n        return settings.openaiKey\n      }\n    } catch {\n      // DB lookup failed, fall back to env vars\n    }\n  }\n  \n  // Fall back to env vars\n  if (provider === 'anthropic') {\n    return process.env.ANTHROPIC_API_KEY || null\n  }\n  return process.env.OPENAI_API_KEY || null\n}\n\n/**\n * Fetch web search results using OpenAI's Responses API with web_search tool.\n * Returns a summary of search results to be used as context.\n */\nasync function fetchSearchResults(query: string, openaiKey?: string): Promise<string | null> {\n  // Create a timeout promise to prevent hanging\n  const timeoutMs = 30000 // 30 seconds\n  const timeoutPromise = new Promise<null>((_, reject) => {\n    setTimeout(() => reject(new Error('Search timeout after 30s')), timeoutMs)\n  })\n  \n  try {\n    console.log('[Web Search] Fetching search results for:', query.slice(0, 100))\n    \n    // Check if OpenAI key is available\n    const apiKey = openaiKey || process.env.OPENAI_API_KEY\n    if (!apiKey) {\n      console.warn('[Web Search] No OpenAI API key available for search')\n      return null\n    }\n    \n    const openai = new OpenAI({\n      apiKey,\n    })\n    \n    // Race between the search and timeout\n    const response = await Promise.race([\n      (openai as any).responses.create({\n        model: 'gpt-4o-mini',\n        input: `You are a research assistant. Provide a concise summary of the most relevant and recent information from the web about the following query. Include key facts, dates, and sources when available. Keep your response under 500 words.\\n\\nQuery: ${query}`,\n        tools: [{ type: 'web_search' }],\n      }),\n      timeoutPromise,\n    ])\n    \n    if (!response) {\n      console.warn('[Web Search] No response received')\n      return null\n    }\n    \n    const result = response.output_text || null\n    console.log('[Web Search] Got results:', result ? `${result.length} chars` : 'null')\n    return result\n  } catch (error) {\n    console.error('[Web Search] Failed:', error)\n    return null\n  }\n}\n\n/**\n * Extract the most recent user message to use as search query.\n */\nfunction extractSearchQuery(messages: ChatMessage[]): string {\n  const userMessages = messages.filter(m => m.role === 'user')\n  return userMessages[userMessages.length - 1]?.content || ''\n}\n\n/**\n * Generate text using the specified model (non-streaming).\n * Used for search mode and other non-streaming requests.\n */\nexport async function generate(\n  modelId: string,\n  systemPrompt: string,\n  userPrompt: string,\n  options: {\n    anthropicKey?: string\n    openaiKey?: string\n    maxTokens?: number\n    useWebSearch?: boolean\n  } = {}\n): Promise<GenerateResult> {\n  const model = getModel(modelId)\n  if (!model) {\n    throw new Error(`Unknown model: ${modelId}`)\n  }\n\n  if (model.provider === 'anthropic') {\n    return generateWithAnthropic(model.modelId, systemPrompt, userPrompt, options)\n  }\n  return generateWithOpenAI(model.modelId, systemPrompt, userPrompt, options)\n}\n\nasync function generateWithAnthropic(\n  modelId: string,\n  systemPrompt: string,\n  userPrompt: string,\n  options: { anthropicKey?: string; maxTokens?: number }\n): Promise<GenerateResult> {\n  const anthropic = new Anthropic({\n    ...(options.anthropicKey && { apiKey: options.anthropicKey }),\n  })\n\n  const response = await anthropic.messages.create({\n    model: modelId,\n    max_tokens: options.maxTokens || 4096,\n    system: systemPrompt,\n    messages: [{ role: 'user', content: userPrompt }],\n  })\n\n  const textContent = response.content.find(c => c.type === 'text')\n  if (!textContent || textContent.type !== 'text') {\n    throw new Error('No text content in response')\n  }\n\n  return {\n    text: textContent.text,\n    inputTokens: response.usage?.input_tokens,\n    outputTokens: response.usage?.output_tokens,\n  }\n}\n\nasync function generateWithOpenAI(\n  modelId: string,\n  systemPrompt: string,\n  userPrompt: string,\n  options: { openaiKey?: string; maxTokens?: number; useWebSearch?: boolean }\n): Promise<GenerateResult> {\n  const openai = new OpenAI({\n    ...(options.openaiKey && { apiKey: options.openaiKey }),\n  })\n\n  // Use Responses API for web search\n  if (options.useWebSearch) {\n    const response = await (openai as any).responses.create({\n      model: modelId,\n      instructions: systemPrompt,\n      input: userPrompt,\n      max_output_tokens: options.maxTokens || 4096,\n      tools: [{ type: 'web_search' }],\n    })\n\n    const textOutput = response.output?.find((item: { type: string }) => item.type === 'message')\n    const content = textOutput?.content?.find((c: { type: string }) => c.type === 'output_text')?.text\n\n    if (!content) {\n      throw new Error('No content in response')\n    }\n\n    return {\n      text: content,\n      inputTokens: response.usage?.input_tokens,\n      outputTokens: response.usage?.output_tokens,\n    }\n  }\n\n  // Standard chat completions\n  const response = await openai.chat.completions.create({\n    model: modelId,\n    max_completion_tokens: options.maxTokens || 4096,\n    messages: [\n      { role: 'system', content: systemPrompt },\n      { role: 'user', content: userPrompt },\n    ],\n  })\n\n  const content = response.choices[0]?.message?.content\n  if (!content) {\n    throw new Error('No content in response')\n  }\n\n  return {\n    text: content,\n    inputTokens: response.usage?.prompt_tokens,\n    outputTokens: response.usage?.completion_tokens,\n  }\n}\n\nexport async function createStream(options: StreamOptions): Promise<ReadableStream> {\n  const modelConfig = getModel(options.model)\n  if (!modelConfig) {\n    throw new Error(`Unknown model: ${options.model}`)\n  }\n\n  // For Anthropic with web search enabled, fetch search results first using OpenAI\n  let searchContext = ''\n  if (options.useWebSearch && modelConfig.provider === 'anthropic') {\n    const query = extractSearchQuery(options.messages)\n    if (query) {\n      try {\n        const searchResults = await fetchSearchResults(query, options.openaiKey)\n        if (searchResults) {\n          searchContext = `\\n\\n<web_search_results>\\n${searchResults}\\n</web_search_results>\\n\\nUse the search results above to inform your response with current, accurate information.`\n        } else {\n          // Search failed but don't block - add note for AI\n          searchContext = `\\n\\n<web_search_status>Web search was requested but returned no results. Answer based on your training knowledge and note any information that may be outdated.</web_search_status>`\n        }\n      } catch (err) {\n        console.error('[createStream] Search failed, continuing without:', err)\n        searchContext = `\\n\\n<web_search_status>Web search encountered an error. Answer based on your training knowledge.</web_search_status>`\n      }\n    }\n  }\n\n  if (modelConfig.provider === 'anthropic') {\n    return createAnthropicStream(options, modelConfig.modelId, searchContext)\n  } else {\n    return createOpenAIStream(options, modelConfig.modelId, options.useWebSearch)\n  }\n}\n\n/** Helper to safely enqueue data to controller */\nfunction safeEnqueue(controller: ReadableStreamDefaultController, data: Uint8Array): boolean {\n  try {\n    controller.enqueue(data)\n    return true\n  } catch {\n    // Controller already closed\n    return false\n  }\n}\n\n/** Helper to safely close controller */\nfunction safeClose(controller: ReadableStreamDefaultController): void {\n  try {\n    controller.close()\n  } catch {\n    // Controller already closed\n  }\n}\n\n/** Normalized event from any provider stream */\ninterface NormalizedEvent {\n  text?: string\n  thinking?: string\n}\n\n/**\n * Factory to create SSE ReadableStream from normalized provider events.\n * Eliminates duplicate stream creation logic across providers.\n */\nfunction createProviderStream(\n  events: AsyncIterable<NormalizedEvent>,\n  errorPrefix: string\n): ReadableStream {\n  const encoder = new TextEncoder()\n  \n  return new ReadableStream({\n    async start(controller) {\n      try {\n        for await (const event of events) {\n          if (event.text) {\n            if (!safeEnqueue(controller, encoder.encode(`data: ${JSON.stringify({ text: event.text })}\\n\\n`))) {\n              return\n            }\n          }\n          if (event.thinking) {\n            if (!safeEnqueue(controller, encoder.encode(`data: ${JSON.stringify({ thinking: event.thinking })}\\n\\n`))) {\n              return\n            }\n          }\n        }\n        safeEnqueue(controller, encoder.encode('data: [DONE]\\n\\n'))\n        safeClose(controller)\n      } catch (streamError) {\n        const errorMessage = streamError instanceof Error ? streamError.message : 'Stream error'\n        console.error(`[${errorPrefix}]`, streamError)\n        safeEnqueue(controller, encoder.encode(`data: ${JSON.stringify({ error: errorMessage })}\\n\\n`))\n        safeClose(controller)\n      }\n    },\n  })\n}\n\n/** Normalize Anthropic stream events */\nasync function* normalizeAnthropicEvents(stream: AsyncIterable<any>): AsyncGenerator<NormalizedEvent> {\n  for await (const event of stream) {\n    if (event.type === 'content_block_delta') {\n      const delta = event.delta as { type: string; text?: string; thinking?: string }\n      if (delta.type === 'text_delta' && delta.text) {\n        yield { text: delta.text }\n      } else if (delta.type === 'thinking_delta' && delta.thinking) {\n        yield { thinking: delta.thinking }\n      }\n    }\n  }\n}\n\n/** Normalize OpenAI chat completions stream events */\nasync function* normalizeOpenAIEvents(stream: AsyncIterable<any>): AsyncGenerator<NormalizedEvent> {\n  for await (const chunk of stream) {\n    const text = chunk.choices?.[0]?.delta?.content\n    if (text) {\n      yield { text }\n    }\n  }\n}\n\n/** Normalize OpenAI Responses API stream events */\nasync function* normalizeOpenAIResponsesEvents(stream: AsyncIterable<any>): AsyncGenerator<NormalizedEvent> {\n  for await (const event of stream) {\n    if (event.type === 'response.output_text.delta') {\n      const text = event.delta\n      if (text) {\n        yield { text }\n      }\n    }\n  }\n}\n\nasync function createAnthropicStream(options: StreamOptions, modelId: string, searchContext: string = ''): Promise<ReadableStream> {\n  const anthropic = new Anthropic({\n    ...(options.anthropicKey && { apiKey: options.anthropicKey }),\n  })\n\n  const systemMessage = (options.messages.find(m => m.role === 'system')?.content || '') + searchContext\n  const chatMessages = options.messages\n    .filter(m => m.role !== 'system')\n    .map(m => ({ role: m.role as 'user' | 'assistant', content: m.content }))\n\n  const requestParams: any = {\n    model: modelId,\n    max_tokens: options.maxTokens || 4096,\n    system: systemMessage,\n    messages: chatMessages,\n  }\n\n  if (options.useThinking && (modelId.includes('claude-sonnet') || modelId.includes('claude-opus'))) {\n    requestParams.thinking = {\n      type: 'enabled',\n      budget_tokens: 10000,\n    }\n    requestParams.max_tokens = Math.max(requestParams.max_tokens, 16000)\n  }\n\n  try {\n    const stream = await anthropic.messages.stream(requestParams)\n    return createProviderStream(normalizeAnthropicEvents(stream), 'Anthropic Stream Error')\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Anthropic API error'\n    console.error('[Anthropic API Error]', error)\n    throw new Error(errorMessage)\n  }\n}\n\nasync function createOpenAIStream(options: StreamOptions, modelId: string, useWebSearch: boolean = false): Promise<ReadableStream> {\n  const openai = new OpenAI({\n    ...(options.openaiKey && { apiKey: options.openaiKey }),\n  })\n\n  if (useWebSearch) {\n    return createOpenAIResponsesStream(openai, options, modelId)\n  }\n\n  const requestParams: any = {\n    model: modelId,\n    messages: options.messages,\n    max_completion_tokens: options.maxTokens || 4096,\n    stream: true,\n  }\n\n  try {\n    const stream = await openai.chat.completions.create(requestParams) as unknown as AsyncIterable<OpenAI.Chat.Completions.ChatCompletionChunk>\n    return createProviderStream(normalizeOpenAIEvents(stream), 'OpenAI Stream Error')\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'OpenAI API error'\n    console.error('[OpenAI API Error]', error)\n    throw new Error(errorMessage)\n  }\n}\n\nasync function createOpenAIResponsesStream(openai: OpenAI, options: StreamOptions, modelId: string): Promise<ReadableStream> {\n  const systemMessage = options.messages.find(m => m.role === 'system')?.content || ''\n  const conversationMessages = options.messages.filter(m => m.role !== 'system')\n  \n  const lastUserMessage = conversationMessages[conversationMessages.length - 1]?.content || ''\n  const conversationContext = conversationMessages.slice(0, -1)\n    .map(m => `${m.role === 'user' ? 'User' : 'Assistant'}: ${m.content}`)\n    .join('\\n\\n')\n  \n  const fullInput = conversationContext \n    ? `${systemMessage}\\n\\nPrevious conversation:\\n${conversationContext}\\n\\nUser: ${lastUserMessage}`\n    : `${systemMessage}\\n\\n${lastUserMessage}`\n\n  try {\n    const response = await (openai as any).responses.create({\n      model: modelId,\n      input: fullInput,\n      tools: [{ type: 'web_search' }],\n      stream: true,\n    })\n    return createProviderStream(normalizeOpenAIResponsesEvents(response), 'OpenAI Responses Stream Error')\n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'OpenAI Responses API error'\n    console.error('[OpenAI Responses API Error]', error)\n    throw new Error(errorMessage)\n  }\n}\n","import { \n  DEFAULT_GENERATE_TEMPLATE, \n  DEFAULT_CHAT_TEMPLATE, \n  DEFAULT_EXPAND_PLAN_TEMPLATE,\n  DEFAULT_PLAN_TEMPLATE,\n  DEFAULT_PLAN_RULES,\n  DEFAULT_REWRITE_TEMPLATE,\n  DEFAULT_AUTO_DRAFT_TEMPLATE,\n} from './prompts'\n\n/**\n * Build a system prompt for essay generation.\n */\nexport function buildGeneratePrompt(options: {\n  rules?: string\n  template?: string | null\n  wordCount?: number\n  styleExamples?: string\n}): string {\n  const template = options.template || DEFAULT_GENERATE_TEMPLATE\n  \n  return template\n    .replace('{{RULES}}', options.rules || '')\n    .replace('{{WORD_COUNT}}', String(options.wordCount || 800))\n    .replace('{{STYLE_EXAMPLES}}', options.styleExamples || '')\n}\n\n/**\n * Build a system prompt for chat interactions.\n */\nexport function buildChatPrompt(options: {\n  chatRules?: string\n  rules?: string\n  template?: string | null\n  essayContext?: { title: string; subtitle?: string; markdown: string } | null\n  styleExamples?: string\n}): string {\n  const template = options.template || DEFAULT_CHAT_TEMPLATE\n  \n  let essaySection = ''\n  if (options.essayContext) {\n    essaySection = `\nCurrent essay being edited:\nTitle: ${options.essayContext.title}\n${options.essayContext.subtitle ? `Subtitle: ${options.essayContext.subtitle}` : ''}\n\nContent:\n${options.essayContext.markdown}\n`\n  }\n  \n  return template\n    .replace('{{CHAT_RULES}}', options.chatRules || '')\n    .replace('{{RULES}}', options.rules || '')\n    .replace('{{ESSAY_CONTEXT}}', essaySection)\n    .replace('{{STYLE_EXAMPLES}}', options.styleExamples || '')\n}\n\n/**\n * Build a system prompt for expanding a plan into a full essay.\n */\nexport function buildExpandPlanPrompt(options: {\n  rules?: string\n  template?: string | null\n  plan: string\n  styleExamples?: string\n}): string {\n  const template = options.template || DEFAULT_EXPAND_PLAN_TEMPLATE\n  \n  return template\n    .replace('{{RULES}}', options.rules || '')\n    .replace('{{STYLE_EXAMPLES}}', options.styleExamples || '')\n    .replace('{{PLAN}}', options.plan)\n}\n\n/**\n * Build a system prompt for plan/outline generation.\n */\nexport function buildPlanPrompt(options: {\n  planRules?: string\n  template?: string | null\n  styleExamples?: string\n}): string {\n  const template = options.template || DEFAULT_PLAN_TEMPLATE\n  const rules = options.planRules || DEFAULT_PLAN_RULES\n  \n  return template\n    .replace('{{PLAN_RULES}}', rules)\n    .replace('{{STYLE_EXAMPLES}}', options.styleExamples || '')\n}\n\n/**\n * Build a system prompt for text rewriting.\n */\nexport function buildRewritePrompt(options: {\n  rewriteRules?: string\n  rules?: string\n  template?: string | null\n  styleExamples?: string\n}): string {\n  const template = options.template || DEFAULT_REWRITE_TEMPLATE\n  \n  return template\n    .replace('{{REWRITE_RULES}}', options.rewriteRules || '')\n    .replace('{{RULES}}', options.rules || '')\n    .replace('{{STYLE_EXAMPLES}}', options.styleExamples || '')\n}\n\n/**\n * Build a system prompt for auto-drafting essays from news articles.\n */\nexport function buildAutoDraftPrompt(options: {\n  autoDraftRules?: string\n  rules?: string\n  template?: string | null\n  wordCount?: number\n  styleExamples?: string\n  // Article context\n  topicName?: string\n  articleTitle?: string\n  articleSummary?: string\n  articleUrl?: string\n}): string {\n  const template = options.template || DEFAULT_AUTO_DRAFT_TEMPLATE\n  \n  return template\n    .replace('{{AUTO_DRAFT_RULES}}', options.autoDraftRules || '')\n    .replace('{{RULES}}', options.rules || '')\n    .replace('{{AUTO_DRAFT_WORD_COUNT}}', String(options.wordCount || 800))\n    .replace('{{STYLE_EXAMPLES}}', options.styleExamples || '')\n    .replace('{{TOPIC_NAME}}', options.topicName || '')\n    .replace('{{ARTICLE_TITLE}}', options.articleTitle || '')\n    .replace('{{ARTICLE_SUMMARY}}', options.articleSummary || '')\n    .replace('{{ARTICLE_URL}}', options.articleUrl || '')\n}\n","import type { Browser } from 'puppeteer-core'\n\n// Regex to match URLs in text - supports both with and without protocol\n// Matches: https://example.com, http://example.com, www.example.com, example.com/path\nconst URL_WITH_PROTOCOL = /https?:\\/\\/[^\\s<>\\[\\]()]+(?:\\([^\\s<>\\[\\]()]*\\))?[^\\s<>\\[\\]().,;:!?\"']*(?<![.,;:!?\"'])/gi\nconst URL_WITHOUT_PROTOCOL = /(?:www\\.)[a-zA-Z0-9][-a-zA-Z0-9]*(?:\\.[a-zA-Z]{2,})+(?:\\/[^\\s<>\\[\\]()]*)?/gi\nconst DOMAIN_ONLY = /(?<![/@])(?:[a-zA-Z0-9][-a-zA-Z0-9]*\\.)+(?:com|org|net|edu|gov|io|co|app|dev|news|info)(?:\\/[^\\s<>\\[\\]()]*)?(?![a-zA-Z])/gi\n\n// Puppeteer configuration\nconst PUPPETEER_TIMEOUT = 15000 // 15 seconds max for page load\nconst CONTENT_WAIT_TIME = 2000 // Wait 2s after load for JS to render\n\n/**\n * Detect if we're running in a serverless environment (Vercel, AWS Lambda, etc.)\n * In serverless, we use @sparticuz/chromium. Locally, we use regular puppeteer.\n */\nfunction isServerlessEnvironment(): boolean {\n  return !!(\n    process.env.AWS_LAMBDA_FUNCTION_NAME ||\n    process.env.VERCEL ||\n    process.env.NETLIFY ||\n    process.env.AWS_EXECUTION_ENV\n  )\n}\n\n/**\n * Extract URLs from text.\n * Supports URLs with protocol (https://), www prefix, or bare domains.\n */\nexport function extractUrls(text: string): string[] {\n  const urls: string[] = []\n  \n  // Match URLs with protocol first (highest priority)\n  const withProtocol = text.match(URL_WITH_PROTOCOL)\n  if (withProtocol) urls.push(...withProtocol)\n  \n  // Match www. URLs\n  const wwwUrls = text.match(URL_WITHOUT_PROTOCOL)\n  if (wwwUrls) {\n    for (const url of wwwUrls) {\n      // Add https:// prefix for consistency\n      const normalized = `https://${url}`\n      if (!urls.some(u => u.includes(url))) {\n        urls.push(normalized)\n      }\n    }\n  }\n  \n  // Match bare domain URLs (newsday.com, example.org, etc.)\n  const bareUrls = text.match(DOMAIN_ONLY)\n  if (bareUrls) {\n    for (const url of bareUrls) {\n      // Add https:// prefix for consistency\n      const normalized = `https://${url}`\n      if (!urls.some(u => u.includes(url.split('/')[0]))) {\n        urls.push(normalized)\n      }\n    }\n  }\n  \n  return [...new Set(urls)]\n}\n\nexport interface FetchedContent {\n  url: string\n  title?: string\n  content: string\n  error?: string\n}\n\n/**\n * Simple HTML text extraction without JSDOM.\n * Used as fallback when JSDOM fails (common with npm link).\n */\nfunction extractTextFromHtml(html: string, url: string): FetchedContent {\n  // Extract title\n  const titleMatch = html.match(/<title[^>]*>([^<]+)<\\/title>/i)\n  const title = titleMatch ? titleMatch[1].trim() : undefined\n\n  // Remove scripts, styles, and other non-content elements\n  let text = html\n    .replace(/<script[^>]*>[\\s\\S]*?<\\/script>/gi, '')\n    .replace(/<style[^>]*>[\\s\\S]*?<\\/style>/gi, '')\n    .replace(/<nav[^>]*>[\\s\\S]*?<\\/nav>/gi, '')\n    .replace(/<footer[^>]*>[\\s\\S]*?<\\/footer>/gi, '')\n    .replace(/<header[^>]*>[\\s\\S]*?<\\/header>/gi, '')\n    .replace(/<aside[^>]*>[\\s\\S]*?<\\/aside>/gi, '')\n    .replace(/<!--[\\s\\S]*?-->/g, '')\n    // Replace tags with appropriate spacing\n    .replace(/<(p|div|br|h[1-6]|li|tr)[^>]*>/gi, '\\n')\n    .replace(/<[^>]+>/g, ' ')\n    // Decode common HTML entities\n    .replace(/&nbsp;/g, ' ')\n    .replace(/&amp;/g, '&')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&quot;/g, '\"')\n    .replace(/&#39;/g, \"'\")\n    .replace(/&[a-z]+;/gi, ' ')\n    // Clean up whitespace\n    .replace(/\\s+/g, ' ')\n    .replace(/\\n\\s+/g, '\\n')\n    .replace(/\\n+/g, '\\n')\n    .trim()\n\n  // Limit content\n  if (text.length > 4000) {\n    text = text.slice(0, 4000) + '\\n\\n[Content truncated...]'\n  }\n\n  if (text.length < 50) {\n    return { url, content: '', error: 'Could not extract meaningful content' }\n  }\n\n  return { url, title, content: text }\n}\n\n/**\n * Parse HTML with Mozilla Readability.\n * Falls back to simple regex extraction if JSDOM fails.\n */\nasync function parseWithReadability(html: string, url: string): Promise<FetchedContent> {\n  try {\n    const { JSDOM } = await import('jsdom')\n    const { Readability } = await import('@mozilla/readability')\n\n    // CRITICAL: Do NOT load any external resources\n    // Explicitly set resources to undefined to prevent Next.js/npm link issues\n    const doc = new JSDOM(html, { \n      url,\n      resources: undefined,  // Don't load ANY external resources (stylesheets, etc.)\n      runScripts: undefined, // Don't run any scripts\n    })\n    const reader = new Readability(doc.window.document)\n    const article = reader.parse()\n\n    if (!article || !article.textContent) {\n      // Readability couldn't parse - try simple extraction\n      console.log('[Readability] No article content, falling back to simple extraction')\n      return extractTextFromHtml(html, url)\n    }\n\n    // Limit content to avoid token bloat (~4000 chars â‰ˆ 1000 tokens)\n    let content = article.textContent.trim()\n    if (content.length > 4000) {\n      content = content.slice(0, 4000) + '\\n\\n[Content truncated...]'\n    }\n\n    return {\n      url,\n      title: article.title || undefined,\n      content,\n    }\n  } catch (error) {\n    // JSDOM failed (common with npm link due to native module issues)\n    console.error('[JSDOM] Failed, using simple extraction:', error instanceof Error ? error.message : error)\n    return extractTextFromHtml(html, url)\n  }\n}\n\n/**\n * Fetch URL content using Puppeteer (headless browser).\n * This handles JavaScript-rendered pages and some paywalls.\n * \n * Environment detection:\n * - Local development: Uses regular `puppeteer` (auto-downloads Chrome)\n * - Serverless (Vercel/Lambda): Uses `@sparticuz/chromium` + `puppeteer-core`\n */\nasync function fetchWithPuppeteer(url: string): Promise<FetchedContent> {\n  let browser: Browser | null = null\n  const isServerless = isServerlessEnvironment()\n  \n  try {\n    console.log(`[Puppeteer] Launching browser for: ${url} (serverless: ${isServerless})`)\n    \n    if (isServerless) {\n      // Serverless environment: use @sparticuz/chromium\n      const chromium = await import('@sparticuz/chromium')\n      const puppeteerCore = await import('puppeteer-core')\n      \n      const executablePath = await chromium.default.executablePath()\n      \n      browser = await puppeteerCore.default.launch({\n        args: chromium.default.args,\n        defaultViewport: chromium.default.defaultViewport,\n        executablePath,\n        headless: chromium.default.headless,\n      })\n    } else {\n      // Local development: use regular puppeteer (has its own Chrome)\n      try {\n        const puppeteer = await import('puppeteer')\n        \n        browser = await puppeteer.default.launch({\n          headless: true,\n          args: [\n            '--no-sandbox',\n            '--disable-setuid-sandbox',\n            '--disable-dev-shm-usage',\n            '--disable-accelerated-2d-canvas',\n            '--disable-gpu',\n          ],\n        })\n      } catch (puppeteerImportError) {\n        // Puppeteer import/launch failed - this can happen with npm link or missing Chrome\n        console.error('[Puppeteer] Import/launch failed:', puppeteerImportError)\n        return { url, content: '', error: 'Puppeteer unavailable - falling back to simple fetch' }\n      }\n    }\n    \n    const page = await browser.newPage()\n    \n    // Set viewport and user agent\n    await page.setViewport({ width: 1920, height: 1080 })\n    await page.setUserAgent(\n      'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'\n    )\n    \n    // Block unnecessary resources to speed up loading\n    await page.setRequestInterception(true)\n    page.on('request', (req) => {\n      const resourceType = req.resourceType()\n      if (['image', 'stylesheet', 'font', 'media'].includes(resourceType)) {\n        req.abort()\n      } else {\n        req.continue()\n      }\n    })\n    \n    // Navigate with timeout\n    await page.goto(url, {\n      waitUntil: 'networkidle2',\n      timeout: PUPPETEER_TIMEOUT,\n    })\n    \n    // Wait a bit for any remaining JS to execute\n    await new Promise(resolve => setTimeout(resolve, CONTENT_WAIT_TIME))\n    \n    // Get the rendered HTML\n    const html = await page.content()\n    \n    // Close browser before parsing to free resources\n    await browser.close()\n    browser = null\n    \n    console.log('[Puppeteer] Got HTML, parsing with Readability...')\n    \n    // Parse with Readability\n    return await parseWithReadability(html, url)\n    \n  } catch (error) {\n    const errorMessage = error instanceof Error ? error.message : 'Puppeteer error'\n    console.error('[Puppeteer] Failed:', errorMessage)\n    return { url, content: '', error: `Puppeteer: ${errorMessage}` }\n  } finally {\n    // Ensure browser is closed even on error\n    if (browser) {\n      try {\n        await browser.close()\n      } catch {\n        // Ignore close errors\n      }\n    }\n  }\n}\n\n/**\n * Fetch URL content using simple HTTP request + Mozilla Readability.\n * This is the fallback method when Puppeteer fails or isn't available.\n */\nasync function fetchWithSimpleRequest(url: string): Promise<FetchedContent> {\n  try {\n    console.log('[SimpleFetch] Fetching:', url)\n    \n    const res = await fetch(url, {\n      headers: {\n        'User-Agent':\n          'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n        Accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n        'Accept-Language': 'en-US,en;q=0.9',\n      },\n    })\n\n    if (!res.ok) {\n      return { url, content: '', error: `HTTP ${res.status}` }\n    }\n\n    const html = await res.text()\n    return parseWithReadability(html, url)\n  } catch (error) {\n    return {\n      url,\n      content: '',\n      error: error instanceof Error ? error.message : 'Failed to fetch',\n    }\n  }\n}\n\n/**\n * Fetch URL content - tries Puppeteer first for JavaScript-rendered pages,\n * falls back to simple HTTP request if Puppeteer fails.\n */\nexport async function fetchUrlContent(url: string): Promise<FetchedContent> {\n  console.log('[URL Extractor] Fetching content from:', url)\n  \n  // Try Puppeteer first (better for JS-rendered and paywalled sites)\n  const puppeteerResult = await fetchWithPuppeteer(url)\n  \n  // Check if Puppeteer succeeded with actual content\n  if (!puppeteerResult.error && puppeteerResult.content && puppeteerResult.content.length > 100) {\n    console.log('[URL Extractor] Puppeteer succeeded, got', puppeteerResult.content.length, 'chars')\n    return puppeteerResult\n  }\n  \n  // Puppeteer failed or got minimal content - try simple fetch as fallback\n  console.log('[URL Extractor] Puppeteer failed or got minimal content, trying simple fetch...')\n  const simpleResult = await fetchWithSimpleRequest(url)\n  \n  // Return whichever got more content\n  if (simpleResult.content && simpleResult.content.length > (puppeteerResult.content?.length || 0)) {\n    console.log('[URL Extractor] Simple fetch got more content:', simpleResult.content.length, 'chars')\n    return simpleResult\n  }\n  \n  // Return Puppeteer result (even if it failed, it has better error info)\n  if (puppeteerResult.content && puppeteerResult.content.length > 0) {\n    return puppeteerResult\n  }\n  \n  // Both failed - return the simple fetch error (usually more informative)\n  return simpleResult.error ? simpleResult : puppeteerResult\n}\n\n/**\n * Extract URLs from text and fetch their content.\n * Returns fetched content for all URLs found.\n */\nexport async function extractAndFetchUrls(text: string): Promise<FetchedContent[]> {\n  const urls = extractUrls(text)\n  if (urls.length === 0) return []\n\n  // Limit to 3 URLs to avoid abuse and long waits\n  const toFetch = urls.slice(0, 3)\n\n  // Fetch in parallel for speed\n  const results = await Promise.all(toFetch.map(url => fetchUrlContent(url)))\n\n  return results\n}\n\n/**\n * Build context string from fetched URLs for AI prompts.\n */\nexport function buildUrlContext(fetched: FetchedContent[]): string {\n  const successful = fetched.filter((f) => !f.error && f.content)\n  if (successful.length === 0) return ''\n\n  return `\n<referenced_urls>\n${successful\n  .map(\n    (f) =>\n      `<url src=\"${f.url}\"${f.title ? ` title=\"${f.title}\"` : ''}>\n${f.content}\n</url>`\n  )\n  .join('\\n\\n')}\n</referenced_urls>\n\nUse the content from these URLs when relevant to the conversation.`\n}\n","import { createStream } from './provider'\nimport { buildGeneratePrompt, buildExpandPlanPrompt } from './builders'\nimport { extractAndFetchUrls } from '../lib/url-extractor'\n\ninterface GenerateOptions {\n  prompt: string\n  model: string\n  wordCount?: number\n  rules?: string\n  template?: string | null\n  styleExamples?: string\n  anthropicKey?: string\n  openaiKey?: string\n  useWebSearch?: boolean  // Controls ALL internet access: URL extraction AND web search\n  useThinking?: boolean\n}\n\nexport async function generateStream(options: GenerateOptions): Promise<ReadableStream> {\n  const systemPrompt = buildGeneratePrompt({\n    rules: options.rules,\n    template: options.template,\n    wordCount: options.wordCount,\n    styleExamples: options.styleExamples,\n  })\n\n  // Extract and fetch URL content when web access is enabled\n  let enrichedPrompt = options.prompt\n  if (options.useWebSearch) {\n    try {\n      const fetched = await extractAndFetchUrls(options.prompt)\n      const successful = fetched.filter((f) => !f.error && f.content)\n      if (successful.length > 0) {\n        enrichedPrompt = `${options.prompt}\n\n<source_material>\n${successful\n  .map(\n    (f) =>\n      `Source: ${f.url}${f.title ? ` (${f.title})` : ''}\n${f.content}`\n  )\n  .join('\\n\\n---\\n\\n')}\n</source_material>\n\nUse the source material above as reference for the essay.`\n      }\n    } catch (err) {\n      console.warn('URL extraction failed:', err)\n    }\n  }\n\n  return createStream({\n    model: options.model,\n    messages: [\n      { role: 'system', content: systemPrompt },\n      { role: 'user', content: enrichedPrompt },\n    ],\n    anthropicKey: options.anthropicKey,\n    openaiKey: options.openaiKey,\n    maxTokens: options.useThinking ? 16000 : 8192,\n    useWebSearch: options.useWebSearch,\n    useThinking: options.useThinking,\n  })\n}\n\ninterface ExpandPlanOptions {\n  plan: string\n  model: string\n  rules?: string\n  template?: string | null\n  styleExamples?: string\n  anthropicKey?: string\n  openaiKey?: string\n}\n\nexport async function expandPlanStream(options: ExpandPlanOptions): Promise<ReadableStream> {\n  const systemPrompt = buildExpandPlanPrompt({\n    rules: options.rules,\n    template: options.template,\n    plan: options.plan,\n    styleExamples: options.styleExamples,\n  })\n\n  return createStream({\n    model: options.model,\n    messages: [\n      { role: 'system', content: systemPrompt },\n      { role: 'user', content: 'Write the essay now.' },\n    ],\n    anthropicKey: options.anthropicKey,\n    openaiKey: options.openaiKey,\n    maxTokens: 8192,\n  })\n}\n","import { createStream } from './provider'\nimport { buildChatPrompt, buildPlanPrompt } from './builders'\nimport { extractAndFetchUrls, buildUrlContext } from '../lib/url-extractor'\nimport { DEFAULT_AGENT_TEMPLATE, DEFAULT_ASK_TEMPLATE } from './prompts'\n\ninterface ChatMessage {\n  role: 'user' | 'assistant'\n  content: string\n}\n\ninterface ChatOptions {\n  messages: ChatMessage[]\n  model: string\n  essayContext?: { title: string; subtitle?: string; markdown: string } | null\n  mode?: 'ask' | 'agent' | 'search' | 'plan'\n  chatRules?: string\n  rules?: string\n  template?: string | null\n  // Plan mode specific\n  planTemplate?: string | null\n  planRules?: string\n  // Agent mode specific\n  agentTemplate?: string | null\n  styleExamples?: string\n  anthropicKey?: string\n  openaiKey?: string\n  useWebSearch?: boolean  // Controls ALL internet access: URL extraction AND web search\n  useThinking?: boolean\n}\n\nexport async function chatStream(options: ChatOptions): Promise<ReadableStream> {\n  // Use different prompt builder for plan mode\n  const systemPrompt = options.mode === 'plan'\n    ? buildPlanPrompt({\n        planRules: options.planRules,\n        template: options.planTemplate,\n        styleExamples: options.styleExamples,\n      })\n    : buildChatPrompt({\n        chatRules: options.chatRules,\n        rules: options.rules,\n        template: options.template,\n        essayContext: options.essayContext,\n        styleExamples: options.styleExamples,\n      })\n\n  // Extract URLs from the last user message when web access is enabled\n  // The web toggle controls ALL internet access: URL extraction AND web search\n  let urlContext = ''\n  let urlExtractionStatus = ''\n  if (options.useWebSearch) {\n    const lastUserMsg = [...options.messages].reverse().find((m) => m.role === 'user')\n    if (lastUserMsg) {\n      try {\n        const { extractUrls } = await import('../lib/url-extractor')\n        const detectedUrls = extractUrls(lastUserMsg.content)\n        \n        if (detectedUrls.length > 0) {\n          console.log('[URL Extraction] Detected URLs:', detectedUrls)\n          const fetched = await extractAndFetchUrls(lastUserMsg.content)\n          \n          if (fetched.length > 0) {\n            const successful = fetched.filter(f => !f.error && f.content)\n            const failed = fetched.filter(f => f.error || !f.content)\n            \n            if (successful.length > 0) {\n              urlContext = buildUrlContext(fetched)\n              console.log('[URL Extraction] Successfully fetched:', successful.map(f => f.url))\n            }\n            \n            if (failed.length > 0) {\n              console.warn('[URL Extraction] Failed to fetch:', failed.map(f => ({ url: f.url, error: f.error })))\n              urlExtractionStatus = `\\n\\n<url_extraction_status>\nAttempted to fetch ${detectedUrls.length} URL(s). ${successful.length} succeeded, ${failed.length} failed.\n${failed.map(f => `- ${f.url}: ${f.error || 'Empty content'}`).join('\\n')}\n</url_extraction_status>`\n            }\n          }\n        }\n      } catch (err) {\n        console.error('[URL Extraction] Error:', err)\n        urlExtractionStatus = `\\n\\n<url_extraction_status>\nURL extraction encountered an error: ${err instanceof Error ? err.message : 'Unknown error'}\n</url_extraction_status>`\n      }\n    }\n  }\n\n  // Add mode-specific instructions\n  let modeInstructions = ''\n  if (options.mode === 'agent') {\n    // Use custom agent template if set, otherwise use default\n    modeInstructions = '\\n\\n' + (options.agentTemplate || DEFAULT_AGENT_TEMPLATE)\n  } else if (options.mode === 'ask' || !options.mode) {\n    // Ask mode: conversational only, no edit commands\n    modeInstructions = '\\n\\n' + DEFAULT_ASK_TEMPLATE\n  }\n\n  // Add web search context if enabled\n  let webSearchContext = ''\n  if (options.useWebSearch) {\n    // Web search is enabled - OpenAI models use native search, Anthropic models get search results via OpenAI proxy\n    webSearchContext = `\n\n<search_capability>\nWeb search is ENABLED for this conversation. You have access to current, real-time information from the web.\n- For questions about recent events, news, or current information: search results will be provided automatically\n- Cite sources when referencing specific facts from search results\n- If search results are included in <web_search_results> tags, use that information to provide accurate, up-to-date answers\n</search_capability>`\n  }\n\n  // Add thinking mode instructions if enabled\n  let thinkingInstructions = ''\n  if (options.useThinking) {\n    thinkingInstructions = '\\n\\nTake time to think through complex questions step by step. Consider multiple angles before providing your final answer.'\n  }\n\n  // Add URL capability instructions when web access is enabled\n  // These instructions are CRITICAL - they override the AI's default belief that it cannot access URLs\n  let urlCapabilityInstructions = ''\n  if (options.useWebSearch) {\n    const hasUrlContent = urlContext.length > 0\n    const hasFailedUrls = urlExtractionStatus.length > 0\n    \n    urlCapabilityInstructions = `\n\n<CRITICAL_CAPABILITY>\n**IMPORTANT: URL READING IS ENABLED**\n\nYou have a WORKING URL reader in this application. This overrides your default training.\n- DO NOT say \"I cannot access URLs\" or \"I cannot browse the web\" - you CAN and DO have this capability\n- When users share URLs, the content is AUTOMATICALLY FETCHED by the system\n- Look for <referenced_urls> tags below - that contains the fetched page content\n- ${hasUrlContent ? 'URL CONTENT WAS SUCCESSFULLY FETCHED - see <referenced_urls> below' : hasFailedUrls ? 'URL fetch was ATTEMPTED but FAILED - see <url_extraction_status> below for details' : 'No URLs detected in the current message'}\n\nIf you see fetched content, use it to answer the user's question. Quote specific passages when relevant.\nIf the fetch failed, explain what happened using the error details provided.\n</CRITICAL_CAPABILITY>`\n  }\n\n  // Filter out messages with empty content (can happen from partial streams or errors)\n  // AI APIs reject messages with empty content\n  const filteredMessages = options.messages.filter(m => m.content && m.content.trim().length > 0)\n\n  return createStream({\n    model: options.model,\n    messages: [\n      { role: 'system', content: systemPrompt + modeInstructions + webSearchContext + thinkingInstructions + urlCapabilityInstructions + urlContext + urlExtractionStatus },\n      ...filteredMessages,\n    ],\n    anthropicKey: options.anthropicKey,\n    openaiKey: options.openaiKey,\n    maxTokens: options.useThinking ? 16000 : 4096, // Allow more tokens for thinking mode\n    useThinking: options.useThinking,\n    useWebSearch: options.useWebSearch,\n  })\n}\n","// Server-safe exports (no React imports)\nexport { createAutoblogger } from './server'\nexport { createAPIHandler } from './api'\nexport { validateSchema } from './schema'\n\n// Data layer factory\nexport { createCrudData } from './data/factory'\nexport type { CrudOptions, BaseCrud } from './data/factory'\n\n// Data access types\nexport type { Post, Revision, Comment, Tag, PostTag, AISettings, TopicSubscription, NewsItem } from './types'\n\n// AI exports\nexport {\n  AI_MODELS,\n  getModel,\n  getDefaultModel,\n  buildGeneratePrompt,\n  buildChatPrompt,\n  buildExpandPlanPrompt,\n  buildPlanPrompt,\n  buildRewritePrompt,\n  buildAutoDraftPrompt,\n  DEFAULT_GENERATE_TEMPLATE,\n  DEFAULT_CHAT_TEMPLATE,\n  DEFAULT_REWRITE_TEMPLATE,\n  DEFAULT_AUTO_DRAFT_TEMPLATE,\n  DEFAULT_PLAN_TEMPLATE,\n  DEFAULT_PLAN_RULES,\n  DEFAULT_EXPAND_PLAN_TEMPLATE,\n  parseGeneratedContent,\n  generate,\n  resolveModel,\n} from './ai'\nexport type { AIModel } from './ai'\n\n// Utilities\nexport { renderMarkdown, parseMarkdown, htmlToMarkdown, markdownToHtml, wordCount, generateSlug, renderMarkdownSanitized } from './lib/markdown'\nexport { getSeoValues } from './lib/seo'\nexport { formatDate, truncate } from './lib/format'\n\n// Storage (file uploads)\nexport { createStorageHandler, uploadFile, detectStorageConfig } from './lib/storage'\nexport type { StorageConfig, UploadResult } from './lib/storage'\n\n// Auto-draft\nexport { runAutoDraft, fetchRssFeeds, filterByKeywords } from './auto-draft'\nexport type { RssArticle, GenerationResult, AutoDraftConfig } from './auto-draft'\n\n// Comment utilities (for advanced integrations)\nexport { createCommentsClient, canEditComment, canDeleteComment } from './lib/comments'\nexport type { CommentWithUser, CreateCommentData, SelectionState } from './lib/comments'\nexport { CommentMark, addCommentMark, removeCommentMark, applyCommentMarks, scrollToComment } from './lib/comment-mark'\n\n// Destination adapters\nexport { createDestinationDispatcher } from './destinations'\nexport type { DestinationDispatcher, DispatcherConfig } from './destinations'\nexport type { \n  Destination, \n  DestinationResult, \n  DestinationEvent, \n  DestinationsConfig,\n  DispatchResult,\n} from './types/destinations'\n\n// Types (server-safe only)\nexport type { \n  AutobloggerServerConfig as AutobloggerConfig, \n  StylesConfig,\n  AutobloggerServer as Autoblogger,\n  Session,\n} from './server'\n\n// UI-related types (client-side, contains React types)\nexport type { CustomFieldProps, CustomFieldConfig } from './config'\n","// Database model types - placeholder interfaces for Prisma models\n// Actual types come from user's Prisma client\n\n// ============================================================================\n// Post Status Constants\n// ============================================================================\n\nexport const PostStatus = {\n  DRAFT: 'draft',\n  PUBLISHED: 'published',\n  DELETED: 'deleted',\n  SUGGESTED: 'suggested',\n} as const\n\nexport type PostStatusType = typeof PostStatus[keyof typeof PostStatus]\n\n// ============================================================================\n// Database Models\n// ============================================================================\n\nexport interface Post {\n  id: string\n  title: string\n  subtitle?: string | null\n  slug: string\n  markdown: string\n  status: string\n  createdAt: Date\n  updatedAt: Date\n  publishedAt?: Date | null\n  seoTitle?: string | null\n  seoDescription?: string | null\n  seoKeywords?: string | null\n  noIndex: boolean\n  ogImage?: string | null\n  previewToken?: string | null\n  previewExpiry?: Date | null\n  sourceUrl?: string | null\n  topicId?: string | null\n  // Custom fields added by user\n  [key: string]: unknown\n}\n\nexport interface Revision {\n  id: string\n  postId: string\n  title?: string | null\n  subtitle?: string | null\n  markdown: string\n  createdAt: Date\n}\n\nexport interface Comment {\n  id: string\n  postId: string\n  authorId?: string | null\n  authorName?: string | null\n  authorEmail?: string | null\n  content: string\n  approved: boolean\n  createdAt: Date\n}\n\nexport interface Tag {\n  id: string\n  name: string\n  createdAt: Date\n}\n\nexport interface PostTag {\n  id: string\n  postId: string\n  tagId: string\n  createdAt: Date\n}\n\nexport interface AISettings {\n  id: string\n  rules: string\n  chatRules: string\n  rewriteRules?: string | null\n  defaultModel: string\n  generateTemplate?: string | null\n  chatTemplate?: string | null\n  rewriteTemplate?: string | null\n  updatedAt: Date\n}\n\nexport interface TopicSubscription {\n  id: string\n  name: string\n  keywords: string\n  rssFeeds: string\n  isActive: boolean\n  useKeywordFilter: boolean\n  frequency: string\n  maxPerPeriod: number\n  essayFocus?: string | null\n  lastRunAt?: Date | null\n  createdAt: Date\n  updatedAt: Date\n}\n\nexport interface NewsItem {\n  id: string\n  topicId: string\n  url: string\n  title: string\n  summary?: string | null\n  publishedAt?: Date | null\n  status: string\n  postId?: string | null\n  createdAt: Date\n}\n","import type { Post } from '../types/models'\nimport type { Destination, DestinationResult } from '../types/destinations'\n\n/**\n * Configuration for the Prismic destination adapter.\n */\nexport interface PrismicDestinationConfig {\n  /** Prismic repository name (e.g., 'my-repo') */\n  repository: string\n  /** Prismic write API token (from Settings > API & Security) */\n  writeToken: string\n  /** Prismic document type to create (e.g., 'autoblog') */\n  documentType: string\n  /** \n   * Sync mode: \n   * - 'stub': Syncs minimal reference data only (uid)\n   * - 'full': Syncs all content including markdown body as rich text\n   */\n  syncMode?: 'stub' | 'full'\n  /** Master locale for the repository (default: 'en-us') */\n  masterLocale?: string\n  /** Custom document ID resolver (optional, uses post.id by default) */\n  getDocumentId?: (post: Post) => string\n  /** \n   * Whether to auto-update the Prismic document display name from the post title.\n   * Default: false. When true, the document name in Prismic will be updated on publish.\n   */\n  autoRename?: boolean\n}\n\n/**\n * Map an autoblogger post to a minimal stub document.\n * Used in 'stub' sync mode where content lives in autoblogger,\n * and Prismic only stores references for collection slices.\n */\nfunction mapPostToStub(_post: Post): Record<string, unknown> {\n  // Empty data - only the UID matters, and it's set separately\n  return {}\n}\n\n/**\n * Create a Prismic destination adapter for autoblogger.\n * \n * This is an internal implementation used by the dynamic destination system.\n * For external use, import from '@autoblogger/prismic' package.\n */\nexport function createPrismicDestination(config: PrismicDestinationConfig): Destination {\n  const masterLocale = config.masterLocale || 'en-us'\n  const syncMode = config.syncMode || 'stub'\n  const getDocumentId = config.getDocumentId || ((post: Post) => `autoblogger-${post.id}`)\n\n  return {\n    name: `prismic:${config.repository}`,\n\n    async onPublish(post: Post): Promise<DestinationResult> {\n      try {\n        // Dynamic import to avoid requiring @prismicio/client as a dependency\n        const prismic = await import('@prismicio/client')\n        \n        const writeClient = prismic.createWriteClient(config.repository, {\n          writeToken: config.writeToken,\n        })\n        const readClient = prismic.createClient(config.repository)\n        const migration = prismic.createMigration()\n\n        const documentId = getDocumentId(post)\n        \n        // Use stub document data (minimal reference)\n        const documentData = mapPostToStub(post)\n\n        // Check for existing document by UID\n        let existingDoc: any = null\n        try {\n          existingDoc = await readClient.getByUID(config.documentType, post.slug, {\n            lang: masterLocale,\n          })\n        } catch {\n          // Document doesn't exist - will create new\n        }\n\n        if (existingDoc) {\n          // Update existing document\n          const updatedDoc = {\n            ...existingDoc,\n            uid: post.slug,\n            data: { ...existingDoc.data, ...documentData },\n          }\n          \n          // Only update document name if autoRename is enabled\n          if (config.autoRename) {\n            migration.updateDocument(updatedDoc as any, post.title)\n            console.log(`[prismic:${config.repository}] Updating document with new title for post \"${post.slug}\"`)\n          } else {\n            migration.updateDocument(updatedDoc as any)\n            console.log(`[prismic:${config.repository}] Updating existing document for post \"${post.slug}\"`)\n          }\n        } else {\n          // Create new document - ALWAYS use post.title as the document name\n          migration.createDocument(\n            {\n              type: config.documentType,\n              uid: post.slug,\n              lang: masterLocale,\n              data: documentData,\n            } as any,\n            post.title\n          )\n          console.log(`[prismic:${config.repository}] Creating new document for post \"${post.slug}\"`)\n        }\n\n        // Execute the migration\n        await writeClient.migrate(migration, {\n          reporter: () => {}, // Silent reporter\n        })\n\n        console.log(`[prismic:${config.repository}] Synced stub for post \"${post.slug}\"`)\n\n        return {\n          success: true,\n          externalId: documentId,\n        }\n      } catch (error) {\n        console.error(`[prismic:${config.repository}] Failed to sync post \"${post.slug}\":`, error)\n        return {\n          success: false,\n          error: error instanceof Error ? error.message : 'Unknown error publishing to Prismic',\n        }\n      }\n    },\n\n    async onUnpublish(post: Post): Promise<DestinationResult> {\n      // Prismic Migration API doesn't support unpublishing directly\n      // The document will remain but won't be updated\n      console.warn(\n        `[prismic:${config.repository}] Unpublish not fully supported via Migration API. ` +\n        `Document for post \"${post.slug}\" will remain in Prismic.`\n      )\n      \n      return {\n        success: true,\n        externalId: getDocumentId(post),\n      }\n    },\n\n    async onDelete(post: Post): Promise<DestinationResult> {\n      // Prismic Migration API doesn't support deletion directly\n      console.warn(\n        `[prismic:${config.repository}] Delete not fully supported via Migration API. ` +\n        `Document for post \"${post.slug}\" will remain in Prismic.`\n      )\n      \n      return {\n        success: true,\n        externalId: getDocumentId(post),\n      }\n    },\n  }\n}\n","import type { Post } from '../types'\nimport { PostStatus } from '../types/models'\nimport type { DestinationDispatcher } from '../destinations'\nimport { createPrismicDestination } from '../destinations/prismic'\n\ninterface PostHooks {\n  beforePublish?: (post: Post) => Promise<void>\n  afterSave?: (post: Post) => Promise<void>\n  /** Called when a slug changes on a post that was previously published. Used to create redirects. */\n  onSlugChange?: (data: { postId: string; oldSlug: string; newSlug: string }) => Promise<void>\n}\n\ninterface CreatePostInput {\n  title: string\n  subtitle?: string\n  slug?: string\n  markdown?: string\n  status?: string\n  [key: string]: unknown\n}\n\ninterface UpdatePostInput {\n  title?: string\n  subtitle?: string\n  slug?: string\n  markdown?: string\n  status?: string\n  publishedAt?: Date\n  [key: string]: unknown\n}\n\nfunction slugify(text: string): string {\n  return text\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, '-')\n    .replace(/^-+|-+$/g, '')\n}\n\nasync function generateUniqueSlug(prisma: any, baseSlug: string, excludeId?: string): Promise<string> {\n  let slug = baseSlug\n  let counter = 1\n  \n  while (true) {\n    const existing = await prisma.post.findFirst({\n      where: {\n        slug,\n        ...(excludeId ? { NOT: { id: excludeId } } : {}),\n      },\n    })\n    \n    if (!existing) return slug\n    \n    counter++\n    slug = `${baseSlug}-${counter}`\n  }\n}\n\n/**\n * Fire the dynamic Prismic destination if enabled in IntegrationSettings.\n * This runs in the background and does not block the main response.\n */\nasync function fireDynamicPrismicDestination(\n  prisma: any, \n  post: Post, \n  event: 'publish' | 'unpublish' | 'delete',\n  envWriteToken?: string\n): Promise<void> {\n  try {\n    // Check if Prismic integration is enabled in DB\n    const settings = await prisma.integrationSettings.findUnique({\n      where: { id: 'default' },\n    })\n\n    if (!settings?.prismicEnabled || !settings?.prismicRepository) {\n      return // Prismic not enabled or not configured\n    }\n\n    // Use DB token or fall back to env token passed from host app config\n    const writeToken = settings.prismicWriteToken || envWriteToken\n    if (!writeToken) {\n      console.warn('[autoblogger] Prismic enabled but no write token configured')\n      return\n    }\n\n    // Create dynamic Prismic destination from DB settings\n    const prismicDest = createPrismicDestination({\n      repository: settings.prismicRepository,\n      writeToken: writeToken,\n      documentType: settings.prismicDocumentType || 'autoblog',\n      syncMode: (settings.prismicSyncMode as 'stub' | 'full') || 'stub',\n      masterLocale: settings.prismicLocale || 'en-us',\n      autoRename: settings.prismicAutoRename ?? false,\n    })\n\n    // Fire the appropriate event\n    if (event === 'publish') {\n      await prismicDest.onPublish(post)\n    } else if (event === 'unpublish') {\n      await prismicDest.onUnpublish(post)\n    } else if (event === 'delete') {\n      await prismicDest.onDelete(post)\n    }\n  } catch (error) {\n    console.error('[autoblogger] Failed to fire dynamic Prismic destination:', error)\n  }\n}\n\nexport function createPostsData(prisma: any, hooks?: PostHooks, dispatcher?: DestinationDispatcher, prismicEnvToken?: string) {\n  return {\n    async count(where?: { status?: string }) {\n      return prisma.post.count({ where })\n    },\n\n    async findPublished() {\n      return prisma.post.findMany({\n        where: { status: PostStatus.PUBLISHED },\n        orderBy: { publishedAt: 'desc' },\n      })\n    },\n\n    async findBySlug(slug: string) {\n      return prisma.post.findUnique({\n        where: { slug },\n        include: { tags: { include: { tag: true } } },\n      })\n    },\n\n    async findById(id: string) {\n      return prisma.post.findUnique({\n        where: { id },\n        include: { tags: { include: { tag: true } } },\n      })\n    },\n\n    async findDrafts() {\n      return prisma.post.findMany({\n        where: { status: PostStatus.DRAFT },\n        orderBy: { updatedAt: 'desc' },\n      })\n    },\n\n    async findAll(options?: { \n      status?: string\n      orderBy?: any\n      skip?: number\n      take?: number\n      includeRevisionCount?: boolean\n    }) {\n      return prisma.post.findMany({\n        where: options?.status ? { status: options.status } : undefined,\n        orderBy: options?.orderBy || { updatedAt: 'desc' },\n        include: { \n          tags: { include: { tag: true } },\n          ...(options?.includeRevisionCount ? { _count: { select: { revisions: true } } } : {}),\n        },\n        skip: options?.skip,\n        take: options?.take,\n      })\n    },\n\n    async create(data: CreatePostInput) {\n      // Extract tagIds before passing to Prisma\n      const { tagIds, ...postData } = data as CreatePostInput & { tagIds?: string[] }\n      \n      const slug = postData.slug \n        ? await generateUniqueSlug(prisma, postData.slug)\n        : await generateUniqueSlug(prisma, slugify(postData.title))\n\n      const post = await prisma.post.create({\n        data: {\n          ...postData,\n          slug,\n          markdown: postData.markdown || '',\n          status: postData.status || PostStatus.DRAFT,\n        },\n      })\n\n      // Create tag associations if provided\n      if (tagIds?.length) {\n        await prisma.postTag.createMany({\n          data: tagIds.map((tagId: string) => ({ postId: post.id, tagId })),\n        })\n      }\n\n      // Fetch with tags included\n      const result = await prisma.post.findUnique({\n        where: { id: post.id },\n        include: { tags: { include: { tag: true } } },\n      })\n\n      if (hooks?.afterSave) {\n        await hooks.afterSave(result)\n      }\n\n      return result\n    },\n\n    async update(id: string, data: UpdatePostInput) {\n      // Extract relation IDs, computed fields, and read-only fields before passing to Prisma\n      const { \n        tagIds, \n        tags, \n        revisions, \n        topic,\n        topicId,                    // Handle separately as relation\n        id: _id,                    // Don't update the ID\n        createdAt: _createdAt,      // Don't update createdAt\n        wordCount: _wordCount,      // Computed field, don't save\n        ...postData \n      } = data as UpdatePostInput & { \n        tagIds?: string[]\n        tags?: unknown\n        revisions?: unknown\n        topic?: unknown\n        topicId?: string | null\n        id?: string\n        createdAt?: Date\n        wordCount?: number\n      }\n      \n      // Track if this is a publish, unpublish, or update of published content\n      let isPublishing = false\n      let isUnpublishing = false\n      let isUpdatingPublished = false\n\n      // Fetch existing post to determine state changes\n      const existing = await prisma.post.findUnique({ where: { id } })\n\n      // Check if content that affects external destinations has changed\n      // For code-configured destinations (full sync mode), check title, slug, and content\n      const hasDestinationChanges = existing && (\n        (postData.title !== undefined && postData.title !== existing.title) ||\n        (postData.slug !== undefined && postData.slug !== existing.slug) ||\n        (postData.markdown !== undefined && postData.markdown !== existing.markdown)\n      )\n      \n      // For dynamic Prismic destination (stub mode), only slug and title changes matter\n      // Content doesn't need to sync since it lives in autoblogger, not Prismic\n      const hasSlugChange = existing && postData.slug !== undefined && postData.slug !== existing.slug\n      const hasTitleChange = existing && postData.title !== undefined && postData.title !== existing.title\n\n      // Auto-set publishedAt on first publish\n      if (postData.status === PostStatus.PUBLISHED) {\n        if (existing?.status !== PostStatus.PUBLISHED) {\n          postData.publishedAt = new Date()\n          isPublishing = true\n          \n          if (hooks?.beforePublish) {\n            await hooks.beforePublish(existing)\n          }\n        } else if (hasDestinationChanges) {\n          // Post is already published AND has content changes - sync to destinations\n          isUpdatingPublished = true\n        }\n      } else if (postData.status === PostStatus.DRAFT) {\n        // Check if unpublishing (from published to draft)\n        if (existing?.status === PostStatus.PUBLISHED) {\n          isUnpublishing = true\n        }\n      } else if (postData.status === undefined && existing?.status === PostStatus.PUBLISHED && hasDestinationChanges) {\n        // Status not changing but post is published AND has changes - sync to destinations\n        isUpdatingPublished = true\n      }\n\n      // Handle slug uniqueness if slug is being changed\n      if (postData.slug) {\n        postData.slug = await generateUniqueSlug(prisma, postData.slug, id)\n      }\n\n      // Build the update payload\n      const updatePayload: any = { ...postData }\n\n      // Handle topic relation properly using connect/disconnect syntax\n      if (topicId !== undefined) {\n        updatePayload.topic = topicId ? { connect: { id: topicId } } : { disconnect: true }\n      }\n\n      const post = await prisma.post.update({\n        where: { id },\n        data: updatePayload,\n      })\n\n      // Update tag associations if provided\n      if (tagIds !== undefined) {\n        // Delete existing tags and create new ones\n        await prisma.postTag.deleteMany({ where: { postId: id } })\n        if (tagIds.length) {\n          await prisma.postTag.createMany({\n            data: tagIds.map((tagId: string) => ({ postId: id, tagId })),\n          })\n        }\n      }\n\n      // Fetch with tags included\n      const result = await prisma.post.findUnique({\n        where: { id },\n        include: { tags: { include: { tag: true } } },\n      })\n\n      if (hooks?.afterSave) {\n        await hooks.afterSave(result)\n      }\n\n      // Check for slug change on a previously-published post (create redirect)\n      const oldSlug = existing?.slug\n      const newSlug = postData.slug\n      const slugChanged = oldSlug && newSlug && newSlug !== oldSlug\n      const wasPublished = existing?.publishedAt !== null\n      if (slugChanged && wasPublished && hooks?.onSlugChange) {\n        hooks.onSlugChange({\n          postId: id,\n          oldSlug,\n          newSlug,\n        }).catch((err) => {\n          console.error('[autoblogger] Failed to handle slug change:', err)\n        })\n      }\n\n      // Fire destination events after save\n      if (isPublishing || isUnpublishing || isUpdatingPublished) {\n        // Fire code-configured dispatcher (full sync mode - syncs on all content changes)\n        if (dispatcher) {\n          if (isPublishing || isUpdatingPublished) {\n            // Both new publish and updates to published content use onPublish\n            dispatcher.publish(result).catch((err) => {\n              console.error('[autoblogger] Failed to dispatch publish event:', err)\n            })\n          } else if (isUnpublishing) {\n            dispatcher.unpublish(result).catch((err) => {\n              console.error('[autoblogger] Failed to dispatch unpublish event:', err)\n            })\n          }\n        }\n      }\n      \n      // Fire dynamic Prismic destination separately (stub mode - only on publish/unpublish/slug/title changes)\n      // Don't sync on content-only saves - only when document needs to be created, UID updated, or name updated\n      if (isPublishing || isUnpublishing || (isUpdatingPublished && (hasSlugChange || hasTitleChange))) {\n        const event = isUnpublishing ? 'unpublish' : 'publish'\n        fireDynamicPrismicDestination(prisma, result, event, prismicEnvToken)\n      }\n\n      return result\n    },\n\n    async delete(id: string) {\n      // Get the post before deleting to pass to dispatcher\n      const existing = await prisma.post.findUnique({\n        where: { id },\n        include: { tags: { include: { tag: true } } },\n      })\n\n      // Soft delete - set status to 'deleted' instead of removing\n      const result = await prisma.post.update({ \n        where: { id },\n        data: { status: PostStatus.DELETED },\n      })\n\n      // Fire delete event if the post was published\n      if (existing?.status === PostStatus.PUBLISHED) {\n        if (dispatcher) {\n          dispatcher.delete(existing).catch((err) => {\n            console.error('[autoblogger] Failed to dispatch delete event:', err)\n          })\n        }\n        \n        // Fire dynamic Prismic destination if enabled\n        fireDynamicPrismicDestination(prisma, existing, 'delete', prismicEnvToken)\n      }\n\n      return result\n    },\n\n    async getPreviewUrl(id: string, basePath: string = '/e') {\n      const token = crypto.randomUUID()\n      const expiry = new Date(Date.now() + 24 * 60 * 60 * 1000) // 24 hours\n\n      const post = await prisma.post.update({\n        where: { id },\n        data: { previewToken: token, previewExpiry: expiry },\n      })\n\n      return `${basePath}/${post.slug}?preview=${token}`\n    },\n\n    async findByPreviewToken(token: string) {\n      const post = await prisma.post.findFirst({\n        where: {\n          previewToken: token,\n          previewExpiry: { gt: new Date() },\n        },\n      })\n      return post\n    },\n  }\n}\n","/**\n * Comments data layer for autoblogger.\n * Supports both public blog comments (simple) and editor comments (with quotedText, replies, resolve).\n */\n\ninterface CommentsConfig {\n  mode?: 'authenticated' | 'public' | 'disabled'\n}\n\n// Editor comment with full features\ninterface EditorComment {\n  id: string\n  postId: string\n  userId: string\n  quotedText: string\n  content: string\n  parentId: string | null\n  resolved: boolean\n  createdAt: Date\n  updatedAt: Date\n  user: {\n    id: string\n    name: string | null\n    email: string\n  }\n  replies?: EditorComment[]\n}\n\ninterface CreateEditorCommentInput {\n  postId: string\n  quotedText: string\n  content: string\n  parentId?: string\n}\n\n// Simple public comment (for blog post comments)\ninterface CreatePublicCommentInput {\n  postId: string\n  content: string\n  authorId?: string\n  authorName?: string\n  authorEmail?: string\n}\n\nexport function createCommentsData(prisma: any, config?: CommentsConfig) {\n  const mode = config?.mode || 'authenticated'\n\n  return {\n    async count() {\n      if (mode === 'disabled') return 0\n      return prisma.comment.count()\n    },\n\n    // Public blog comments (original simple system)\n    async findByPost(postId: string) {\n      if (mode === 'disabled') return []\n      \n      return prisma.comment.findMany({\n        where: { postId, approved: true },\n        orderBy: { createdAt: 'desc' },\n      })\n    },\n\n    async findAll(options?: { postId?: string; approved?: boolean; page?: number; limit?: number }) {\n      if (mode === 'disabled') return { data: [], total: 0, page: 1, totalPages: 1 }\n      \n      const page = options?.page || 1\n      const limit = options?.limit || 25\n      const skip = (page - 1) * limit\n\n      const where = {\n        ...(options?.postId ? { postId: options.postId } : {}),\n        ...(options?.approved !== undefined ? { approved: options.approved } : {}),\n      }\n\n      const [comments, total] = await Promise.all([\n        prisma.comment.findMany({\n          where,\n          orderBy: { createdAt: 'desc' },\n          skip,\n          take: limit,\n          include: { \n            post: { select: { id: true, title: true, slug: true } },\n            user: { select: { id: true, name: true, email: true } },\n          },\n        }),\n        prisma.comment.count({ where }),\n      ])\n\n      return {\n        data: comments,\n        total,\n        page,\n        totalPages: Math.ceil(total / limit),\n      }\n    },\n\n    async create(data: CreatePublicCommentInput) {\n      if (mode === 'disabled') {\n        throw new Error('Comments are disabled')\n      }\n\n      return prisma.comment.create({\n        data: {\n          ...data,\n          approved: mode === 'authenticated',\n        },\n      })\n    },\n\n    async approve(id: string) {\n      return prisma.comment.update({\n        where: { id },\n        data: { approved: true },\n      })\n    },\n\n    async delete(id: string) {\n      return prisma.comment.delete({ where: { id } })\n    },\n\n    getMode() {\n      return mode\n    },\n\n    // ========================================\n    // Editor comments (with quotedText, replies, resolve)\n    // ========================================\n\n    /**\n     * Find all editor comments for a post with nested replies.\n     */\n    async findEditorComments(postId: string, userId?: string): Promise<EditorComment[]> {\n      if (mode === 'disabled') return []\n\n      // Fetch all non-deleted comments for the post\n      const allComments = await prisma.comment.findMany({\n        where: {\n          postId,\n          deletedAt: null,\n        },\n        orderBy: { createdAt: 'desc' },\n        include: {\n          user: {\n            select: { id: true, name: true, email: true },\n          },\n        },\n      })\n\n      // Separate top-level and replies\n      const topLevel = allComments.filter((c: any) => !c.parentId)\n      const replies = allComments.filter((c: any) => c.parentId)\n\n      // Attach replies to their parents\n      return topLevel.map((comment: any) => ({\n        ...comment,\n        replies: replies.filter((r: any) => r.parentId === comment.id),\n      }))\n    },\n\n    /**\n     * Create an editor comment (with quotedText and optional parentId for replies).\n     */\n    async createEditorComment(\n      postId: string,\n      userId: string,\n      data: CreateEditorCommentInput\n    ): Promise<EditorComment> {\n      if (mode === 'disabled') {\n        throw new Error('Comments are disabled')\n      }\n\n      const comment = await prisma.comment.create({\n        data: {\n          postId,\n          userId,\n          quotedText: data.quotedText || '',\n          content: data.content,\n          parentId: data.parentId || null,\n          resolved: false,\n        },\n        include: {\n          user: {\n            select: { id: true, name: true, email: true },\n          },\n        },\n      })\n\n      return { ...comment, replies: [] }\n    },\n\n    /**\n     * Update a comment's content.\n     */\n    async updateEditorComment(\n      commentId: string,\n      content: string,\n      userId?: string\n    ): Promise<EditorComment> {\n      const comment = await prisma.comment.update({\n        where: { id: commentId },\n        data: { content },\n        include: {\n          user: {\n            select: { id: true, name: true, email: true },\n          },\n        },\n      })\n\n      return comment\n    },\n\n    /**\n     * Soft delete a comment.\n     */\n    async deleteEditorComment(commentId: string): Promise<void> {\n      // Check if the schema has deletedAt field\n      const hasDeletedAt = await prisma.comment.findFirst({\n        where: { id: commentId },\n        select: { id: true },\n      })\n\n      if (hasDeletedAt) {\n        // Try soft delete first, fall back to hard delete\n        try {\n          await prisma.comment.update({\n            where: { id: commentId },\n            data: { deletedAt: new Date() },\n          })\n        } catch {\n          // Schema doesn't have deletedAt, do hard delete\n          await prisma.comment.delete({ where: { id: commentId } })\n        }\n      }\n    },\n\n    /**\n     * Toggle resolved status.\n     */\n    async toggleResolve(commentId: string): Promise<EditorComment> {\n      const current = await prisma.comment.findUnique({\n        where: { id: commentId },\n        select: { resolved: true },\n      })\n\n      const comment = await prisma.comment.update({\n        where: { id: commentId },\n        data: { resolved: !current?.resolved },\n        include: {\n          user: {\n            select: { id: true, name: true, email: true },\n          },\n        },\n      })\n\n      return comment\n    },\n\n    /**\n     * Resolve all open comments for a post.\n     */\n    async resolveAll(postId: string): Promise<{ resolved: number }> {\n      const result = await prisma.comment.updateMany({\n        where: {\n          postId,\n          resolved: false,\n          parentId: null, // Only top-level comments\n        },\n        data: { resolved: true },\n      })\n\n      return { resolved: result.count }\n    },\n  }\n}\n","// Generic CRUD factory for data layer\n\nexport interface CrudOptions {\n  model: string\n  defaultOrderBy?: Record<string, 'asc' | 'desc'>\n  defaultInclude?: Record<string, unknown>\n}\n\nexport interface BaseCrud<T> {\n  findAll: (opts?: { skip?: number; take?: number; where?: Record<string, unknown> }) => Promise<T[]>\n  findById: (id: string) => Promise<T | null>\n  count: (where?: Record<string, unknown>) => Promise<number>\n  create: (data: Partial<T>) => Promise<T>\n  update: (id: string, data: Partial<T>) => Promise<T>\n  delete: (id: string) => Promise<T>\n}\n\n/**\n * Create a base CRUD data layer for a Prisma model.\n * Use spread operator to extend with custom methods:\n * \n * ```typescript\n * const base = createCrudData(prisma, { model: 'tag', defaultOrderBy: { name: 'asc' } })\n * return {\n *   ...base,\n *   customMethod: async () => { ... }\n * }\n * ```\n */\nexport function createCrudData<T>(prisma: any, options: CrudOptions): BaseCrud<T> {\n  const delegate = prisma[options.model]\n  \n  return {\n    async findAll(opts?: { skip?: number; take?: number; where?: Record<string, unknown> }) {\n      return delegate.findMany({\n        orderBy: options.defaultOrderBy,\n        include: options.defaultInclude,\n        ...opts,\n      })\n    },\n\n    async findById(id: string) {\n      return delegate.findUnique({\n        where: { id },\n        include: options.defaultInclude,\n      })\n    },\n\n    async count(where?: Record<string, unknown>) {\n      return delegate.count({ where })\n    },\n\n    async create(data: Partial<T>) {\n      return delegate.create({ data })\n    },\n\n    async update(id: string, data: Partial<T>) {\n      return delegate.update({\n        where: { id },\n        data,\n      })\n    },\n\n    async delete(id: string) {\n      return delegate.delete({ where: { id } })\n    },\n  }\n}\n","import { createCrudData } from './factory'\n\nexport function createTagsData(prisma: any) {\n  const base = createCrudData(prisma, {\n    model: 'tag',\n    defaultOrderBy: { name: 'asc' },\n    defaultInclude: { _count: { select: { posts: true } } },\n  })\n\n  return {\n    ...base,\n\n    // Alias for backward compatibility\n    async findAllWithCounts() {\n      return base.findAll()\n    },\n\n    async findByName(name: string) {\n      return prisma.tag.findUnique({ where: { name } })\n    },\n\n    // Override create to accept string directly\n    async create(name: string) {\n      return prisma.tag.create({ data: { name } })\n    },\n\n    // Override update to accept name directly\n    async update(id: string, name: string) {\n      return prisma.tag.update({ where: { id }, data: { name } })\n    },\n\n    async addToPost(postId: string, tagId: string) {\n      return prisma.postTag.create({\n        data: { postId, tagId },\n      })\n    },\n\n    async removeFromPost(postId: string, tagId: string) {\n      return prisma.postTag.deleteMany({\n        where: { postId, tagId },\n      })\n    },\n\n    async getPostTags(postId: string) {\n      const postTags = await prisma.postTag.findMany({\n        where: { postId },\n        include: { tag: true },\n      })\n      return postTags.map((pt: any) => pt.tag)\n    },\n  }\n}\n","export function createRevisionsData(prisma: any) {\n  return {\n    async findAll(options?: { postId?: string; skip?: number; take?: number }) {\n      return prisma.revision.findMany({\n        where: options?.postId ? { postId: options.postId } : {},\n        orderBy: { createdAt: 'desc' },\n        skip: options?.skip,\n        take: options?.take,\n        include: {\n          post: { select: { id: true, title: true, slug: true, markdown: true } },\n        },\n      })\n    },\n\n    async count(where?: { postId?: string }) {\n      return prisma.revision.count({ where })\n    },\n\n    async findByPost(postId: string) {\n      return prisma.revision.findMany({\n        where: { postId },\n        orderBy: { createdAt: 'desc' },\n      })\n    },\n\n    async findById(id: string) {\n      return prisma.revision.findUnique({\n        where: { id },\n        include: {\n          post: { select: { id: true, title: true, slug: true, markdown: true } },\n        },\n      })\n    },\n\n    async create(postId: string, data: { title?: string; subtitle?: string; markdown: string }) {\n      return prisma.revision.create({\n        data: { postId, ...data },\n      })\n    },\n\n    async restore(revisionId: string) {\n      const revision = await prisma.revision.findUnique({ where: { id: revisionId } })\n      if (!revision) throw new Error('Revision not found')\n\n      return prisma.post.update({\n        where: { id: revision.postId },\n        data: {\n          title: revision.title,\n          subtitle: revision.subtitle,\n          markdown: revision.markdown,\n        },\n      })\n    },\n\n    async compare(revisionId1: string, revisionId2: string) {\n      const [rev1, rev2] = await Promise.all([\n        prisma.revision.findUnique({ where: { id: revisionId1 } }),\n        prisma.revision.findUnique({ where: { id: revisionId2 } }),\n      ])\n\n      if (!rev1 || !rev2) throw new Error('Revision not found')\n\n      return {\n        older: rev1.createdAt < rev2.createdAt ? rev1 : rev2,\n        newer: rev1.createdAt < rev2.createdAt ? rev2 : rev1,\n      }\n    },\n\n    async pruneOldest(postId: string, keepCount: number) {\n      const revisions = await prisma.revision.findMany({\n        where: { postId },\n        orderBy: { createdAt: 'desc' },\n        skip: keepCount,\n        select: { id: true },\n      })\n\n      if (revisions.length > 0) {\n        await prisma.revision.deleteMany({\n          where: { id: { in: revisions.map((r: any) => r.id) } },\n        })\n      }\n\n      return revisions.length\n    },\n\n    async delete(id: string) {\n      return prisma.revision.delete({ where: { id } })\n    },\n  }\n}\n","export function createAISettingsData(prisma: any) {\n  const DEFAULT_ID = 'default'\n\n  return {\n    async get() {\n      let settings = await prisma.aISettings.findUnique({ where: { id: DEFAULT_ID } })\n      \n      if (!settings) {\n        settings = await prisma.aISettings.create({\n          data: { id: DEFAULT_ID },\n        })\n      }\n      \n      return settings\n    },\n\n    async update(data: {\n      rules?: string\n      chatRules?: string\n      rewriteRules?: string\n      autoDraftRules?: string\n      planRules?: string\n      defaultModel?: string\n      autoDraftWordCount?: number\n      generateTemplate?: string | null\n      chatTemplate?: string | null\n      rewriteTemplate?: string | null\n      autoDraftTemplate?: string | null\n      planTemplate?: string | null\n      expandPlanTemplate?: string | null\n      agentTemplate?: string | null\n      anthropicKey?: string | null\n      openaiKey?: string | null\n    }) {\n      return prisma.aISettings.upsert({\n        where: { id: DEFAULT_ID },\n        create: { id: DEFAULT_ID, ...data },\n        update: data,\n      })\n    },\n  }\n}\n","interface CreateTopicInput {\n  name: string\n  keywords?: string[]\n  rssFeeds?: string[]\n  isActive?: boolean\n  useKeywordFilter?: boolean\n  frequency?: string\n  maxPerPeriod?: number\n  essayFocus?: string\n}\n\ninterface UpdateTopicInput {\n  name?: string\n  keywords?: string[]\n  rssFeeds?: string[]\n  isActive?: boolean\n  useKeywordFilter?: boolean\n  frequency?: string\n  maxPerPeriod?: number\n  essayFocus?: string\n  lastRunAt?: Date\n}\n\nexport function createTopicsData(prisma: any) {\n  return {\n    async findAll() {\n      return prisma.topicSubscription.findMany({\n        orderBy: { createdAt: 'desc' },\n        include: {\n          _count: { select: { posts: true, newsItems: true } },\n        },\n      })\n    },\n\n    async count() {\n      return prisma.topicSubscription.count()\n    },\n\n    async findActive() {\n      return prisma.topicSubscription.findMany({\n        where: { isActive: true },\n        orderBy: { createdAt: 'desc' },\n      })\n    },\n\n    async findById(id: string) {\n      return prisma.topicSubscription.findUnique({\n        where: { id },\n        include: { posts: true, newsItems: true },\n      })\n    },\n\n    async create(data: CreateTopicInput) {\n      return prisma.topicSubscription.create({\n        data: {\n          name: data.name,\n          keywords: JSON.stringify(data.keywords || []),\n          rssFeeds: JSON.stringify(data.rssFeeds || []),\n          isActive: data.isActive ?? true,\n          useKeywordFilter: data.useKeywordFilter ?? true,\n          frequency: data.frequency || 'daily',\n          maxPerPeriod: data.maxPerPeriod || 3,\n          essayFocus: data.essayFocus,\n        },\n      })\n    },\n\n    async update(id: string, data: UpdateTopicInput) {\n      const updateData: any = { ...data }\n      \n      if (data.keywords) {\n        updateData.keywords = JSON.stringify(data.keywords)\n      }\n      if (data.rssFeeds) {\n        updateData.rssFeeds = JSON.stringify(data.rssFeeds)\n      }\n\n      return prisma.topicSubscription.update({\n        where: { id },\n        data: updateData,\n      })\n    },\n\n    async delete(id: string) {\n      return prisma.topicSubscription.delete({ where: { id } })\n    },\n\n    async markRun(id: string) {\n      return prisma.topicSubscription.update({\n        where: { id },\n        data: { lastRunAt: new Date() },\n      })\n    },\n  }\n}\n","import { PostStatus } from '../types/models'\n\ninterface CreateNewsItemInput {\n  topicId: string\n  url: string\n  title: string\n  summary?: string\n  publishedAt?: Date\n}\n\nexport function createNewsItemsData(prisma: any) {\n  return {\n    async findPending() {\n      return prisma.newsItem.findMany({\n        where: { status: 'pending' },\n        orderBy: { createdAt: 'desc' },\n        include: { topic: true },\n      })\n    },\n\n    async findByTopic(topicId: string) {\n      return prisma.newsItem.findMany({\n        where: { topicId },\n        orderBy: { createdAt: 'desc' },\n      })\n    },\n\n    async findById(id: string) {\n      return prisma.newsItem.findUnique({\n        where: { id },\n        include: { topic: true, post: true },\n      })\n    },\n\n    async create(data: CreateNewsItemInput) {\n      // Check if URL already exists\n      const existing = await prisma.newsItem.findUnique({\n        where: { url: data.url },\n      })\n      \n      if (existing) {\n        return existing\n      }\n\n      return prisma.newsItem.create({ data })\n    },\n\n    async skip(id: string) {\n      return prisma.newsItem.update({\n        where: { id },\n        data: { status: 'skipped' },\n      })\n    },\n\n    async markGenerated(id: string, postId: string) {\n      return prisma.newsItem.update({\n        where: { id },\n        data: { status: 'generated', postId },\n      })\n    },\n\n    async delete(id: string) {\n      return prisma.newsItem.delete({ where: { id } })\n    },\n\n    // This would be called by the auto-draft system\n    async generateDraft(id: string, createPost: (data: any) => Promise<any>) {\n      const newsItem = await prisma.newsItem.findUnique({\n        where: { id },\n        include: { topic: true },\n      })\n\n      if (!newsItem) throw new Error('News item not found')\n\n      // Create draft post\n      const post = await createPost({\n        title: newsItem.title,\n        markdown: newsItem.summary || '',\n        status: PostStatus.SUGGESTED,\n        sourceUrl: newsItem.url,\n        topicId: newsItem.topicId,\n      })\n\n      // Mark as generated\n      await prisma.newsItem.update({\n        where: { id },\n        data: { status: 'generated', postId: post.id },\n      })\n\n      return post\n    },\n  }\n}\n","import { createCrudData } from './factory'\n\ninterface CreateUserInput {\n  email: string\n  name?: string\n  role?: string\n}\n\ninterface UpdateUserInput {\n  name?: string\n  role?: string\n}\n\nexport function createUsersData(prisma: any) {\n  const base = createCrudData(prisma, {\n    model: 'user',\n    defaultOrderBy: { createdAt: 'desc' },\n  })\n\n  return {\n    ...base,\n\n    async findByEmail(email: string) {\n      return prisma.user.findUnique({ where: { email } })\n    },\n\n    // Override create with proper defaults\n    async create(data: CreateUserInput) {\n      return prisma.user.create({\n        data: {\n          email: data.email,\n          name: data.name,\n          role: data.role || 'writer',\n        },\n      })\n    },\n\n    // Override update with proper typing\n    async update(id: string, data: UpdateUserInput) {\n      return prisma.user.update({\n        where: { id },\n        data,\n      })\n    },\n  }\n}\n","import type { AutobloggerServer as Autoblogger, Session } from '../server'\nimport { PostStatus } from '../types/models'\n\ntype NextRequest = Request & { nextUrl: URL }\n\nfunction jsonResponse(data: unknown, status = 200) {\n  return new Response(JSON.stringify(data), {\n    status,\n    headers: { 'Content-Type': 'application/json' },\n  })\n}\n\nfunction countWords(text?: string | null): number {\n  if (!text) return 0\n  return text.split(/\\s+/).filter(Boolean).length\n}\n\nfunction withWordCount<T extends { markdown?: string | null }>(post: T): T & { wordCount: number } {\n  return { ...post, wordCount: countWords(post.markdown) }\n}\n\nexport async function handlePostsAPI(\n  req: NextRequest,\n  cms: Autoblogger,\n  session: Session | null,\n  path: string,\n  onMutate?: (type: string, data: unknown) => Promise<void>\n): Promise<Response> {\n  const method = req.method\n  const segments = path.split('/').filter(Boolean)\n  const postId = segments[1]\n  \n  // Handle nested comment routes: /posts/:id/comments\n  if (postId && segments[2] === 'comments') {\n    return handlePostCommentsAPI(req, cms, session, postId, segments.slice(3), onMutate)\n  }\n\n  // GET /posts - list posts\n  if (method === 'GET' && !postId) {\n    const url = new URL(req.url)\n    const status = url.searchParams.get('status')\n    const all = url.searchParams.get('all') === '1'\n    const page = parseInt(url.searchParams.get('page') || '1', 10)\n    const limit = parseInt(url.searchParams.get('limit') || '0', 10)\n    const includeRevisionCount = url.searchParams.get('includeRevisionCount') === '1'\n    \n    // Calculate pagination\n    const skip = limit > 0 ? (page - 1) * limit : undefined\n    const take = limit > 0 ? limit : undefined\n    \n    // Get total count for pagination\n    const total = await cms.posts.count(all ? undefined : { status: status || undefined })\n    \n    const posts = await cms.posts.findAll({ \n      status: all ? undefined : (status || undefined),\n      skip,\n      take,\n      includeRevisionCount,\n    })\n    return jsonResponse({ data: posts.map(withWordCount), total })\n  }\n\n  // GET /posts/:id - get single post\n  if (method === 'GET' && postId) {\n    const post = await cms.posts.findById(postId)\n    if (!post) return jsonResponse({ error: 'Post not found' }, 404)\n    return jsonResponse({ data: withWordCount(post) })\n  }\n\n  // POST /posts - create post\n  if (method === 'POST') {\n    const body = await req.json()\n    const post = await cms.posts.create(body)\n    if (onMutate) await onMutate('post', post)\n    return jsonResponse({ data: post }, 201)\n  }\n\n  // PATCH /posts/:id - update post\n  if (method === 'PATCH' && postId) {\n    const body = await req.json()\n    \n    // Check publish permission\n    if (body.status === PostStatus.PUBLISHED && !cms.config.auth.canPublish(session)) {\n      return jsonResponse({ error: 'Not authorized to publish' }, 403)\n    }\n    \n    // Create a revision of the current state BEFORE updating (if content is changing)\n    const contentChanging = body.title !== undefined || body.subtitle !== undefined || body.markdown !== undefined\n    if (contentChanging) {\n      const existingPost = await cms.posts.findById(postId)\n      if (existingPost && existingPost.markdown) {\n        // Check if content is actually different from most recent revision\n        // to avoid creating duplicate revisions on frequent auto-saves\n        const recentRevisions = await cms.revisions.findByPost(postId)\n        const lastRevision = recentRevisions[0]\n        \n        const contentIsDifferent = !lastRevision || \n          lastRevision.markdown !== existingPost.markdown ||\n          lastRevision.title !== existingPost.title ||\n          lastRevision.subtitle !== existingPost.subtitle\n        \n        if (contentIsDifferent) {\n          await cms.revisions.create(postId, {\n            title: existingPost.title,\n            subtitle: existingPost.subtitle,\n            markdown: existingPost.markdown,\n          })\n          // Prune old revisions (keep last 50)\n          await cms.revisions.pruneOldest(postId, 50)\n        }\n      }\n    }\n    \n    const post = await cms.posts.update(postId, body)\n    if (onMutate) await onMutate('post', post)\n    return jsonResponse({ data: post })\n  }\n\n  // DELETE /posts/:id - delete post\n  if (method === 'DELETE' && postId) {\n    if (!cms.config.auth.isAdmin(session)) {\n      return jsonResponse({ error: 'Admin required' }, 403)\n    }\n    await cms.posts.delete(postId)\n    if (onMutate) await onMutate('post', { id: postId })\n    return jsonResponse({ data: { success: true } })\n  }\n\n  return jsonResponse({ error: 'Method not allowed' }, 405)\n}\n\n/**\n * Handle post-specific comment routes: /posts/:postId/comments/*\n * These are editor comments (with quotedText, replies, resolve).\n */\nasync function handlePostCommentsAPI(\n  req: NextRequest,\n  cms: Autoblogger,\n  session: Session | null,\n  postId: string,\n  segments: string[], // e.g., [] for /comments, ['abc'] for /comments/abc, ['abc', 'resolve'] for /comments/abc/resolve\n  onMutate?: (type: string, data: unknown) => Promise<void>\n): Promise<Response> {\n  const method = req.method\n  const commentId = segments[0]\n  const action = segments[1] // e.g., 'resolve'\n  \n  const userId = session?.user?.id\n  if (!userId) {\n    return jsonResponse({ error: 'Authentication required' }, 401)\n  }\n\n  // GET /posts/:id/comments - list comments for post\n  if (method === 'GET' && !commentId) {\n    const comments = await cms.comments.findEditorComments(postId, userId)\n    return jsonResponse({ data: comments })\n  }\n\n  // POST /posts/:id/comments - create comment\n  if (method === 'POST' && !commentId) {\n    const body = await req.json()\n    const comment = await cms.comments.createEditorComment(postId, userId, {\n      postId,\n      quotedText: body.quotedText || '',\n      content: body.content,\n      parentId: body.parentId,\n    })\n    if (onMutate) await onMutate('comment', comment)\n    return jsonResponse({ data: comment }, 201)\n  }\n\n  // POST /posts/:id/comments/resolve-all - resolve all comments\n  if (method === 'POST' && commentId === 'resolve-all') {\n    const result = await cms.comments.resolveAll(postId)\n    return jsonResponse({ data: result })\n  }\n\n  // PATCH /posts/:id/comments/:commentId - update comment\n  if (method === 'PATCH' && commentId && !action) {\n    const body = await req.json()\n    const comment = await cms.comments.updateEditorComment(commentId, body.content, userId)\n    return jsonResponse({ data: comment })\n  }\n\n  // POST /posts/:id/comments/:commentId/resolve - toggle resolve\n  if (method === 'POST' && commentId && action === 'resolve') {\n    const comment = await cms.comments.toggleResolve(commentId)\n    return jsonResponse({ data: comment })\n  }\n\n  // DELETE /posts/:id/comments/:commentId - delete comment\n  if (method === 'DELETE' && commentId) {\n    await cms.comments.deleteEditorComment(commentId)\n    return jsonResponse({ data: { success: true } })\n  }\n\n  return jsonResponse({ error: 'Method not allowed' }, 405)\n}\n","import type { AutobloggerServer } from '../server'\nimport type { Session } from '../types/session'\n\n/**\n * Create a JSON response with proper headers.\n */\nexport function jsonResponse(data: unknown, status = 200): Response {\n  return new Response(JSON.stringify(data), {\n    status,\n    headers: { 'Content-Type': 'application/json' },\n  })\n}\n\n/**\n * Parse URL path into segments and common parts.\n */\nexport function parsePath(path: string): {\n  segments: string[]\n  resource: string\n  id?: string\n  subPath: string\n} {\n  const segments = path.split('/').filter(Boolean)\n  return {\n    segments,\n    resource: segments[0] || '',\n    id: segments[1],\n    subPath: segments.slice(2).join('/'),\n  }\n}\n\n/**\n * Check if user is admin, return error response if not.\n * Returns null if authorized.\n */\nexport function requireAdmin(\n  cms: AutobloggerServer,\n  session: Session | null\n): Response | null {\n  if (!cms.config.auth.isAdmin(session)) {\n    return jsonResponse({ error: 'Admin required' }, 403)\n  }\n  return null\n}\n\n/**\n * Check if user is authenticated, return error response if not.\n * Returns null if authorized.\n */\nexport function requireAuth(session: Session | null): Response | null {\n  if (!session) {\n    return jsonResponse({ error: 'Authentication required' }, 401)\n  }\n  return null\n}\n\n/**\n * Check if user can publish, return error response if not.\n * Returns null if authorized.\n */\nexport function requirePublish(\n  cms: AutobloggerServer,\n  session: Session | null\n): Response | null {\n  if (!cms.config.auth.canPublish(session)) {\n    return jsonResponse({ error: 'Publish permission required' }, 403)\n  }\n  return null\n}\n","import type { AutobloggerServer as Autoblogger, Session } from '../server'\nimport { jsonResponse, parsePath, requireAdmin } from './utils'\n\ntype NextRequest = Request & { nextUrl: URL }\n\nexport async function handleCommentsAPI(\n  req: NextRequest,\n  cms: Autoblogger,\n  session: Session | null,\n  path: string,\n  onMutate?: (type: string, data: unknown) => Promise<void>\n): Promise<Response> {\n  const method = req.method\n  const { id: commentId, subPath } = parsePath(path)\n\n  // GET /comments - list comments (with pagination)\n  if (method === 'GET') {\n    const url = new URL(req.url)\n    const postId = url.searchParams.get('postId')\n    const page = parseInt(url.searchParams.get('page') || '1')\n    const limit = parseInt(url.searchParams.get('limit') || '25')\n    const result = await cms.comments.findAll({ \n      postId: postId || undefined,\n      page,\n      limit,\n    })\n    return jsonResponse(result)\n  }\n\n  // POST /comments - create comment\n  if (method === 'POST') {\n    const body = await req.json()\n    const comment = await cms.comments.create({\n      ...body,\n      authorId: session?.user?.id,\n    })\n    if (onMutate) await onMutate('comment', comment)\n    return jsonResponse({ data: comment }, 201)\n  }\n\n  // PATCH /comments/:id/approve - approve comment\n  if (method === 'PATCH' && commentId && subPath === 'approve') {\n    const authError = requireAdmin(cms, session)\n    if (authError) return authError\n\n    const comment = await cms.comments.approve(commentId)\n    return jsonResponse({ data: comment })\n  }\n\n  // DELETE /comments/:id - delete comment\n  if (method === 'DELETE' && commentId) {\n    const authError = requireAdmin(cms, session)\n    if (authError) return authError\n\n    await cms.comments.delete(commentId)\n    return jsonResponse({ data: { success: true } })\n  }\n\n  return jsonResponse({ error: 'Method not allowed' }, 405)\n}\n","import type { AutobloggerServer as Autoblogger, Session } from '../server'\nimport { jsonResponse, parsePath, requireAdmin } from './utils'\n\ntype NextRequest = Request & { nextUrl: URL }\n\nexport async function handleTagsAPI(\n  req: NextRequest,\n  cms: Autoblogger,\n  session: Session | null,\n  path: string,\n  onMutate?: (type: string, data: unknown) => Promise<void>\n): Promise<Response> {\n  const method = req.method\n  const { id: tagId } = parsePath(path)\n\n  // GET /tags - list all tags\n  if (method === 'GET' && !tagId) {\n    const tags = await cms.tags.findAll()\n    return jsonResponse({ data: tags })\n  }\n\n  // POST /tags - create tag\n  if (method === 'POST') {\n    const authError = requireAdmin(cms, session)\n    if (authError) return authError\n\n    const body = await req.json()\n    const tag = await cms.tags.create(body.name)\n    if (onMutate) await onMutate('tag', tag)\n    return jsonResponse({ data: tag }, 201)\n  }\n\n  // PATCH /tags/:id - update tag\n  if (method === 'PATCH' && tagId) {\n    const authError = requireAdmin(cms, session)\n    if (authError) return authError\n\n    const body = await req.json()\n    const tag = await cms.tags.update(tagId, body.name)\n    return jsonResponse({ data: tag })\n  }\n\n  // DELETE /tags/:id - delete tag\n  if (method === 'DELETE' && tagId) {\n    const authError = requireAdmin(cms, session)\n    if (authError) return authError\n\n    await cms.tags.delete(tagId)\n    return jsonResponse({ data: { success: true } })\n  }\n\n  return jsonResponse({ error: 'Method not allowed' }, 405)\n}\n","import type { AutobloggerServer as Autoblogger, Session } from '../server'\nimport {\n  DEFAULT_GENERATE_TEMPLATE,\n  DEFAULT_CHAT_TEMPLATE,\n  DEFAULT_REWRITE_TEMPLATE,\n  DEFAULT_AUTO_DRAFT_TEMPLATE,\n  DEFAULT_PLAN_TEMPLATE,\n  DEFAULT_EXPAND_PLAN_TEMPLATE,\n  DEFAULT_PLAN_RULES,\n  DEFAULT_AGENT_TEMPLATE,\n  DEFAULT_SEARCH_ONLY_PROMPT,\n} from '../ai/prompts'\nimport { getModelOptions } from '../ai/models'\nimport { jsonResponse, requireAuth, requireAdmin } from './utils'\n\ntype NextRequest = Request & { nextUrl: URL }\n\nexport async function handleAIAPI(\n  req: NextRequest,\n  cms: Autoblogger,\n  session: Session | null,\n  path: string\n): Promise<Response> {\n  const method = req.method\n  \n  // Check auth\n  const authError = requireAuth(session)\n  if (authError) return authError\n\n  // GET /ai/settings - get AI settings\n  if (method === 'GET' && path === '/ai/settings') {\n    const settings = await cms.aiSettings.get()\n    \n    // Check if API keys are available from config or environment variables\n    const hasAnthropicEnvKey = !!(cms.config.ai?.anthropicKey || process.env.ANTHROPIC_API_KEY)\n    const hasOpenaiEnvKey = !!(cms.config.ai?.openaiKey || process.env.OPENAI_API_KEY)\n    \n    // Include default templates for the UI to display as placeholders\n    return jsonResponse({ \n      data: {\n        ...settings,\n        // Don't expose actual env keys, just indicate they exist\n        hasAnthropicEnvKey,\n        hasOpenaiEnvKey,\n        defaultGenerateTemplate: DEFAULT_GENERATE_TEMPLATE,\n        defaultChatTemplate: DEFAULT_CHAT_TEMPLATE,\n        defaultRewriteTemplate: DEFAULT_REWRITE_TEMPLATE,\n        defaultAutoDraftTemplate: DEFAULT_AUTO_DRAFT_TEMPLATE,\n        defaultPlanTemplate: DEFAULT_PLAN_TEMPLATE,\n        defaultExpandPlanTemplate: DEFAULT_EXPAND_PLAN_TEMPLATE,\n        defaultAgentTemplate: DEFAULT_AGENT_TEMPLATE,\n        defaultPlanRules: DEFAULT_PLAN_RULES,\n        availableModels: getModelOptions(),\n      }\n    })\n  }\n\n  // PATCH /ai/settings - update AI settings\n  if (method === 'PATCH' && path === '/ai/settings') {\n    const adminError = requireAdmin(cms, session)\n    if (adminError) return adminError\n\n    const body = await req.json()\n    const settings = await cms.aiSettings.update(body)\n    return jsonResponse({ data: settings })\n  }\n\n  // POST /ai/generate - generate content (streaming)\n  if (method === 'POST' && path === '/ai/generate') {\n    const body = await req.json()\n    const { prompt, model, wordCount, mode, plan, styleExamples: clientStyleExamples, useWebSearch, useThinking } = body\n    \n    // Get AI settings for rules\n    const settings = await cms.aiSettings.get()\n    \n    try {\n      let stream: ReadableStream\n      \n      // Use keys from config, falling back to database settings\n      const anthropicKey = cms.config.ai?.anthropicKey || settings.anthropicKey\n      const openaiKey = cms.config.ai?.openaiKey || settings.openaiKey\n\n      if (mode === 'expand_plan' && plan) {\n        // Fetch published essays as style examples if not provided by client\n        let styleExamples = clientStyleExamples || ''\n        if (!styleExamples) {\n          styleExamples = await fetchStyleExamples(cms)\n        }\n        \n        // Draft essay from plan mode\n        const { expandPlanStream } = await import('../ai/generate')\n        stream = await expandPlanStream({\n          plan,\n          model: model || settings.defaultModel,\n          rules: settings.rules,\n          template: settings.expandPlanTemplate,\n          styleExamples,\n          anthropicKey,\n          openaiKey,\n        })\n      } else {\n        // Fetch published essays as style examples for standard generation too\n        let styleExamples = clientStyleExamples || ''\n        if (!styleExamples) {\n          styleExamples = await fetchStyleExamples(cms)\n        }\n        \n        // Standard generation\n        const { generateStream } = await import('../ai/generate')\n        stream = await generateStream({\n          prompt,\n          model: model || settings.defaultModel,\n          wordCount,\n          rules: settings.rules,\n          template: settings.generateTemplate,\n          styleExamples,\n          anthropicKey,\n          openaiKey,\n          useWebSearch,\n          useThinking,\n        })\n      }\n      \n      return new Response(stream, {\n        headers: {\n          'Content-Type': 'text/event-stream',\n          'Cache-Control': 'no-cache',\n          'Connection': 'keep-alive',\n        },\n      })\n    } catch (error) {\n      console.error('[AI Generate Error]', error)\n      return jsonResponse({ \n        error: error instanceof Error ? error.message : 'Generation failed' \n      }, 500)\n    }\n  }\n\n  // POST /ai/chat - chat with AI (streaming or search mode)\n  if (method === 'POST' && path === '/ai/chat') {\n    const body = await req.json()\n    const { messages, model, essayContext, mode, useWebSearch, useThinking } = body\n    \n    const settings = await cms.aiSettings.get()\n    \n    // Use keys from config, falling back to database settings\n    const anthropicKey = cms.config.ai?.anthropicKey || settings.anthropicKey\n    const openaiKey = cms.config.ai?.openaiKey || settings.openaiKey\n    \n    // Handle search mode - non-streaming JSON response\n    if (mode === 'search') {\n      try {\n        const { generate } = await import('../ai/provider')\n        \n        // Get the last user message as the search query\n        const lastUserMessage = [...messages].reverse().find((m: { role: string }) => m.role === 'user')\n        if (!lastUserMessage) {\n          return jsonResponse({ error: 'No user message found' }, 400)\n        }\n        \n        const result = await generate(\n          model || settings.defaultModel,\n          DEFAULT_SEARCH_ONLY_PROMPT,\n          lastUserMessage.content,\n          {\n            anthropicKey,\n            openaiKey,\n            maxTokens: 4096,\n            useWebSearch: true, // Always use web search in search mode\n          }\n        )\n        \n        return jsonResponse({ \n          content: result.text,\n          usage: {\n            inputTokens: result.inputTokens,\n            outputTokens: result.outputTokens,\n          }\n        })\n      } catch (error) {\n        console.error('[AI Search Error]', error)\n        return jsonResponse({ \n          error: error instanceof Error ? error.message : 'Search failed' \n        }, 500)\n      }\n    }\n    \n    // Fetch published essays as style examples\n    let styleExamples = ''\n    try {\n      const publishedPosts = await cms.posts.findPublished()\n      const MAX_STYLE_EXAMPLES = 5\n      const MAX_WORDS_PER_EXAMPLE = 500\n      \n      if (publishedPosts.length > 0) {\n        const examples = publishedPosts\n          .slice(0, MAX_STYLE_EXAMPLES)\n          .map((post: { title: string; subtitle?: string; markdown: string }) => {\n            // Truncate long essays to avoid massive prompts\n            const words = post.markdown.split(/\\s+/)\n            const truncatedContent = words.length > MAX_WORDS_PER_EXAMPLE\n              ? words.slice(0, MAX_WORDS_PER_EXAMPLE).join(' ') + '...'\n              : post.markdown\n            \n            return `## ${post.title}\n${post.subtitle ? `*${post.subtitle}*\\n` : ''}\n${truncatedContent}`\n          })\n          .join('\\n\\n---\\n\\n')\n        \n        styleExamples = `<published_essays>\nThe following are examples of the author's published work. Use these to match their voice, tone, and writing style:\n\n${examples}\n</published_essays>`\n      }\n    } catch (err) {\n      console.error('[AI Chat] Failed to fetch published essays:', err)\n      // Continue without style examples\n    }\n    \n    const { chatStream } = await import('../ai/chat')\n    \n    try {\n      const stream = await chatStream({\n        messages,\n        model: model || settings.defaultModel,\n        essayContext,\n        mode,\n        chatRules: settings.chatRules,\n        rules: settings.rules,\n        template: settings.chatTemplate,\n        // Plan mode specific settings\n        planTemplate: settings.planTemplate,\n        planRules: settings.planRules,\n        // Agent mode specific settings\n        agentTemplate: settings.agentTemplate,\n        styleExamples,\n        anthropicKey,\n        openaiKey,\n        useWebSearch,\n        useThinking,\n      })\n      \n      return new Response(stream, {\n        headers: {\n          'Content-Type': 'text/event-stream',\n          'Cache-Control': 'no-cache',\n          'Connection': 'keep-alive',\n        },\n      })\n    } catch (error) {\n      console.error('[AI Chat Error]', error)\n      return jsonResponse({ \n        error: error instanceof Error ? error.message : 'Chat failed' \n      }, 500)\n    }\n  }\n\n  // POST /ai/rewrite - rewrite selected text (non-streaming)\n  if (method === 'POST' && path === '/ai/rewrite') {\n    const body = await req.json()\n    const { text } = body\n    \n    if (!text || typeof text !== 'string') {\n      return jsonResponse({ error: 'Text is required' }, 400)\n    }\n    \n    const settings = await cms.aiSettings.get()\n    \n    // Use keys from config, falling back to database settings\n    const anthropicKey = cms.config.ai?.anthropicKey || settings.anthropicKey\n    const openaiKey = cms.config.ai?.openaiKey || settings.openaiKey\n    \n    // Fetch published essays as style examples\n    let styleExamples = ''\n    try {\n      const publishedPosts = await cms.posts.findPublished()\n      const MAX_STYLE_EXAMPLES = 3\n      const MAX_WORDS_PER_EXAMPLE = 300\n      \n      if (publishedPosts.length > 0) {\n        const examples = publishedPosts\n          .slice(0, MAX_STYLE_EXAMPLES)\n          .map((post: { title: string; subtitle?: string; markdown: string }) => {\n            const words = post.markdown.split(/\\s+/)\n            const truncatedContent = words.length > MAX_WORDS_PER_EXAMPLE\n              ? words.slice(0, MAX_WORDS_PER_EXAMPLE).join(' ') + '...'\n              : post.markdown\n            \n            return `## ${post.title}\n${truncatedContent}`\n          })\n          .join('\\n\\n---\\n\\n')\n        \n        styleExamples = examples\n      }\n    } catch (err) {\n      console.error('[AI Rewrite] Failed to fetch published essays:', err)\n    }\n    \n    const { buildRewritePrompt } = await import('../ai/builders')\n    const { createStream } = await import('../ai/provider')\n    \n    try {\n      const systemPrompt = buildRewritePrompt({\n        rewriteRules: settings.rewriteRules,\n        rules: settings.rules,\n        template: settings.rewriteTemplate,\n        styleExamples,\n      })\n      \n      // Use streaming internally but collect full response\n      const stream = await createStream({\n        model: settings.defaultModel,\n        messages: [\n          { role: 'system', content: systemPrompt },\n          { role: 'user', content: `Rewrite the following text, preserving meaning but improving clarity and style:\\n\\n${text}` },\n        ],\n        anthropicKey,\n        openaiKey,\n        maxTokens: 2048,\n      })\n      \n      // Collect the streamed response\n      const reader = stream.getReader()\n      const decoder = new TextDecoder()\n      let rewrittenText = ''\n      \n      while (true) {\n        const { done, value } = await reader.read()\n        if (done) break\n        \n        const chunk = decoder.decode(value, { stream: true })\n        const lines = chunk.split('\\n')\n        \n        for (const line of lines) {\n          if (line.startsWith('data: ')) {\n            const data = line.slice(6)\n            if (data === '[DONE]') continue\n            try {\n              const parsed = JSON.parse(data)\n              if (parsed.text) {\n                rewrittenText += parsed.text\n              }\n            } catch {\n              // Ignore parse errors\n            }\n          }\n        }\n      }\n      \n      return jsonResponse({ text: rewrittenText.trim() })\n    } catch (error) {\n      console.error('[AI Rewrite Error]', error)\n      return jsonResponse({ \n        error: error instanceof Error ? error.message : 'Rewrite failed' \n      }, 500)\n    }\n  }\n\n  return jsonResponse({ error: 'Not found' }, 404)\n}\n\n// Helper to fetch published essays as style examples\nasync function fetchStyleExamples(cms: Autoblogger): Promise<string> {\n  try {\n    const publishedPosts = await cms.posts.findPublished()\n    const MAX_STYLE_EXAMPLES = 5\n    const MAX_WORDS_PER_EXAMPLE = 500\n    \n    if (publishedPosts.length > 0) {\n      const examples = publishedPosts\n        .slice(0, MAX_STYLE_EXAMPLES)\n        .map((post: { title: string; subtitle?: string; markdown: string }) => {\n          const words = post.markdown.split(/\\s+/)\n          const truncatedContent = words.length > MAX_WORDS_PER_EXAMPLE\n            ? words.slice(0, MAX_WORDS_PER_EXAMPLE).join(' ') + '...'\n            : post.markdown\n          \n          return `## ${post.title}\n${post.subtitle ? `*${post.subtitle}*\\n` : ''}\n${truncatedContent}`\n        })\n        .join('\\n\\n---\\n\\n')\n      \n      return `The following are examples of the author's published work. Use these to match their voice, tone, and writing style:\n\n${examples}`\n    }\n  } catch (err) {\n    console.error('[AI] Failed to fetch published essays:', err)\n  }\n  return ''\n}\n","import type { AutobloggerServer as Autoblogger, Session } from '../server'\nimport { jsonResponse, requireAuth } from './utils'\n\ntype NextRequest = Request & { nextUrl: URL }\n\nexport async function handleUploadAPI(\n  req: NextRequest,\n  cms: Autoblogger,\n  session: Session | null\n): Promise<Response> {\n  if (req.method !== 'POST') {\n    return jsonResponse({ error: 'Method not allowed' }, 405)\n  }\n  \n  const authError = requireAuth(session)\n  if (authError) return authError\n  \n  if (!cms.config.storage?.upload) {\n    return jsonResponse({ \n      error: 'Image uploads not configured. Add storage.upload to your autoblogger config.' \n    }, 400)\n  }\n\n  try {\n    const formData = await req.formData()\n    // Support both 'image' (toolbar uploads) and 'file' (general uploads) field names\n    const file = (formData.get('image') || formData.get('file')) as File\n    \n    if (!file) {\n      return jsonResponse({ error: 'No file provided' }, 400)\n    }\n    \n    // Validate file type\n    const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp']\n    if (!allowedTypes.includes(file.type)) {\n      return jsonResponse({ \n        error: 'Invalid file type. Allowed: JPEG, PNG, GIF, WebP' \n      }, 400)\n    }\n    \n    // Validate file size (4MB max)\n    const maxSize = 4 * 1024 * 1024\n    if (file.size > maxSize) {\n      return jsonResponse({ error: 'File too large. Maximum size: 4MB' }, 400)\n    }\n    \n    const result = await cms.config.storage.upload(file)\n    return jsonResponse({ data: result })\n  } catch (error) {\n    return jsonResponse({ \n      error: error instanceof Error ? error.message : 'Upload failed' \n    }, 500)\n  }\n}\n","import type { AutobloggerServer as Autoblogger, Session } from '../server'\nimport { jsonResponse, parsePath, requireAdmin } from './utils'\n\ntype NextRequest = Request & { nextUrl: URL }\n\nexport async function handleTopicsAPI(\n  req: NextRequest,\n  cms: Autoblogger,\n  session: Session | null,\n  path: string,\n  onMutate?: (type: string, data: unknown) => Promise<void>\n): Promise<Response> {\n  const method = req.method\n  const { id: topicId, subPath } = parsePath(path)\n\n  // Check admin for all topic operations\n  const authError = requireAdmin(cms, session)\n  if (authError) return authError\n\n  // GET /topics - list topics\n  if (method === 'GET' && !topicId) {\n    const topics = await cms.topics.findAll()\n    return jsonResponse({ data: topics })\n  }\n\n  // GET /topics/:id - get single topic\n  if (method === 'GET' && topicId) {\n    const topic = await cms.topics.findById(topicId)\n    if (!topic) return jsonResponse({ error: 'Topic not found' }, 404)\n    return jsonResponse({ data: topic })\n  }\n\n  // POST /topics/generate - trigger generation for all active topics\n  if (method === 'POST' && path === '/topics/generate') {\n    const results = await cms.autoDraft.run(undefined, true) // skipFrequencyCheck = true for manual trigger\n    return jsonResponse({ \n      data: { \n        success: true, \n        results,\n      } \n    })\n  }\n\n  // POST /topics - create topic\n  if (method === 'POST' && !topicId) {\n    const body = await req.json()\n    const topic = await cms.topics.create(body)\n    if (onMutate) await onMutate('topic', topic)\n    return jsonResponse({ data: topic }, 201)\n  }\n\n  // POST /topics/:id/generate - trigger generation for a specific topic\n  if (method === 'POST' && topicId && subPath === 'generate') {\n    const results = await cms.autoDraft.run(topicId, true) // skipFrequencyCheck = true for manual trigger\n    return jsonResponse({ \n      data: { \n        success: true, \n        results,\n      } \n    })\n  }\n\n  // PATCH /topics/:id - update topic\n  if (method === 'PATCH' && topicId) {\n    const body = await req.json()\n    const topic = await cms.topics.update(topicId, body)\n    return jsonResponse({ data: topic })\n  }\n\n  // DELETE /topics/:id - delete topic\n  if (method === 'DELETE' && topicId) {\n    await cms.topics.delete(topicId)\n    return jsonResponse({ data: { success: true } })\n  }\n\n  return jsonResponse({ error: 'Method not allowed' }, 405)\n}\n","import type { AutobloggerServer, Session } from '../server'\nimport { jsonResponse, parsePath, requireAdmin } from './utils'\n\ntype NextRequest = Request & { nextUrl: URL }\n\n/**\n * Normalize email address (lowercase, trim)\n */\nfunction normalizeEmail(email: string): string {\n  return email.toLowerCase().trim()\n}\n\nexport async function handleUsersAPI(\n  req: NextRequest,\n  cms: AutobloggerServer,\n  session: Session | null,\n  path: string\n): Promise<Response> {\n  const method = req.method\n  const { id: userId } = parsePath(path)\n\n  // All user operations require admin\n  const authError = requireAdmin(cms, session)\n  if (authError) return authError\n\n  // GET /users - list all users\n  if (method === 'GET' && !userId) {\n    const users = await cms.users.findAll()\n    return jsonResponse({ data: users })\n  }\n\n  // GET /users/:id - get single user\n  if (method === 'GET' && userId) {\n    const user = await cms.users.findById(userId)\n    if (!user) return jsonResponse({ error: 'User not found' }, 404)\n    return jsonResponse({ data: user })\n  }\n\n  // POST /users - create user\n  if (method === 'POST') {\n    const body = await req.json()\n    if (!body.email) {\n      return jsonResponse({ error: 'Email required' }, 400)\n    }\n\n    const email = normalizeEmail(body.email)\n    \n    // Check for duplicate email\n    const existing = await cms.users.findByEmail(email)\n    if (existing) {\n      return jsonResponse({ error: 'User with this email already exists' }, 400)\n    }\n\n    const user = await cms.users.create({\n      ...body,\n      email, // Use normalized email\n    })\n    return jsonResponse({ data: user }, 201)\n  }\n\n  // PATCH /users/:id - update user\n  if (method === 'PATCH' && userId) {\n    const body = await req.json()\n    const user = await cms.users.update(userId, body)\n    return jsonResponse({ data: user })\n  }\n\n  // DELETE /users/:id - delete user\n  if (method === 'DELETE' && userId) {\n    await cms.users.delete(userId)\n    return jsonResponse({ data: { success: true } })\n  }\n\n  return jsonResponse({ error: 'Method not allowed' }, 405)\n}\n","import type { AutobloggerServer, Session } from '../server'\nimport { jsonResponse, requireAdmin } from './utils'\n\ntype NextRequest = Request & { nextUrl: URL }\n\nexport async function handleAdminAPI(\n  req: NextRequest,\n  cms: AutobloggerServer,\n  session: Session | null,\n  path: string\n): Promise<Response> {\n  const method = req.method\n\n  // All admin operations require admin role\n  const authError = requireAdmin(cms, session)\n  if (authError) return authError\n\n  // GET /admin/counts - get counts for dashboard\n  if (method === 'GET' && path === '/admin/counts') {\n    const [users, posts, tags, topics] = await Promise.all([\n      cms.users.count(),\n      cms.posts.findAll().then(p => p.length),\n      cms.tags.findAll().then(t => t.length),\n      cms.topics.findAll().then(t => t.length),\n    ])\n    return jsonResponse({ \n      data: { users, posts, tags, topics } \n    })\n  }\n\n  return jsonResponse({ error: 'Not found' }, 404)\n}\n","import type { AutobloggerServer, Session } from '../server'\nimport { jsonResponse, requireAuth, requireAdmin } from './utils'\n\ntype NextRequest = Request & { nextUrl: URL }\n\n// Type for Prismic integration settings\ninterface PrismicSettings {\n  prismicEnabled: boolean\n  prismicRepository: string | null\n  prismicWriteToken: string | null\n  prismicDocumentType: string\n  prismicSyncMode: string\n  prismicLocale: string\n  prismicAutoRename: boolean\n}\n\n// Mask sensitive token for API response\nfunction maskToken(token: string | null): string {\n  if (!token) return ''\n  if (token.length <= 8) return 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢'\n  return token.slice(0, 4) + 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢' + token.slice(-4)\n}\n\nexport async function handleSettingsAPI(\n  req: NextRequest,\n  cms: AutobloggerServer,\n  session: Session | null,\n  path: string\n): Promise<Response> {\n  const method = req.method\n  const prisma = cms.config.prisma as any\n\n  // Check auth\n  const authError = requireAuth(session)\n  if (authError) return authError\n\n  // GET /settings - get general settings\n  if (method === 'GET' && path === '/settings') {\n    // Get autoDraftEnabled from IntegrationSettings\n    const integrationSettings = await prisma.integrationSettings.findUnique({\n      where: { id: 'default' },\n    })\n    \n    return jsonResponse({ \n      data: { \n        autoDraftEnabled: integrationSettings?.autoDraftEnabled ?? false,\n        postUrlPattern: integrationSettings?.postUrlPattern ?? '/e/{slug}',\n      } \n    })\n  }\n\n  // PATCH /settings - update general settings\n  if (method === 'PATCH' && path === '/settings') {\n    // Check admin\n    const adminError = requireAdmin(cms, session)\n    if (adminError) return adminError\n\n    const body = await req.json()\n    \n    // Build update object\n    const updateData: { autoDraftEnabled?: boolean; postUrlPattern?: string } = {}\n    if (typeof body.autoDraftEnabled === 'boolean') {\n      updateData.autoDraftEnabled = body.autoDraftEnabled\n    }\n    if (typeof body.postUrlPattern === 'string') {\n      updateData.postUrlPattern = body.postUrlPattern\n    }\n    \n    // Upsert IntegrationSettings\n    if (Object.keys(updateData).length > 0) {\n      await prisma.integrationSettings.upsert({\n        where: { id: 'default' },\n        create: { id: 'default', ...updateData },\n        update: updateData,\n      })\n    }\n\n    const integrationSettings = await prisma.integrationSettings.findUnique({\n      where: { id: 'default' },\n    })\n\n    return jsonResponse({ \n      data: { \n        autoDraftEnabled: integrationSettings?.autoDraftEnabled ?? false,\n        postUrlPattern: integrationSettings?.postUrlPattern ?? '/e/{slug}',\n      } \n    })\n  }\n\n  // GET /settings/integrations - get integration settings (Prismic, etc.)\n  if (method === 'GET' && path === '/settings/integrations') {\n    const integrationSettings = await prisma.integrationSettings.findUnique({\n      where: { id: 'default' },\n    })\n    \n    // Check for config fallbacks (passed through config from host app)\n    const configRepo = cms.config.prismic?.repository\n    const hasEnvToken = !!cms.config.prismic?.writeToken\n    const hasDbToken = !!integrationSettings?.prismicWriteToken\n    \n    return jsonResponse({ \n      data: { \n        prismic: {\n          enabled: integrationSettings?.prismicEnabled ?? false,\n          repository: integrationSettings?.prismicRepository ?? '',\n          configRepository: configRepo ?? null,\n          writeToken: maskToken(integrationSettings?.prismicWriteToken),\n          hasWriteToken: hasDbToken,\n          hasEnvToken: hasEnvToken,\n          documentType: integrationSettings?.prismicDocumentType ?? 'autoblog',\n          syncMode: integrationSettings?.prismicSyncMode ?? 'stub',\n          locale: integrationSettings?.prismicLocale ?? 'en-us',\n          autoRename: integrationSettings?.prismicAutoRename ?? false,\n        }\n      } \n    })\n  }\n\n  // PATCH /settings/integrations - update integration settings\n  if (method === 'PATCH' && path === '/settings/integrations') {\n    // Check admin\n    const adminError = requireAdmin(cms, session)\n    if (adminError) return adminError\n\n    const body = await req.json()\n    \n    // Build update object for Prismic settings\n    const updateData: Partial<PrismicSettings> = {}\n    \n    if (typeof body.prismicEnabled === 'boolean') {\n      updateData.prismicEnabled = body.prismicEnabled\n    }\n    if (typeof body.prismicRepository === 'string') {\n      updateData.prismicRepository = body.prismicRepository || null\n    }\n    if (typeof body.prismicWriteToken === 'string') {\n      // Only update if not the masked placeholder\n      if (!body.prismicWriteToken.includes('â€¢â€¢â€¢â€¢')) {\n        updateData.prismicWriteToken = body.prismicWriteToken || null\n      }\n    }\n    if (typeof body.prismicDocumentType === 'string') {\n      updateData.prismicDocumentType = body.prismicDocumentType || 'autoblog'\n    }\n    if (typeof body.prismicSyncMode === 'string' && ['stub', 'full'].includes(body.prismicSyncMode)) {\n      updateData.prismicSyncMode = body.prismicSyncMode\n    }\n    if (typeof body.prismicLocale === 'string') {\n      updateData.prismicLocale = body.prismicLocale || 'en-us'\n    }\n    if (typeof body.prismicAutoRename === 'boolean') {\n      updateData.prismicAutoRename = body.prismicAutoRename\n    }\n\n    // Validate: if enabling, repository and write token are required (env var counts as token)\n    if (updateData.prismicEnabled === true) {\n      const current = await prisma.integrationSettings.findUnique({\n        where: { id: 'default' },\n      })\n      \n      const repo = updateData.prismicRepository ?? current?.prismicRepository\n      const hasDbToken = !!(updateData.prismicWriteToken ?? current?.prismicWriteToken)\n      const hasEnvToken = !!cms.config.prismic?.writeToken\n      \n      if (!repo) {\n        return jsonResponse({ error: 'Repository name is required to enable Prismic' }, 400)\n      }\n      if (!hasDbToken && !hasEnvToken) {\n        return jsonResponse({ error: 'Write token is required to enable Prismic (set PRISMIC_WRITE_TOKEN in config or enter in field)' }, 400)\n      }\n    }\n    \n    // Upsert IntegrationSettings\n    if (Object.keys(updateData).length > 0) {\n      await prisma.integrationSettings.upsert({\n        where: { id: 'default' },\n        create: { id: 'default', ...updateData },\n        update: updateData,\n      })\n    }\n\n    const integrationSettings = await prisma.integrationSettings.findUnique({\n      where: { id: 'default' },\n    })\n\n    return jsonResponse({ \n      data: { \n        prismic: {\n          enabled: integrationSettings?.prismicEnabled ?? false,\n          repository: integrationSettings?.prismicRepository ?? '',\n          writeToken: maskToken(integrationSettings?.prismicWriteToken),\n          hasWriteToken: !!integrationSettings?.prismicWriteToken,\n          documentType: integrationSettings?.prismicDocumentType ?? 'autoblog',\n          syncMode: integrationSettings?.prismicSyncMode ?? 'stub',\n          locale: integrationSettings?.prismicLocale ?? 'en-us',\n          autoRename: integrationSettings?.prismicAutoRename ?? false,\n        }\n      } \n    })\n  }\n\n  return jsonResponse({ error: 'Not found' }, 404)\n}\n","import type { AutobloggerServer as Autoblogger, Session } from '../server'\nimport { jsonResponse, parsePath, requireAdmin } from './utils'\n\ntype NextRequest = Request & { nextUrl: URL }\n\nexport async function handleRevisionsAPI(\n  req: NextRequest,\n  cms: Autoblogger,\n  session: Session | null,\n  path: string,\n  onMutate?: (type: string, data: unknown) => Promise<void>\n): Promise<Response> {\n  const method = req.method\n  const url = new URL(req.url)\n  const { id: revisionId, subPath } = parsePath(path)\n\n  // GET /revisions - list all revisions (paginated)\n  if (method === 'GET' && !revisionId) {\n    const page = parseInt(url.searchParams.get('page') || '1')\n    const limit = parseInt(url.searchParams.get('limit') || '25')\n    const postId = url.searchParams.get('postId')\n\n    const where = postId ? { postId } : {}\n    \n    const [revisions, total] = await Promise.all([\n      cms.revisions.findAll({ ...where, skip: (page - 1) * limit, take: limit }),\n      cms.revisions.count(where),\n    ])\n\n    return jsonResponse({\n      data: revisions,\n      total,\n      page,\n      totalPages: Math.ceil(total / limit),\n    })\n  }\n\n  // GET /revisions/:id - get single revision\n  if (method === 'GET' && revisionId) {\n    const revision = await cms.revisions.findById(revisionId)\n    if (!revision) return jsonResponse({ error: 'Revision not found' }, 404)\n    return jsonResponse({ data: revision })\n  }\n\n  // POST /revisions/:id/restore - restore a revision\n  if (method === 'POST' && revisionId && subPath === 'restore') {\n    const authError = requireAdmin(cms, session)\n    if (authError) return authError\n\n    const post = await cms.revisions.restore(revisionId)\n    if (onMutate) await onMutate('post', post)\n    return jsonResponse({ data: post })\n  }\n\n  // DELETE /revisions/:id - delete a revision\n  if (method === 'DELETE' && revisionId) {\n    const authError = requireAdmin(cms, session)\n    if (authError) return authError\n\n    await cms.revisions.delete(revisionId)\n    return jsonResponse({ data: { success: true } })\n  }\n\n  return jsonResponse({ error: 'Method not allowed' }, 405)\n}\n","import type { PrismaClient } from '@prisma/client'\n\ninterface ChatHistoryRequest {\n  role: 'user' | 'assistant'\n  content: string\n}\n\n/**\n * Handle chat history API requests.\n * GET - Fetch recent messages\n * POST - Save a new message\n * DELETE - Clear all messages\n */\nexport async function handleChatHistoryAPI(\n  req: Request,\n  prisma: PrismaClient,\n  isAuthenticated: boolean\n): Promise<Response> {\n  // Require authentication\n  if (!isAuthenticated) {\n    return new Response(JSON.stringify({ error: 'Unauthorized' }), {\n      status: 401,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  }\n\n  const method = req.method\n\n  // Check if ChatMessage model exists\n  const hasChatMessage = !!(prisma as any).chatMessage\n\n  try {\n    // GET - Fetch recent messages\n    if (method === 'GET') {\n      if (!hasChatMessage) {\n        return new Response(JSON.stringify([]), {\n          status: 200,\n          headers: { 'Content-Type': 'application/json' },\n        })\n      }\n      \n      const messages = await (prisma as any).chatMessage.findMany({\n        orderBy: { createdAt: 'desc' },\n        take: 50,\n      })\n      \n      // Return in chronological order\n      return new Response(JSON.stringify(messages.reverse()), {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      })\n    }\n\n    // POST - Save a new message\n    if (method === 'POST') {\n      if (!hasChatMessage) {\n        // Silently succeed - chat still works, just not persisted\n        return new Response(JSON.stringify({ id: 'temp', role: 'user', content: '' }), {\n          status: 201,\n          headers: { 'Content-Type': 'application/json' },\n        })\n      }\n\n      const body: ChatHistoryRequest = await req.json()\n      \n      if (!body.role || !body.content) {\n        return new Response(JSON.stringify({ error: 'Missing role or content' }), {\n          status: 400,\n          headers: { 'Content-Type': 'application/json' },\n        })\n      }\n\n      const message = await (prisma as any).chatMessage.create({\n        data: {\n          role: body.role,\n          content: body.content,\n        },\n      })\n\n      return new Response(JSON.stringify(message), {\n        status: 201,\n        headers: { 'Content-Type': 'application/json' },\n      })\n    }\n\n    // DELETE - Clear all messages\n    if (method === 'DELETE') {\n      if (!hasChatMessage) {\n        return new Response(JSON.stringify({ success: true }), {\n          status: 200,\n          headers: { 'Content-Type': 'application/json' },\n        })\n      }\n\n      await (prisma as any).chatMessage.deleteMany({})\n      \n      return new Response(JSON.stringify({ success: true }), {\n        status: 200,\n        headers: { 'Content-Type': 'application/json' },\n      })\n    }\n\n    return new Response(JSON.stringify({ error: 'Method not allowed' }), {\n      status: 405,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  } catch (error) {\n    console.error('[Chat History API Error]', error)\n    return new Response(JSON.stringify({ error: 'Internal server error' }), {\n      status: 500,\n      headers: { 'Content-Type': 'application/json' },\n    })\n  }\n}\n","import type { AutobloggerServer, Session } from '../server'\nimport { handlePostsAPI } from './posts'\nimport { handleCommentsAPI } from './comments'\nimport { handleTagsAPI } from './tags'\nimport { handleAIAPI } from './ai'\nimport { handleUploadAPI } from './upload'\nimport { handleTopicsAPI } from './topics'\nimport { handleUsersAPI } from './users'\nimport { handleAdminAPI } from './admin'\nimport { handleSettingsAPI } from './settings'\nimport { handleRevisionsAPI } from './revisions'\nimport { handleChatHistoryAPI } from './chat-history'\n\ninterface APIHandlerOptions {\n  basePath?: string\n  onMutate?: (type: string, data: unknown) => Promise<void>\n}\n\ntype NextRequest = Request & { nextUrl: URL }\n\nfunction extractPath(pathname: string, basePath: string): string {\n  const normalized = pathname.replace(/\\/$/, '')\n  const base = basePath.replace(/\\/$/, '')\n  \n  if (normalized === base) return '/'\n  if (normalized.startsWith(base + '/')) {\n    return normalized.slice(base.length)\n  }\n  return '/'\n}\n\nfunction jsonResponse(data: unknown, status = 200) {\n  return new Response(JSON.stringify(data), {\n    status,\n    headers: { 'Content-Type': 'application/json' },\n  })\n}\n\nexport function createAPIHandler(cms: AutobloggerServer, options: APIHandlerOptions = {}) {\n  const basePath = options.basePath || '/api/cms'\n  \n  return async (req: NextRequest): Promise<Response> => {\n    const path = extractPath(req.nextUrl.pathname, basePath)\n    const method = req.method\n    \n    // Get session for auth\n    let session: Session | null = null\n    try {\n      session = await cms.config.auth.getSession()\n    } catch {\n      // Session retrieval failed\n    }\n    \n    // Check auth for protected routes\n    const isPublicRoute = path.startsWith('/posts') && method === 'GET'\n    if (!isPublicRoute && !session) {\n      return jsonResponse({ error: 'Unauthorized' }, 401)\n    }\n    \n    try {\n      // Route to handlers\n      if (path.startsWith('/posts')) {\n        return handlePostsAPI(req, cms, session, path, options.onMutate)\n      }\n      \n      if (path.startsWith('/comments')) {\n        return handleCommentsAPI(req, cms, session, path, options.onMutate)\n      }\n      \n      if (path.startsWith('/tags')) {\n        return handleTagsAPI(req, cms, session, path, options.onMutate)\n      }\n      \n      if (path.startsWith('/ai')) {\n        return handleAIAPI(req, cms, session, path)\n      }\n      \n      if (path.startsWith('/upload')) {\n        return handleUploadAPI(req, cms, session)\n      }\n      \n      if (path.startsWith('/topics')) {\n        return handleTopicsAPI(req, cms, session, path, options.onMutate)\n      }\n      \n      if (path.startsWith('/users')) {\n        return handleUsersAPI(req, cms, session, path)\n      }\n      \n      if (path.startsWith('/admin')) {\n        return handleAdminAPI(req, cms, session, path)\n      }\n      \n      if (path.startsWith('/settings')) {\n        return handleSettingsAPI(req, cms, session, path)\n      }\n      \n      if (path.startsWith('/revisions')) {\n        return handleRevisionsAPI(req, cms, session, path, options.onMutate)\n      }\n      \n      if (path.startsWith('/chat/history')) {\n        return handleChatHistoryAPI(req, cms.config.prisma as any, !!session)\n      }\n      \n      return jsonResponse({ error: 'Not found' }, 404)\n    } catch (error) {\n      console.error('API error:', error)\n      return jsonResponse({ \n        error: error instanceof Error ? error.message : 'Internal server error' \n      }, 500)\n    }\n  }\n}\n\nexport { handlePostsAPI } from './posts'\nexport { handleCommentsAPI } from './comments'\nexport { handleTagsAPI } from './tags'\nexport { handleAIAPI } from './ai'\nexport { handleUploadAPI } from './upload'\nexport { handleTopicsAPI } from './topics'\nexport { handleUsersAPI } from './users'\nexport { handleAdminAPI } from './admin'\nexport { handleSettingsAPI } from './settings'\nexport { handleRevisionsAPI } from './revisions'\nexport { handleChatHistoryAPI } from './chat-history'\n","import Parser from 'rss-parser'\n\nexport interface RssArticle {\n  title: string\n  url: string\n  summary: string | null\n  publishedAt: Date | null\n}\n\nconst parser = new Parser({\n  timeout: 10000,\n  headers: {\n    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n  },\n})\n\n/**\n * Fetch and parse multiple RSS feeds, combining all articles.\n */\nexport async function fetchRssFeeds(feedUrls: string[]): Promise<RssArticle[]> {\n  const articles: RssArticle[] = []\n\n  for (const url of feedUrls) {\n    try {\n      const feed = await parser.parseURL(url)\n      \n      for (const item of feed.items) {\n        if (!item.title || !item.link) continue\n        \n        articles.push({\n          title: item.title,\n          url: item.link,\n          summary: item.contentSnippet || item.content || null,\n          publishedAt: item.pubDate ? new Date(item.pubDate) : null,\n        })\n      }\n    } catch (error) {\n      console.error(`Failed to fetch RSS feed: ${url}`, error)\n      // Continue with other feeds\n    }\n  }\n\n  return articles\n}\n","import type { RssArticle } from './rss'\n\n/**\n * Filter articles by keyword matching.\n * Case-insensitive substring match on title and summary.\n */\nexport function filterByKeywords(\n  articles: RssArticle[],\n  keywords: string[]\n): RssArticle[] {\n  if (keywords.length === 0) return articles\n\n  const lowerKeywords = keywords.map(k => k.toLowerCase().trim())\n\n  return articles.filter(article => {\n    const searchText = `${article.title} ${article.summary || ''}`.toLowerCase()\n    return lowerKeywords.some(keyword => searchText.includes(keyword))\n  })\n}\n","// Models\nexport { \n  AI_MODELS, \n  getModel, \n  getDefaultModel,\n  modelHasNativeSearch,\n  getSearchModel,\n  resolveModel,\n  getModelOptions,\n  toModelOption,\n  LENGTH_OPTIONS,\n} from './models'\nexport type { AIModel, AIModelOption, ModelId, LengthOption } from './models'\n\n// Provider\nexport { createStream, generate, getApiKey } from './provider'\nexport type { ChatMessage } from './provider'\n\n// Generate\nexport { generateStream, expandPlanStream } from './generate'\n\n// Chat\nexport { chatStream } from './chat'\n\n// Builders\nexport { \n  buildGeneratePrompt, \n  buildChatPrompt, \n  buildExpandPlanPrompt, \n  buildPlanPrompt, \n  buildRewritePrompt, \n  buildAutoDraftPrompt \n} from './builders'\n\n// Prompts\nexport {\n  DEFAULT_GENERATE_TEMPLATE,\n  DEFAULT_CHAT_TEMPLATE,\n  DEFAULT_REWRITE_TEMPLATE,\n  DEFAULT_AUTO_DRAFT_TEMPLATE,\n  DEFAULT_PLAN_TEMPLATE,\n  DEFAULT_PLAN_RULES,\n  DEFAULT_EXPAND_PLAN_TEMPLATE,\n  DEFAULT_AGENT_TEMPLATE,\n  DEFAULT_SEARCH_ONLY_PROMPT,\n  buildSearchOnlyPrompt,\n  buildPlanPrompt as buildPlanPromptFromPrompts,\n  buildChatPrompt as buildChatPromptFromPrompts,\n  buildAgentChatPrompt,\n  buildGeneratePrompt as buildGeneratePromptFromPrompts,\n  buildRewritePrompt as buildRewritePromptFromPrompts,\n  buildExpandPlanPrompt as buildExpandPlanPromptFromPrompts,\n} from './prompts'\nexport type { EssayContext, StyleContext } from './prompts'// Parse\nexport { parseGeneratedContent } from './parse'","/**\n * Parse AI-generated markdown to extract title, subtitle, and body.\n * \n * Expects format:\n * # Title\n * *Subtitle*\n * \n * Body content...\n */\nexport function parseGeneratedContent(markdown: string): {\n  title: string\n  subtitle: string\n  body: string\n} {\n  const lines = markdown.trim().split('\\n')\n  let title = ''\n  let subtitle = ''\n  let bodyStartIndex = 0\n\n  // Look for H1 title at the start\n  if (lines[0]?.startsWith('# ')) {\n    title = lines[0].replace(/^#\\s+/, '').trim()\n    bodyStartIndex = 1\n  }\n\n  // Look for italic subtitle (next non-empty line starting with * and ending with *)\n  for (let i = bodyStartIndex; i < lines.length; i++) {\n    const line = lines[i].trim()\n    if (line === '') continue // skip empty lines\n\n    // Check for italic subtitle: *text* or _text_\n    const italicMatch = line.match(/^\\*(.+)\\*$/) || line.match(/^_(.+)_$/)\n    if (italicMatch) {\n      subtitle = italicMatch[1].trim()\n      bodyStartIndex = i + 1\n    }\n    break // stop after first non-empty line (whether it's subtitle or not)\n  }\n\n  // Skip any leading empty lines after title/subtitle\n  while (bodyStartIndex < lines.length && lines[bodyStartIndex].trim() === '') {\n    bodyStartIndex++\n  }\n\n  const body = lines.slice(bodyStartIndex).join('\\n').trim()\n\n  return { title, subtitle, body }\n}\n","import { marked } from 'marked'\nimport TurndownService from 'turndown'\n\n// Configure marked for consistent rendering\nmarked.setOptions({\n  gfm: true,\n  breaks: false,\n})\n\n/**\n * Render markdown to HTML\n */\nexport function renderMarkdown(markdown: string): string {\n  return marked.parse(markdown) as string\n}\n\n/**\n * Convert markdown to HTML with GFM and line breaks enabled.\n * Safe for client-side use in components like ChatPanel.\n */\nexport function markdownToHtml(markdown: string): string {\n  return marked.parse(markdown, { gfm: true, breaks: true }) as string\n}\n\n/**\n * @deprecated Use markdownToHtml with Tailwind Typography prose classes instead.\n * Kept for backwards compatibility.\n */\nexport function markdownToStyledHtml(markdown: string): string {\n  return markdownToHtml(markdown)\n}\n\n/**\n * Parse markdown to tokens (AST)\n */\nexport function parseMarkdown(markdown: string) {\n  return marked.lexer(markdown)\n}\n\n// Configure Turndown for HTML to markdown conversion\nconst turndownService = new TurndownService({\n  headingStyle: 'atx',\n  codeBlockStyle: 'fenced',\n  bulletListMarker: '-',\n})\n\n// Add strikethrough support (GFM extension)\nturndownService.addRule('strikethrough', {\n  filter: (node: HTMLElement) => {\n    const tagName = node.nodeName.toLowerCase()\n    return tagName === 'del' || tagName === 's' || tagName === 'strike'\n  },\n  replacement: (content) => `~~${content}~~`\n})\n\n/**\n * Convert HTML to markdown\n */\nexport function htmlToMarkdown(html: string): string {\n  return turndownService.turndown(html)\n}\n\n/**\n * Count words in text (markdown or plain text)\n */\nexport function wordCount(text: string): number {\n  if (!text) return 0\n  return text.trim().split(/\\s+/).filter(Boolean).length\n}\n\n/**\n * Generate URL-safe slug from title\n */\nexport function generateSlug(title: string): string {\n  return title\n    .toLowerCase()\n    .trim()\n    .replace(/[^\\w\\s-]/g, '')\n    .replace(/\\s+/g, '-')\n    .replace(/-+/g, '-')\n    .substring(0, 60)\n}\n\nimport sanitizeHtml from 'sanitize-html'\n\n/**\n * Render markdown to sanitized HTML.\n * Safe for public-facing pages where user content is displayed.\n */\nexport function renderMarkdownSanitized(markdown: string): string {\n  const html = renderMarkdown(markdown)\n  return sanitizeHtml(html, {\n    allowedTags: sanitizeHtml.defaults.allowedTags.concat(['img', 'h1', 'h2']),\n    allowedAttributes: {\n      ...sanitizeHtml.defaults.allowedAttributes,\n      img: ['src', 'alt', 'title'],\n      a: ['href', 'target', 'rel'],\n    },\n  })\n}\n","import { generate, resolveModel, buildAutoDraftPrompt, parseGeneratedContent } from '../ai'\nimport { generateSlug } from '../lib/markdown'\nimport { fetchRssFeeds, type RssArticle } from './rss'\nimport { filterByKeywords } from './keywords'\nimport { PostStatus } from '../types/models'\n\nexport interface GenerationResult {\n  topicId: string\n  topicName: string\n  generated: number\n  skipped: number\n}\n\nexport interface AutoDraftConfig {\n  prisma: any\n  anthropicKey?: string\n  openaiKey?: string\n  /** Called after generating an essay, before creating the post. Return additional post fields. */\n  onPostCreate?: (article: RssArticle, essay: { title: string; subtitle: string | null; markdown: string }) => Record<string, unknown> | Promise<Record<string, unknown>>\n}\n\n/**\n * Get style context from the database for AI generation.\n */\nasync function getStyleContext(prisma: any) {\n  const settings = await prisma.aISettings.findUnique({ where: { id: 'default' } })\n  const posts = await prisma.post.findMany({\n    where: { status: PostStatus.PUBLISHED },\n    select: { title: true, subtitle: true, markdown: true },\n    orderBy: { publishedAt: 'desc' },\n    take: 10,\n  })\n  \n  const styleExamples = posts\n    .map((p: { title: string; subtitle?: string; markdown: string }) => \n      `# ${p.title}\\n${p.subtitle ? `*${p.subtitle}*\\n\\n` : ''}${p.markdown}`\n    )\n    .join('\\n\\n---\\n\\n')\n  \n  return {\n    rules: settings?.rules || '',\n    autoDraftRules: settings?.autoDraftRules || '',\n    styleExamples,\n  }\n}\n\n/**\n * Check if a topic should run based on its frequency and lastRunAt.\n */\nfunction shouldRunTopic(topic: { frequency: string; lastRunAt: Date | null }): boolean {\n  if (topic.frequency === 'manual') return false\n  if (!topic.lastRunAt) return true\n\n  const now = new Date()\n  const lastRun = new Date(topic.lastRunAt)\n  const hoursSinceLastRun = (now.getTime() - lastRun.getTime()) / (1000 * 60 * 60)\n\n  if (topic.frequency === 'daily') return hoursSinceLastRun >= 23\n  if (topic.frequency === 'weekly') return hoursSinceLastRun >= 167 // ~7 days\n  \n  return true\n}\n\n/**\n * Deduplicate articles against existing NewsItems (global, across all topics).\n */\nasync function deduplicateArticles(\n  prisma: any,\n  articles: RssArticle[]\n): Promise<RssArticle[]> {\n  const articleUrls = articles.map(a => a.url)\n  const existingUrls = await prisma.newsItem.findMany({\n    where: { url: { in: articleUrls } },\n    select: { url: true },\n  })\n  \n  const urlSet = new Set(existingUrls.map((n: { url: string }) => n.url))\n  return articles.filter(a => !urlSet.has(a.url))\n}\n\n/**\n * Generate a unique slug for a post.\n * If the slug already exists, appends -2, -3, etc.\n */\nasync function generateUniqueSlug(prisma: any, title: string): Promise<string> {\n  const baseSlug = generateSlug(title)\n  \n  // Check if base slug is available\n  const existing = await prisma.post.findUnique({ where: { slug: baseSlug } })\n  if (!existing) return baseSlug\n\n  // Find next available suffix\n  let suffix = 2\n  while (suffix < 100) {\n    const candidateSlug = `${baseSlug}-${suffix}`\n    const exists = await prisma.post.findUnique({ where: { slug: candidateSlug } })\n    if (!exists) return candidateSlug\n    suffix++\n  }\n\n  // Fallback: add random suffix\n  return `${baseSlug}-${Date.now()}`\n}\n\n/**\n * Generate an essay from an article using AI.\n */\nasync function generateEssayFromArticle(\n  config: AutoDraftConfig,\n  article: RssArticle,\n  topicName: string,\n  essayFocus?: string | null\n): Promise<{ title: string; subtitle: string | null; markdown: string }> {\n  const context = await getStyleContext(config.prisma)\n  \n  const systemPrompt = buildAutoDraftPrompt({\n    autoDraftRules: context.autoDraftRules,\n    rules: context.rules,\n    wordCount: 800,\n    styleExamples: context.styleExamples,\n    topicName: topicName,\n    articleTitle: article.title,\n    articleSummary: article.summary || '',\n    articleUrl: article.url,\n  })\n  \n  // Resolve the default model\n  const model = await resolveModel(undefined, async () => {\n    const settings = await config.prisma.aISettings.findUnique({ where: { id: 'default' } })\n    return settings?.defaultModel || null\n  })\n\n  // User prompt is minimal since all instructions are in the system prompt\n  const userPrompt = essayFocus \n    ? `Write the essay now. Focus on: ${essayFocus}`\n    : 'Write the essay now.'\n  \n  const result = await generate(model.id, systemPrompt, userPrompt, {\n    maxTokens: 4096,\n    anthropicKey: config.anthropicKey,\n    openaiKey: config.openaiKey,\n  })\n  const parsed = parseGeneratedContent(result.text)\n\n  return {\n    title: parsed.title || article.title,\n    subtitle: parsed.subtitle || null,\n    markdown: parsed.body,\n  }\n}\n\n/**\n * Run auto-draft for one or all active topics.\n * @param config - Configuration including prisma client and API keys\n * @param topicId - Optional: run for a specific topic only\n * @param skipFrequencyCheck - If true, ignore frequency settings (for manual trigger)\n */\nexport async function runAutoDraft(\n  config: AutoDraftConfig,\n  topicId?: string,\n  skipFrequencyCheck = false\n): Promise<GenerationResult[]> {\n  const { prisma } = config\n\n  // Check master toggle first\n  const integrationSettings = await prisma.integrationSettings.findUnique({\n    where: { id: 'default' },\n  }) as { autoDraftEnabled?: boolean } | null\n  if (!integrationSettings?.autoDraftEnabled) {\n    console.log('Auto-draft is disabled. Skipping.')\n    return []\n  }\n\n  const topics = topicId\n    ? await prisma.topicSubscription.findMany({ where: { id: topicId, isActive: true } })\n    : await prisma.topicSubscription.findMany({ where: { isActive: true } })\n\n  const results: GenerationResult[] = []\n\n  for (const topic of topics) {\n    // Skip if frequency check applies and topic shouldn't run\n    if (!skipFrequencyCheck && !shouldRunTopic(topic)) {\n      continue\n    }\n\n    try {\n      // 1. Fetch RSS feeds\n      const feedUrls: string[] = JSON.parse(topic.rssFeeds)\n      const articles = await fetchRssFeeds(feedUrls)\n\n      // 2. Filter by keywords (if enabled)\n      const keywords: string[] = JSON.parse(topic.keywords)\n      const relevant = topic.useKeywordFilter\n        ? filterByKeywords(articles, keywords)\n        : articles\n\n      // 3. Deduplicate (skip URLs already processed globally)\n      const newArticles = await deduplicateArticles(prisma, relevant)\n\n      // 4. Generate essays (up to maxPerPeriod)\n      const toGenerate = newArticles.slice(0, topic.maxPerPeriod)\n      let generated = 0\n\n      for (const article of toGenerate) {\n        try {\n          // Create NewsItem first\n          const newsItem = await prisma.newsItem.create({\n            data: {\n              topicId: topic.id,\n              url: article.url,\n              title: article.title,\n              summary: article.summary,\n              publishedAt: article.publishedAt,\n              status: 'pending',\n            },\n          })\n\n          // Generate essay with AI\n          const essay = await generateEssayFromArticle(config, article, topic.name, topic.essayFocus)\n\n          // Generate unique slug\n          const slug = await generateUniqueSlug(prisma, essay.title)\n\n          // Get additional fields from hook (e.g., polyhedraShape)\n          const extraFields = config.onPostCreate \n            ? await config.onPostCreate(article, essay)\n            : {}\n\n          // Create suggested post\n          const post = await prisma.post.create({\n            data: {\n              title: essay.title,\n              subtitle: essay.subtitle,\n              slug,\n              markdown: essay.markdown,\n              status: PostStatus.SUGGESTED,\n              sourceUrl: article.url,\n              topicId: topic.id,\n              ...extraFields,\n            },\n          })\n\n          // Link NewsItem to Post\n          await prisma.newsItem.update({\n            where: { id: newsItem.id },\n            data: { postId: post.id, status: 'generated' },\n          })\n\n          generated++\n        } catch (articleError) {\n          console.error(`Failed to process article: ${article.title}`, articleError)\n          // Continue with other articles\n        }\n      }\n\n      // 5. Update lastRunAt\n      await prisma.topicSubscription.update({\n        where: { id: topic.id },\n        data: { lastRunAt: new Date() },\n      })\n\n      results.push({\n        topicId: topic.id,\n        topicName: topic.name,\n        generated,\n        skipped: relevant.length - generated,\n      })\n    } catch (topicError) {\n      console.error(`Failed to process topic: ${topic.name}`, topicError)\n      results.push({\n        topicId: topic.id,\n        topicName: topic.name,\n        generated: 0,\n        skipped: 0,\n      })\n    }\n  }\n\n  return results\n}\n","import type { Post } from '../types/models'\nimport type { Destination, DestinationResult, DestinationEvent, DispatchResult } from '../types/destinations'\n\nexport interface DispatcherConfig {\n  destinations?: Destination[]\n  webhooks?: string[]\n  onPublish?: (post: Post) => Promise<void>\n  onUnpublish?: (post: Post) => Promise<void>\n  onDelete?: (post: Post) => Promise<void>\n}\n\n/**\n * Creates a destination dispatcher that fires events to adapters, webhooks, and callbacks.\n */\nexport function createDestinationDispatcher(config: DispatcherConfig) {\n  const { destinations = [], webhooks = [], onPublish, onUnpublish, onDelete } = config\n\n  /**\n   * Fire a webhook with the event payload\n   */\n  async function fireWebhook(\n    url: string,\n    event: DestinationEvent\n  ): Promise<{ url: string; success: boolean; error?: string }> {\n    try {\n      const response = await fetch(url, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(event),\n      })\n\n      if (!response.ok) {\n        return {\n          url,\n          success: false,\n          error: `HTTP ${response.status}: ${response.statusText}`,\n        }\n      }\n\n      return { url, success: true }\n    } catch (error) {\n      return {\n        url,\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error',\n      }\n    }\n  }\n\n  /**\n   * Fire a destination adapter\n   */\n  async function fireDestination(\n    destination: Destination,\n    method: 'onPublish' | 'onUnpublish' | 'onDelete',\n    post: Post\n  ): Promise<{ name: string; result: DestinationResult }> {\n    try {\n      const result = await destination[method](post)\n      return { name: destination.name, result }\n    } catch (error) {\n      return {\n        name: destination.name,\n        result: {\n          success: false,\n          error: error instanceof Error ? error.message : 'Unknown error',\n        },\n      }\n    }\n  }\n\n  /**\n   * Dispatch an event to all destinations, webhooks, and callbacks\n   */\n  async function dispatch(\n    type: 'publish' | 'unpublish' | 'delete',\n    post: Post,\n    callback?: (post: Post) => Promise<void>\n  ): Promise<DispatchResult> {\n    const event: DestinationEvent = {\n      type,\n      post,\n      timestamp: new Date().toISOString(),\n    }\n\n    const method = type === 'publish' ? 'onPublish' : type === 'unpublish' ? 'onUnpublish' : 'onDelete'\n\n    // Fire all destinations in parallel\n    const destinationPromises = destinations.map((dest) => fireDestination(dest, method, post))\n\n    // Fire all webhooks in parallel\n    const webhookPromises = webhooks.map((url) => fireWebhook(url, event))\n\n    // Fire the callback (if provided)\n    const callbackPromise = callback ? callback(post).catch((err) => {\n      console.error(`[autoblogger] ${type} callback error:`, err)\n    }) : Promise.resolve()\n\n    // Wait for all to complete\n    const [destinationResults, webhookResults] = await Promise.all([\n      Promise.all(destinationPromises),\n      Promise.all(webhookPromises),\n      callbackPromise,\n    ])\n\n    // Check if all succeeded\n    const allSucceeded =\n      destinationResults.every((r) => r.result.success) &&\n      webhookResults.every((r) => r.success)\n\n    // Log any failures\n    for (const { name, result } of destinationResults) {\n      if (!result.success) {\n        console.error(`[autoblogger] Destination \"${name}\" failed:`, result.error)\n      }\n    }\n    for (const { url, success, error } of webhookResults) {\n      if (!success) {\n        console.error(`[autoblogger] Webhook \"${url}\" failed:`, error)\n      }\n    }\n\n    return {\n      destinations: destinationResults,\n      webhooks: webhookResults,\n      allSucceeded,\n    }\n  }\n\n  return {\n    /**\n     * Dispatch a publish event to all destinations\n     */\n    async publish(post: Post): Promise<DispatchResult> {\n      return dispatch('publish', post, onPublish)\n    },\n\n    /**\n     * Dispatch an unpublish event to all destinations\n     */\n    async unpublish(post: Post): Promise<DispatchResult> {\n      return dispatch('unpublish', post, onUnpublish)\n    },\n\n    /**\n     * Dispatch a delete event to all destinations\n     */\n    async delete(post: Post): Promise<DispatchResult> {\n      return dispatch('delete', post, onDelete)\n    },\n\n    /**\n     * Check if any destinations or webhooks are configured\n     */\n    get hasDestinations(): boolean {\n      return destinations.length > 0 || webhooks.length > 0 || !!onPublish || !!onUnpublish || !!onDelete\n    },\n  }\n}\n\nexport type DestinationDispatcher = ReturnType<typeof createDestinationDispatcher>\n","/**\n * Built-in storage module for autoblogger.\n * Auto-detects cloud storage or falls back to local filesystem.\n * \n * Supported providers (auto-detected from env vars):\n * - Vercel Blob (set BLOB_READ_WRITE_TOKEN) - best for Vercel deployments\n * - DigitalOcean Spaces (set SPACES_KEY, SPACES_SECRET) - best for DO deployments\n * - AWS S3 (set AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_S3_BUCKET)\n * - Local filesystem (no config needed, saves to public/uploads) - for development\n */\n\nimport { writeFile, mkdir } from 'fs/promises'\nimport { join } from 'path'\nimport { randomUUID } from 'crypto'\n\nexport interface UploadResult {\n  url: string\n  key: string\n}\n\nexport interface StorageConfig {\n  // Vercel Blob storage\n  vercelBlob?: {\n    token: string\n  }\n  // S3-compatible storage (DigitalOcean Spaces, AWS S3, etc.)\n  s3?: {\n    accessKeyId: string\n    secretAccessKey: string\n    bucket: string\n    region?: string\n    endpoint?: string\n    cdnEndpoint?: string\n  }\n  // Local storage config\n  local?: {\n    uploadDir?: string // defaults to 'public/uploads'\n    urlPrefix?: string // defaults to '/uploads'\n  }\n}\n\n// Lazy-loaded S3 client\nlet s3ClientPromise: Promise<any> | null = null\n\nasync function getS3Client(config: NonNullable<StorageConfig['s3']>) {\n  if (!s3ClientPromise) {\n    s3ClientPromise = (async () => {\n      // Dynamic import to avoid requiring @aws-sdk/client-s3 if not using S3\n      // eslint-disable-next-line @typescript-eslint/no-require-imports\n      const { S3Client } = await (Function('return import(\"@aws-sdk/client-s3\")')() as Promise<any>)\n      return new S3Client({\n        region: config.region || 'us-east-1',\n        endpoint: config.endpoint,\n        credentials: {\n          accessKeyId: config.accessKeyId,\n          secretAccessKey: config.secretAccessKey,\n        },\n      })\n    })()\n  }\n  return s3ClientPromise\n}\n\n/**\n * Upload to Vercel Blob storage\n */\nasync function uploadToVercelBlob(\n  buffer: Buffer,\n  filename: string,\n  contentType: string,\n  config: NonNullable<StorageConfig['vercelBlob']>\n): Promise<UploadResult> {\n  // Dynamic import to avoid requiring @vercel/blob if not using it\n  // eslint-disable-next-line @typescript-eslint/no-require-imports\n  const { put } = await (Function('return import(\"@vercel/blob\")')() as Promise<any>)\n  \n  const ext = filename.split('.').pop()?.toLowerCase() || 'jpg'\n  const key = `uploads/${randomUUID()}.${ext}`\n\n  const blob = await put(key, buffer, {\n    access: 'public',\n    contentType,\n    token: config.token,\n  })\n\n  return { url: blob.url, key }\n}\n\n/**\n * Upload to S3-compatible storage\n */\nasync function uploadToS3(\n  buffer: Buffer,\n  filename: string,\n  contentType: string,\n  config: NonNullable<StorageConfig['s3']>\n): Promise<UploadResult> {\n  // Dynamic import to avoid requiring @aws-sdk/client-s3 if not using S3\n  // eslint-disable-next-line @typescript-eslint/no-require-imports\n  const { PutObjectCommand } = await (Function('return import(\"@aws-sdk/client-s3\")')() as Promise<any>)\n  const client = await getS3Client(config)\n  \n  const ext = filename.split('.').pop()?.toLowerCase() || 'jpg'\n  const key = `uploads/${randomUUID()}.${ext}`\n\n  await client.send(\n    new PutObjectCommand({\n      Bucket: config.bucket,\n      Key: key,\n      Body: buffer,\n      ContentType: contentType,\n      ACL: 'public-read',\n    })\n  )\n\n  const cdnEndpoint = config.cdnEndpoint || config.endpoint || `https://${config.bucket}.s3.${config.region || 'us-east-1'}.amazonaws.com`\n  const url = cdnEndpoint.endsWith('/') ? `${cdnEndpoint}${key}` : `${cdnEndpoint}/${key}`\n\n  return { url, key }\n}\n\n/**\n * Upload to local filesystem\n */\nasync function uploadToLocal(\n  buffer: Buffer,\n  filename: string,\n  config?: StorageConfig['local']\n): Promise<UploadResult> {\n  const ext = filename.split('.').pop()?.toLowerCase() || 'jpg'\n  const key = `${randomUUID()}.${ext}`\n  const uploadDir = config?.uploadDir || join(process.cwd(), 'public', 'uploads')\n  const urlPrefix = config?.urlPrefix || '/uploads'\n  \n  await mkdir(uploadDir, { recursive: true })\n  await writeFile(join(uploadDir, key), buffer)\n\n  return { url: `${urlPrefix}/${key}`, key }\n}\n\n/**\n * Detect storage configuration from environment variables.\n * Priority: Vercel Blob > DigitalOcean Spaces > AWS S3 > Local\n */\nexport function detectStorageConfig(): StorageConfig {\n  // Vercel Blob (best for Vercel deployments)\n  if (process.env.BLOB_READ_WRITE_TOKEN) {\n    return {\n      vercelBlob: {\n        token: process.env.BLOB_READ_WRITE_TOKEN,\n      },\n    }\n  }\n\n  // DigitalOcean Spaces (best for DO deployments)\n  if (process.env.SPACES_KEY && process.env.SPACES_SECRET) {\n    return {\n      s3: {\n        accessKeyId: process.env.SPACES_KEY,\n        secretAccessKey: process.env.SPACES_SECRET,\n        bucket: process.env.SPACES_BUCKET || 'uploads',\n        region: process.env.SPACES_REGION || 'sfo3',\n        endpoint: process.env.SPACES_ENDPOINT || `https://${process.env.SPACES_REGION || 'sfo3'}.digitaloceanspaces.com`,\n        cdnEndpoint: process.env.SPACES_CDN_ENDPOINT,\n      },\n    }\n  }\n\n  // AWS S3\n  if (process.env.AWS_ACCESS_KEY_ID && process.env.AWS_SECRET_ACCESS_KEY && process.env.AWS_S3_BUCKET) {\n    return {\n      s3: {\n        accessKeyId: process.env.AWS_ACCESS_KEY_ID,\n        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,\n        bucket: process.env.AWS_S3_BUCKET,\n        region: process.env.AWS_REGION || 'us-east-1',\n        cdnEndpoint: process.env.AWS_S3_CDN_ENDPOINT,\n      },\n    }\n  }\n\n  // Default to local storage (for development)\n  return { local: {} }\n}\n\n/**\n * Upload a file using auto-detected or provided storage config\n */\nexport async function uploadFile(\n  buffer: Buffer,\n  filename: string,\n  contentType: string,\n  config?: StorageConfig\n): Promise<UploadResult> {\n  const resolvedConfig = config || detectStorageConfig()\n\n  if (resolvedConfig.vercelBlob) {\n    return uploadToVercelBlob(buffer, filename, contentType, resolvedConfig.vercelBlob)\n  }\n\n  if (resolvedConfig.s3) {\n    return uploadToS3(buffer, filename, contentType, resolvedConfig.s3)\n  }\n\n  return uploadToLocal(buffer, filename, resolvedConfig.local)\n}\n\n/**\n * Create a storage upload handler for autoblogger config.\n * Auto-detects cloud storage from env vars, falls back to local.\n * \n * Supported providers (checked in order):\n * - Vercel Blob: BLOB_READ_WRITE_TOKEN\n * - DigitalOcean Spaces: SPACES_KEY, SPACES_SECRET, SPACES_BUCKET\n * - AWS S3: AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_S3_BUCKET\n * - Local: No env vars needed (uses public/uploads)\n * \n * Usage:\n * ```ts\n * // Automatic - just works! No config needed.\n * const cms = createAutoblogger({ prisma, auth })\n * \n * // Or with explicit config:\n * import { createStorageHandler } from 'autoblogger'\n * const cms = createAutoblogger({\n *   storage: { upload: createStorageHandler() }\n * })\n * ```\n */\nexport function createStorageHandler(config?: StorageConfig) {\n  return async (file: File): Promise<{ url: string }> => {\n    const buffer = Buffer.from(await file.arrayBuffer())\n    const result = await uploadFile(buffer, file.name, file.type, config)\n    return { url: result.url }\n  }\n}\n","import type { ComponentType } from 'react'\nimport type { Post } from './models'\nimport type { Session } from './session'\nimport type { RssArticle } from '../auto-draft'\nimport type { Destination } from './destinations'\n\n// Style configuration for article rendering\nexport interface StylesConfig {\n  container?: string\n  title?: string\n  subtitle?: string\n  byline?: string\n  prose?: string\n}\n\n// Default styles\nexport const DEFAULT_STYLES: Required<StylesConfig> = {\n  container: 'max-w-ab-content mx-auto px-ab-content-padding',\n  title: 'text-ab-title font-bold',\n  subtitle: 'text-ab-h2 text-muted-foreground',\n  byline: 'text-sm text-muted-foreground',\n  prose: 'prose',\n}\n\n// Custom field component props (UI-only)\nexport interface CustomFieldProps<T = unknown> {\n  value: T\n  onChange: (value: T) => void\n  onFieldChange: (name: string, value: unknown) => void  // Update any post field\n  post: Post\n  disabled?: boolean\n}\n\n// Custom field definition (UI-only)\nexport interface CustomFieldConfig {\n  name: string\n  label?: string\n  component: ComponentType<CustomFieldProps<unknown>>\n  position?: 'footer' | 'sidebar'\n}\n\n// Server-safe configuration (no React types)\nexport interface AutobloggerServerConfig {\n  prisma: unknown\n\n  auth: {\n    getSession: () => Promise<Session | null>\n    isAdmin: (session: Session | null) => boolean\n    canPublish: (session: Session | null) => boolean\n  }\n\n  ai?: {\n    anthropicKey?: string\n    openaiKey?: string\n  }\n\n  /** Prismic integration config (passed from host app) */\n  prismic?: {\n    /** Repository name (e.g., 'my-repo') - auto-fills the settings UI */\n    repository?: string\n    /** Write API token from env */\n    writeToken?: string\n  }\n\n  storage?: {\n    upload: (file: File) => Promise<{ url: string }>\n  }\n\n  comments?: {\n    mode: 'authenticated' | 'public' | 'disabled'\n  }\n\n  styles?: StylesConfig\n\n  hooks?: {\n    beforePublish?: (post: Post) => Promise<void>\n    afterSave?: (post: Post) => Promise<void>\n    /** Called when a slug changes on a post that was previously published. Used to create redirects. */\n    onSlugChange?: (data: { postId: string; oldSlug: string; newSlug: string }) => Promise<void>\n    /** Called during auto-draft after generating essay, return extra fields for post creation */\n    onAutoDraftPostCreate?: (article: RssArticle, essay: { title: string; subtitle: string | null; markdown: string }) => Record<string, unknown> | Promise<Record<string, unknown>>\n  }\n\n  // Destination adapters for syncing to external CMSs\n  /** Array of destination adapters to sync posts to (Prismic, Contentful, etc.) */\n  destinations?: Destination[]\n\n  /** Webhook URLs to POST event payloads to when posts are published/unpublished/deleted */\n  webhooks?: string[]\n\n  /** Callback fired when a post is published */\n  onPublish?: (post: Post) => Promise<void>\n\n  /** Callback fired when a post is unpublished */\n  onUnpublish?: (post: Post) => Promise<void>\n\n  /** Callback fired when a post is deleted */\n  onDelete?: (post: Post) => Promise<void>\n}\n\n// Full configuration with custom fields (includes React types)\nexport interface AutobloggerConfig extends AutobloggerServerConfig {\n  fields?: CustomFieldConfig[]\n}\n","// Server-safe exports - no React imports\nimport { createPostsData } from './data/posts'\nimport { createCommentsData } from './data/comments'\nimport { createTagsData } from './data/tags'\nimport { createRevisionsData } from './data/revisions'\nimport { createAISettingsData } from './data/ai-settings'\nimport { createTopicsData } from './data/topics'\nimport { createNewsItemsData } from './data/news-items'\nimport { createUsersData } from './data/users'\nimport { createAPIHandler } from './api'\nimport { runAutoDraft as runAutoDraftInternal, type AutoDraftConfig } from './auto-draft'\nimport { createDestinationDispatcher } from './destinations'\nimport { createStorageHandler } from './lib/storage'\nimport type { AutobloggerServerConfig, StylesConfig } from './types/config'\nimport { DEFAULT_STYLES } from './types/config'\n\n// Re-export types for backward compatibility\nexport type { Session } from './types/session'\nexport type { StylesConfig, AutobloggerServerConfig } from './types/config'\n\n// Autoblogger server instance type\nexport interface AutobloggerServer {\n  config: AutobloggerServerConfig & { styles: Required<StylesConfig> }\n  posts: ReturnType<typeof createPostsData>\n  comments: ReturnType<typeof createCommentsData>\n  tags: ReturnType<typeof createTagsData>\n  revisions: ReturnType<typeof createRevisionsData>\n  aiSettings: ReturnType<typeof createAISettingsData>\n  topics: ReturnType<typeof createTopicsData>\n  newsItems: ReturnType<typeof createNewsItemsData>\n  users: ReturnType<typeof createUsersData>\n  /** Handle an API request - convenience method for route handlers */\n  handleRequest: (req: Request, path: string) => Promise<Response>\n  /** Auto-draft runner */\n  autoDraft: {\n    run: (topicId?: string, skipFrequencyCheck?: boolean) => Promise<import('./auto-draft').GenerationResult[]>\n  }\n}\n\n// Create autoblogger server instance\nexport function createAutoblogger(config: AutobloggerServerConfig): AutobloggerServer {\n  const prisma = config.prisma as any\n  \n  const mergedStyles: Required<StylesConfig> = {\n    ...DEFAULT_STYLES,\n    ...config.styles,\n  }\n\n  // Use built-in storage handler if none provided\n  // Auto-detects cloud storage (S3/Spaces) from env vars, falls back to local\n  const storage = config.storage || {\n    upload: createStorageHandler(),\n  }\n\n  // Create destination dispatcher\n  const dispatcher = createDestinationDispatcher({\n    destinations: config.destinations,\n    webhooks: config.webhooks,\n    onPublish: config.onPublish,\n    onUnpublish: config.onUnpublish,\n    onDelete: config.onDelete,\n  })\n\n  // Create the base server object first (without handleRequest)\n  const baseServer = {\n    config: {\n      ...config,\n      storage,\n      styles: mergedStyles,\n    },\n    posts: createPostsData(prisma, config.hooks, dispatcher, config.prismic?.writeToken),\n    comments: createCommentsData(prisma, config.comments),\n    tags: createTagsData(prisma),\n    revisions: createRevisionsData(prisma),\n    aiSettings: createAISettingsData(prisma),\n    topics: createTopicsData(prisma),\n    newsItems: createNewsItemsData(prisma),\n    users: createUsersData(prisma),\n  }\n\n  // Create the full server with handleRequest and autoDraft\n  const server: AutobloggerServer = {\n    ...baseServer,\n    handleRequest: async () => new Response('Not initialized', { status: 500 }),\n    autoDraft: {\n      run: async (topicId?: string, skipFrequencyCheck?: boolean) => {\n        const autoDraftConfig: AutoDraftConfig = {\n          prisma,\n          anthropicKey: config.ai?.anthropicKey,\n          openaiKey: config.ai?.openaiKey,\n          onPostCreate: config.hooks?.onAutoDraftPostCreate,\n        }\n        return runAutoDraftInternal(autoDraftConfig, topicId, skipFrequencyCheck)\n      },\n    },\n  }\n\n  // Create the API handler with the server\n  const apiHandler = createAPIHandler(server)\n\n  // Now set the real handleRequest implementation\n  server.handleRequest = async (req: Request, path: string): Promise<Response> => {\n    // Normalize path to start with /\n    const normalizedPath = '/' + path.replace(/^\\//, '')\n    \n    // Build the full URL the handler expects\n    const originalUrl = new URL(req.url)\n    const newUrl = new URL(originalUrl.origin + '/api/cms' + normalizedPath)\n    \n    // Copy search params\n    originalUrl.searchParams.forEach((value, key) => {\n      newUrl.searchParams.set(key, value)\n    })\n    \n    // Create a new request with nextUrl property (required by the handler)\n    const handlerReq = new Request(newUrl.toString(), {\n      method: req.method,\n      headers: req.headers,\n      body: req.method !== 'GET' && req.method !== 'HEAD' ? req.body : undefined,\n      // @ts-ignore - duplex is needed for streaming bodies\n      duplex: req.method !== 'GET' && req.method !== 'HEAD' ? 'half' : undefined,\n    }) as Request & { nextUrl: URL }\n    \n    // Add nextUrl property\n    Object.defineProperty(handlerReq, 'nextUrl', {\n      value: newUrl,\n      writable: false,\n    })\n    \n    return apiHandler(handlerReq)\n  }\n\n  return server\n}\n","// Schema validation helper\n\nconst REQUIRED_TABLES = [\n  'Post',\n  'Revision',\n  'Comment',\n  'Tag',\n  'PostTag',\n  'AISettings',\n  'TopicSubscription',\n  'NewsItem',\n]\n\nexport interface SchemaValidationResult {\n  valid: boolean\n  missingTables: string[]\n}\n\nexport async function validateSchema(prisma: unknown): Promise<SchemaValidationResult> {\n  const p = prisma as any\n  const missingTables: string[] = []\n\n  for (const table of REQUIRED_TABLES) {\n    const modelName = table.charAt(0).toLowerCase() + table.slice(1)\n    try {\n      // Try to access the model - if it doesn't exist, it will throw\n      if (!p[modelName]) {\n        missingTables.push(table)\n      } else {\n        // Try a simple query to verify the table exists\n        await p[modelName].findFirst({ take: 1 }).catch(() => {\n          missingTables.push(table)\n        })\n      }\n    } catch {\n      missingTables.push(table)\n    }\n  }\n\n  return {\n    valid: missingTables.length === 0,\n    missingTables,\n  }\n}\n","const MINUTE = 60_000, HOUR = 3_600_000, DAY = 86_400_000\n\n/**\n * Format a date as relative time (e.g., \"5m ago\", \"2h ago\", \"Yesterday\")\n */\nexport function formatRelativeTime(isoDate: string): string {\n  const date = new Date(isoDate)\n  const diffMs = Date.now() - date.getTime()\n  const mins = Math.floor(diffMs / MINUTE)\n  const hours = Math.floor(diffMs / HOUR)\n  const days = Math.floor(diffMs / DAY)\n  \n  if (mins < 1) return 'Just now'\n  if (mins < 60) return `${mins}m ago`\n  if (hours < 24) return `${hours}h ago`\n  if (days === 1) return 'Yesterday'\n  if (days < 7) return `${days}d ago`\n  return date.toLocaleDateString()\n}\n\n/**\n * Format a date for display\n */\nexport function formatDate(date: Date | string, options?: Intl.DateTimeFormatOptions): string {\n  const d = typeof date === 'string' ? new Date(date) : date\n  \n  const defaultOptions: Intl.DateTimeFormatOptions = {\n    year: 'numeric',\n    month: 'long',\n    day: 'numeric',\n  }\n  \n  return d.toLocaleDateString('en-US', options || defaultOptions)\n}\n\n/**\n * Format saved time for display (e.g., \"just now\", \"5m ago\", \"2:30 PM\")\n */\nexport function formatSavedTime(date: Date): string {\n  const now = new Date()\n  const diffMs = now.getTime() - date.getTime()\n  const diffSecs = Math.floor(diffMs / 1000)\n  const diffMins = Math.floor(diffMs / MINUTE)\n  \n  // Show relative time for recent saves\n  if (diffSecs < 10) return 'just now'\n  if (diffSecs < 60) return `${diffSecs}s ago`\n  if (diffMins < 60) return `${diffMins}m ago`\n  \n  // Show clock time for today\n  const isToday = date.toDateString() === now.toDateString()\n  if (isToday) {\n    return date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })\n  }\n  \n  return date.toLocaleDateString('en-US', { \n    month: 'short', \n    day: 'numeric',\n    hour: 'numeric',\n    minute: '2-digit',\n  })\n}\n\n/**\n * Count words in text\n */\nexport function countWords(text?: string | null): number {\n  if (!text) return 0\n  return text.split(/\\s+/).filter(Boolean).length\n}\n\n/**\n * Truncate text to a maximum length\n */\nexport function truncate(text: string, maxLength: number): string {\n  // Strip markdown formatting for description\n  const stripped = text\n    .replace(/#+\\s/g, '')\n    .replace(/\\*\\*/g, '')\n    .replace(/\\*/g, '')\n    .replace(/`/g, '')\n    .replace(/\\[([^\\]]+)\\]\\([^)]+\\)/g, '$1')\n    .replace(/\\n+/g, ' ')\n    .trim()\n  \n  if (stripped.length <= maxLength) return stripped\n  \n  return stripped.slice(0, maxLength - 3).trim() + '...'\n}\n","import type { Post } from '../types'\nimport { truncate } from './format'\n\nexport interface SeoValues {\n  title: string\n  description: string\n  keywords?: string | null\n  noIndex: boolean\n  ogImage?: string | null\n}\n\n/**\n * Get SEO values from a post with fallbacks\n */\nexport function getSeoValues(post: Post): SeoValues {\n  return {\n    title: post.seoTitle || post.title,\n    description: post.seoDescription || post.subtitle || truncate(post.markdown, 160),\n    keywords: post.seoKeywords,\n    noIndex: post.noIndex,\n    ogImage: post.ogImage,\n  }\n}\n","/**\n * Comment types and client-side API helpers for the editor commenting system.\n * Used for collaborative inline comments on posts.\n */\n\n// Types matching Prisma schema + includes\nexport interface CommentUser {\n  id: string\n  name: string | null\n  email: string\n}\n\nexport interface CommentWithUser {\n  id: string\n  postId: string\n  userId: string\n  quotedText: string\n  content: string\n  parentId: string | null\n  resolved: boolean\n  createdAt: string\n  updatedAt: string\n  user: CommentUser\n  replies?: CommentWithUser[]\n}\n\nexport interface CreateCommentData {\n  quotedText: string\n  content: string\n  parentId?: string\n}\n\nexport interface SelectionState {\n  text: string\n  from: number\n  to: number\n  hasExistingComment?: boolean\n}\n\n// Permission helpers (compare by email since that's what we have in session)\nexport function canDeleteComment(\n  comment: CommentWithUser,\n  currentUserEmail: string,\n  isAdmin: boolean\n): boolean {\n  return comment.user.email === currentUserEmail || isAdmin\n}\n\nexport function canEditComment(\n  comment: CommentWithUser,\n  currentUserEmail: string\n): boolean {\n  return comment.user.email === currentUserEmail\n}\n\n// API client factory - creates functions bound to a specific API base path\nexport function createCommentsClient(apiBasePath: string = '/api/cms') {\n  return {\n    async fetchComments(postId: string): Promise<CommentWithUser[]> {\n      const res = await fetch(`${apiBasePath}/posts/${postId}/comments`)\n      if (!res.ok) throw new Error('Failed to fetch comments')\n      const json = await res.json()\n      return json.data || json\n    },\n\n    async createComment(\n      postId: string,\n      data: CreateCommentData\n    ): Promise<CommentWithUser> {\n      const res = await fetch(`${apiBasePath}/posts/${postId}/comments`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(data),\n      })\n      if (!res.ok) {\n        const error = await res.json()\n        throw new Error(error.error || 'Failed to create comment')\n      }\n      const json = await res.json()\n      return json.data || json\n    },\n\n    async updateComment(\n      postId: string,\n      commentId: string,\n      content: string\n    ): Promise<CommentWithUser> {\n      const res = await fetch(`${apiBasePath}/posts/${postId}/comments/${commentId}`, {\n        method: 'PATCH',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ content }),\n      })\n      if (!res.ok) {\n        const error = await res.json()\n        throw new Error(error.error || 'Failed to update comment')\n      }\n      const json = await res.json()\n      return json.data || json\n    },\n\n    async deleteComment(\n      postId: string,\n      commentId: string\n    ): Promise<void> {\n      const res = await fetch(`${apiBasePath}/posts/${postId}/comments/${commentId}`, {\n        method: 'DELETE',\n      })\n      if (!res.ok) {\n        const error = await res.json()\n        throw new Error(error.error || 'Failed to delete comment')\n      }\n    },\n\n    async toggleResolve(\n      postId: string,\n      commentId: string\n    ): Promise<CommentWithUser> {\n      const res = await fetch(`${apiBasePath}/posts/${postId}/comments/${commentId}/resolve`, {\n        method: 'POST',\n      })\n      if (!res.ok) {\n        const error = await res.json()\n        throw new Error(error.error || 'Failed to toggle resolve')\n      }\n      const json = await res.json()\n      return json.data || json\n    },\n\n    async resolveAllComments(\n      postId: string\n    ): Promise<{ resolved: number }> {\n      const res = await fetch(`${apiBasePath}/posts/${postId}/comments/resolve-all`, {\n        method: 'POST',\n      })\n      if (!res.ok) {\n        const error = await res.json()\n        throw new Error(error.error || 'Failed to resolve all comments')\n      }\n      const json = await res.json()\n      return json.data || json\n    },\n  }\n}\n","import type { EditorState, Transaction } from '@tiptap/pm/state'\n\n/**\n * Takes a Transaction & Editor State and turns it into a chainable state object\n * @param config The transaction and state to create the chainable state from\n * @returns A chainable Editor state object\n */\nexport function createChainableState(config: { transaction: Transaction; state: EditorState }): EditorState {\n  const { state, transaction } = config\n  let { selection } = transaction\n  let { doc } = transaction\n  let { storedMarks } = transaction\n\n  return {\n    ...state,\n    apply: state.apply.bind(state),\n    applyTransaction: state.applyTransaction.bind(state),\n    plugins: state.plugins,\n    schema: state.schema,\n    reconfigure: state.reconfigure.bind(state),\n    toJSON: state.toJSON.bind(state),\n    get storedMarks() {\n      return storedMarks\n    },\n    get selection() {\n      return selection\n    },\n    get doc() {\n      return doc\n    },\n    get tr() {\n      selection = transaction.selection\n      doc = transaction.doc\n      storedMarks = transaction.storedMarks\n\n      return transaction\n    },\n  }\n}\n","import type { EditorState, Transaction } from '@tiptap/pm/state'\n\nimport type { Editor } from './Editor.js'\nimport { createChainableState } from './helpers/createChainableState.js'\nimport type { AnyCommands, CanCommands, ChainedCommands, CommandProps, SingleCommands } from './types.js'\n\nexport class CommandManager {\n  editor: Editor\n\n  rawCommands: AnyCommands\n\n  customState?: EditorState\n\n  constructor(props: { editor: Editor; state?: EditorState }) {\n    this.editor = props.editor\n    this.rawCommands = this.editor.extensionManager.commands\n    this.customState = props.state\n  }\n\n  get hasCustomState(): boolean {\n    return !!this.customState\n  }\n\n  get state(): EditorState {\n    return this.customState || this.editor.state\n  }\n\n  get commands(): SingleCommands {\n    const { rawCommands, editor, state } = this\n    const { view } = editor\n    const { tr } = state\n    const props = this.buildProps(tr)\n\n    return Object.fromEntries(\n      Object.entries(rawCommands).map(([name, command]) => {\n        const method = (...args: any[]) => {\n          const callback = command(...args)(props)\n\n          if (!tr.getMeta('preventDispatch') && !this.hasCustomState) {\n            view.dispatch(tr)\n          }\n\n          return callback\n        }\n\n        return [name, method]\n      }),\n    ) as unknown as SingleCommands\n  }\n\n  get chain(): () => ChainedCommands {\n    return () => this.createChain()\n  }\n\n  get can(): () => CanCommands {\n    return () => this.createCan()\n  }\n\n  public createChain(startTr?: Transaction, shouldDispatch = true): ChainedCommands {\n    const { rawCommands, editor, state } = this\n    const { view } = editor\n    const callbacks: boolean[] = []\n    const hasStartTransaction = !!startTr\n    const tr = startTr || state.tr\n\n    const run = () => {\n      if (!hasStartTransaction && shouldDispatch && !tr.getMeta('preventDispatch') && !this.hasCustomState) {\n        view.dispatch(tr)\n      }\n\n      return callbacks.every(callback => callback === true)\n    }\n\n    const chain = {\n      ...Object.fromEntries(\n        Object.entries(rawCommands).map(([name, command]) => {\n          const chainedCommand = (...args: never[]) => {\n            const props = this.buildProps(tr, shouldDispatch)\n            const callback = command(...args)(props)\n\n            callbacks.push(callback)\n\n            return chain\n          }\n\n          return [name, chainedCommand]\n        }),\n      ),\n      run,\n    } as unknown as ChainedCommands\n\n    return chain\n  }\n\n  public createCan(startTr?: Transaction): CanCommands {\n    const { rawCommands, state } = this\n    const dispatch = false\n    const tr = startTr || state.tr\n    const props = this.buildProps(tr, dispatch)\n    const formattedCommands = Object.fromEntries(\n      Object.entries(rawCommands).map(([name, command]) => {\n        return [name, (...args: never[]) => command(...args)({ ...props, dispatch: undefined })]\n      }),\n    ) as unknown as SingleCommands\n\n    return {\n      ...formattedCommands,\n      chain: () => this.createChain(tr, dispatch),\n    } as CanCommands\n  }\n\n  public buildProps(tr: Transaction, shouldDispatch = true): CommandProps {\n    const { rawCommands, editor, state } = this\n    const { view } = editor\n\n    const props: CommandProps = {\n      tr,\n      editor,\n      view,\n      state: createChainableState({\n        state,\n        transaction: tr,\n      }),\n      dispatch: shouldDispatch ? () => undefined : undefined,\n      chain: () => this.createChain(tr, shouldDispatch),\n      can: () => this.createCan(tr),\n      get commands() {\n        return Object.fromEntries(\n          Object.entries(rawCommands).map(([name, command]) => {\n            return [name, (...args: never[]) => command(...args)(props)]\n          }),\n        ) as unknown as SingleCommands\n      },\n    }\n\n    return props\n  }\n}\n","export * from './blur.js'\nexport * from './clearContent.js'\nexport * from './clearNodes.js'\nexport * from './command.js'\nexport * from './createParagraphNear.js'\nexport * from './cut.js'\nexport * from './deleteCurrentNode.js'\nexport * from './deleteNode.js'\nexport * from './deleteRange.js'\nexport * from './deleteSelection.js'\nexport * from './enter.js'\nexport * from './exitCode.js'\nexport * from './extendMarkRange.js'\nexport * from './first.js'\nexport * from './focus.js'\nexport * from './forEach.js'\nexport * from './insertContent.js'\nexport * from './insertContentAt.js'\nexport * from './join.js'\nexport * from './joinItemBackward.js'\nexport * from './joinItemForward.js'\nexport * from './joinTextblockBackward.js'\nexport * from './joinTextblockForward.js'\nexport * from './keyboardShortcut.js'\nexport * from './lift.js'\nexport * from './liftEmptyBlock.js'\nexport * from './liftListItem.js'\nexport * from './newlineInCode.js'\nexport * from './resetAttributes.js'\nexport * from './scrollIntoView.js'\nexport * from './selectAll.js'\nexport * from './selectNodeBackward.js'\nexport * from './selectNodeForward.js'\nexport * from './selectParentNode.js'\nexport * from './selectTextblockEnd.js'\nexport * from './selectTextblockStart.js'\nexport * from './setContent.js'\nexport * from './setMark.js'\nexport * from './setMeta.js'\nexport * from './setNode.js'\nexport * from './setNodeSelection.js'\nexport * from './setTextDirection.js'\nexport * from './setTextSelection.js'\nexport * from './sinkListItem.js'\nexport * from './splitBlock.js'\nexport * from './splitListItem.js'\nexport * from './toggleList.js'\nexport * from './toggleMark.js'\nexport * from './toggleNode.js'\nexport * from './toggleWrap.js'\nexport * from './undoInputRule.js'\nexport * from './unsetAllMarks.js'\nexport * from './unsetMark.js'\nexport * from './unsetTextDirection.js'\nexport * from './updateAttributes.js'\nexport * from './wrapIn.js'\nexport * from './wrapInList.js'\n","import type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    blur: {\n      /**\n       * Removes focus from the editor.\n       * @example editor.commands.blur()\n       */\n      blur: () => ReturnType\n    }\n  }\n}\n\nexport const blur: RawCommands['blur'] =\n  () =>\n  ({ editor, view }) => {\n    requestAnimationFrame(() => {\n      if (!editor.isDestroyed) {\n        ;(view.dom as HTMLElement).blur()\n\n        // Browsers should remove the caret on blur but safari does not.\n        // See: https://github.com/ueberdosis/tiptap/issues/2405\n        window?.getSelection()?.removeAllRanges()\n      }\n    })\n\n    return true\n  }\n","import type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    clearContent: {\n      /**\n       * Clear the whole document.\n       * @example editor.commands.clearContent()\n       */\n      clearContent: (\n        /**\n         * Whether to emit an update event.\n         * @default true\n         */\n        emitUpdate?: boolean,\n      ) => ReturnType\n    }\n  }\n}\n\nexport const clearContent: RawCommands['clearContent'] =\n  (emitUpdate = true) =>\n  ({ commands }) => {\n    return commands.setContent('', { emitUpdate })\n  }\n","import { liftTarget } from '@tiptap/pm/transform'\n\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    clearNodes: {\n      /**\n       * Normalize nodes to a simple paragraph.\n       * @example editor.commands.clearNodes()\n       */\n      clearNodes: () => ReturnType\n    }\n  }\n}\n\nexport const clearNodes: RawCommands['clearNodes'] =\n  () =>\n  ({ state, tr, dispatch }) => {\n    const { selection } = tr\n    const { ranges } = selection\n\n    if (!dispatch) {\n      return true\n    }\n\n    ranges.forEach(({ $from, $to }) => {\n      state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n        if (node.type.isText) {\n          return\n        }\n\n        const { doc, mapping } = tr\n        const $mappedFrom = doc.resolve(mapping.map(pos))\n        const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize))\n        const nodeRange = $mappedFrom.blockRange($mappedTo)\n\n        if (!nodeRange) {\n          return\n        }\n\n        const targetLiftDepth = liftTarget(nodeRange)\n\n        if (node.type.isTextblock) {\n          const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index())\n\n          tr.setNodeMarkup(nodeRange.start, defaultType)\n        }\n\n        if (targetLiftDepth || targetLiftDepth === 0) {\n          tr.lift(nodeRange, targetLiftDepth)\n        }\n      })\n    })\n\n    return true\n  }\n","import type { Command, RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    command: {\n      /**\n       * Define a command inline.\n       * @param fn The command function.\n       * @example\n       * editor.commands.command(({ tr, state }) => {\n       *   ...\n       *   return true\n       * })\n       */\n      command: (fn: (props: Parameters<Command>[0]) => boolean) => ReturnType\n    }\n  }\n}\n\nexport const command: RawCommands['command'] = fn => props => {\n  return fn(props)\n}\n","import { createParagraphNear as originalCreateParagraphNear } from '@tiptap/pm/commands'\n\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    createParagraphNear: {\n      /**\n       * Create a paragraph nearby.\n       * @example editor.commands.createParagraphNear()\n       */\n      createParagraphNear: () => ReturnType\n    }\n  }\n}\n\nexport const createParagraphNear: RawCommands['createParagraphNear'] =\n  () =>\n  ({ state, dispatch }) => {\n    return originalCreateParagraphNear(state, dispatch)\n  }\n","import { TextSelection } from '@tiptap/pm/state'\n\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    cut: {\n      /**\n       * Cuts content from a range and inserts it at a given position.\n       * @param range The range to cut.\n       * @param range.from The start position of the range.\n       * @param range.to The end position of the range.\n       * @param targetPos The position to insert the content at.\n       * @example editor.commands.cut({ from: 1, to: 3 }, 5)\n       */\n      cut: ({ from, to }: { from: number; to: number }, targetPos: number) => ReturnType\n    }\n  }\n}\n\nexport const cut: RawCommands['cut'] =\n  (originRange, targetPos) =>\n  ({ editor, tr }) => {\n    const { state } = editor\n\n    const contentSlice = state.doc.slice(originRange.from, originRange.to)\n\n    tr.deleteRange(originRange.from, originRange.to)\n    const newPos = tr.mapping.map(targetPos)\n\n    tr.insert(newPos, contentSlice.content)\n\n    tr.setSelection(new TextSelection(tr.doc.resolve(Math.max(newPos - 1, 0))))\n\n    return true\n  }\n","import type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    deleteCurrentNode: {\n      /**\n       * Delete the node that currently has the selection anchor.\n       * @example editor.commands.deleteCurrentNode()\n       */\n      deleteCurrentNode: () => ReturnType\n    }\n  }\n}\n\nexport const deleteCurrentNode: RawCommands['deleteCurrentNode'] =\n  () =>\n  ({ tr, dispatch }) => {\n    const { selection } = tr\n    const currentNode = selection.$anchor.node()\n\n    // if there is content inside the current node, break out of this command\n    if (currentNode.content.size > 0) {\n      return false\n    }\n\n    const $pos = tr.selection.$anchor\n\n    for (let depth = $pos.depth; depth > 0; depth -= 1) {\n      const node = $pos.node(depth)\n\n      if (node.type === currentNode.type) {\n        if (dispatch) {\n          const from = $pos.before(depth)\n          const to = $pos.after(depth)\n\n          tr.delete(from, to).scrollIntoView()\n        }\n\n        return true\n      }\n    }\n\n    return false\n  }\n","import type { NodeType, Schema } from '@tiptap/pm/model'\n\nexport function getNodeType(nameOrType: string | NodeType, schema: Schema): NodeType {\n  if (typeof nameOrType === 'string') {\n    if (!schema.nodes[nameOrType]) {\n      throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`)\n    }\n\n    return schema.nodes[nameOrType]\n  }\n\n  return nameOrType\n}\n","import type { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    deleteNode: {\n      /**\n       * Delete a node with a given type or name.\n       * @param typeOrName The type or name of the node.\n       * @example editor.commands.deleteNode('paragraph')\n       */\n      deleteNode: (typeOrName: string | NodeType) => ReturnType\n    }\n  }\n}\n\nexport const deleteNode: RawCommands['deleteNode'] =\n  typeOrName =>\n  ({ tr, state, dispatch }) => {\n    const type = getNodeType(typeOrName, state.schema)\n    const $pos = tr.selection.$anchor\n\n    for (let depth = $pos.depth; depth > 0; depth -= 1) {\n      const node = $pos.node(depth)\n\n      if (node.type === type) {\n        if (dispatch) {\n          const from = $pos.before(depth)\n          const to = $pos.after(depth)\n\n          tr.delete(from, to).scrollIntoView()\n        }\n\n        return true\n      }\n    }\n\n    return false\n  }\n","import type { Range, RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    deleteRange: {\n      /**\n       * Delete a given range.\n       * @param range The range to delete.\n       * @example editor.commands.deleteRange({ from: 1, to: 3 })\n       */\n      deleteRange: (range: Range) => ReturnType\n    }\n  }\n}\n\nexport const deleteRange: RawCommands['deleteRange'] =\n  range =>\n  ({ tr, dispatch }) => {\n    const { from, to } = range\n\n    if (dispatch) {\n      tr.delete(from, to)\n    }\n\n    return true\n  }\n","import { deleteSelection as originalDeleteSelection } from '@tiptap/pm/commands'\n\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    deleteSelection: {\n      /**\n       * Delete the selection, if there is one.\n       * @example editor.commands.deleteSelection()\n       */\n      deleteSelection: () => ReturnType\n    }\n  }\n}\n\nexport const deleteSelection: RawCommands['deleteSelection'] =\n  () =>\n  ({ state, dispatch }) => {\n    return originalDeleteSelection(state, dispatch)\n  }\n","import type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    enter: {\n      /**\n       * Trigger enter.\n       * @example editor.commands.enter()\n       */\n      enter: () => ReturnType\n    }\n  }\n}\n\nexport const enter: RawCommands['enter'] =\n  () =>\n  ({ commands }) => {\n    return commands.keyboardShortcut('Enter')\n  }\n","import { exitCode as originalExitCode } from '@tiptap/pm/commands'\n\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    exitCode: {\n      /**\n       * Exit from a code block.\n       * @example editor.commands.exitCode()\n       */\n      exitCode: () => ReturnType\n    }\n  }\n}\n\nexport const exitCode: RawCommands['exitCode'] =\n  () =>\n  ({ state, dispatch }) => {\n    return originalExitCode(state, dispatch)\n  }\n","import type { MarkType } from '@tiptap/pm/model'\nimport { TextSelection } from '@tiptap/pm/state'\n\nimport { getMarkRange } from '../helpers/getMarkRange.js'\nimport { getMarkType } from '../helpers/getMarkType.js'\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    extendMarkRange: {\n      /**\n       * Extends the text selection to the current mark by type or name.\n       * @param typeOrName The type or name of the mark.\n       * @param attributes The attributes of the mark.\n       * @example editor.commands.extendMarkRange('bold')\n       * @example editor.commands.extendMarkRange('mention', { userId: \"1\" })\n       */\n      extendMarkRange: (\n        /**\n         * The type or name of the mark.\n         */\n        typeOrName: string | MarkType,\n\n        /**\n         * The attributes of the mark.\n         */\n        attributes?: Record<string, any>,\n      ) => ReturnType\n    }\n  }\n}\n\nexport const extendMarkRange: RawCommands['extendMarkRange'] =\n  (typeOrName, attributes = {}) =>\n  ({ tr, state, dispatch }) => {\n    const type = getMarkType(typeOrName, state.schema)\n    const { doc, selection } = tr\n    const { $from, from, to } = selection\n\n    if (dispatch) {\n      const range = getMarkRange($from, type, attributes)\n\n      if (range && range.from <= from && range.to >= to) {\n        const newSelection = TextSelection.create(doc, range.from, range.to)\n\n        tr.setSelection(newSelection)\n      }\n    }\n\n    return true\n  }\n","export function isRegExp(value: any): value is RegExp {\n  return Object.prototype.toString.call(value) === '[object RegExp]'\n}\n","import { isRegExp } from './isRegExp.js'\n\n/**\n * Check if object1 includes object2\n * @param object1 Object\n * @param object2 Object\n */\nexport function objectIncludes(\n  object1: Record<string, any>,\n  object2: Record<string, any>,\n  options: { strict: boolean } = { strict: true },\n): boolean {\n  const keys = Object.keys(object2)\n\n  if (!keys.length) {\n    return true\n  }\n\n  return keys.every(key => {\n    if (options.strict) {\n      return object2[key] === object1[key]\n    }\n\n    if (isRegExp(object2[key])) {\n      return object2[key].test(object1[key])\n    }\n\n    return object2[key] === object1[key]\n  })\n}\n","import type { Mark as ProseMirrorMark, MarkType, ResolvedPos } from '@tiptap/pm/model'\n\nimport type { Range } from '../types.js'\nimport { objectIncludes } from '../utilities/objectIncludes.js'\n\nfunction findMarkInSet(\n  marks: ProseMirrorMark[],\n  type: MarkType,\n  attributes: Record<string, any> = {},\n): ProseMirrorMark | undefined {\n  return marks.find(item => {\n    return (\n      item.type === type &&\n      objectIncludes(\n        // Only check equality for the attributes that are provided\n        Object.fromEntries(Object.keys(attributes).map(k => [k, item.attrs[k]])),\n        attributes,\n      )\n    )\n  })\n}\n\nfunction isMarkInSet(marks: ProseMirrorMark[], type: MarkType, attributes: Record<string, any> = {}): boolean {\n  return !!findMarkInSet(marks, type, attributes)\n}\n\n/**\n * Get the range of a mark at a resolved position.\n */\nexport function getMarkRange(\n  /**\n   * The position to get the mark range for.\n   */\n  $pos: ResolvedPos,\n  /**\n   * The mark type to get the range for.\n   */\n  type: MarkType,\n  /**\n   * The attributes to match against.\n   * If not provided, only the first mark at the position will be matched.\n   */\n  attributes?: Record<string, any>,\n): Range | void {\n  if (!$pos || !type) {\n    return\n  }\n  let start = $pos.parent.childAfter($pos.parentOffset)\n\n  // If the cursor is at the start of a text node that does not have the mark, look backward\n  if (!start.node || !start.node.marks.some(mark => mark.type === type)) {\n    start = $pos.parent.childBefore($pos.parentOffset)\n  }\n\n  // If there is no text node with the mark even backward, return undefined\n  if (!start.node || !start.node.marks.some(mark => mark.type === type)) {\n    return\n  }\n\n  // Default to only matching against the first mark's attributes\n  attributes = attributes || start.node.marks[0]?.attrs\n\n  // We now know that the cursor is either at the start, middle or end of a text node with the specified mark\n  // so we can look it up on the targeted mark\n  const mark = findMarkInSet([...start.node.marks], type, attributes)\n\n  if (!mark) {\n    return\n  }\n\n  let startIndex = start.index\n  let startPos = $pos.start() + start.offset\n  let endIndex = startIndex + 1\n  let endPos = startPos + start.node.nodeSize\n\n  while (startIndex > 0 && isMarkInSet([...$pos.parent.child(startIndex - 1).marks], type, attributes)) {\n    startIndex -= 1\n    startPos -= $pos.parent.child(startIndex).nodeSize\n  }\n\n  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {\n    endPos += $pos.parent.child(endIndex).nodeSize\n    endIndex += 1\n  }\n\n  return {\n    from: startPos,\n    to: endPos,\n  }\n}\n","import type { MarkType, Schema } from '@tiptap/pm/model'\n\nexport function getMarkType(nameOrType: string | MarkType, schema: Schema): MarkType {\n  if (typeof nameOrType === 'string') {\n    if (!schema.marks[nameOrType]) {\n      throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`)\n    }\n\n    return schema.marks[nameOrType]\n  }\n\n  return nameOrType\n}\n","import type { Command, CommandProps, RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    first: {\n      /**\n       * Runs one command after the other and stops at the first which returns true.\n       * @param commands The commands to run.\n       * @example editor.commands.first([command1, command2])\n       */\n      first: (commands: Command[] | ((props: CommandProps) => Command[])) => ReturnType\n    }\n  }\n}\n\nexport const first: RawCommands['first'] = commands => props => {\n  const items = typeof commands === 'function' ? commands(props) : commands\n\n  for (let i = 0; i < items.length; i += 1) {\n    if (items[i](props)) {\n      return true\n    }\n  }\n\n  return false\n}\n","import { TextSelection } from '@tiptap/pm/state'\n\nexport function isTextSelection(value: unknown): value is TextSelection {\n  return value instanceof TextSelection\n}\n","import type { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { Selection, TextSelection } from '@tiptap/pm/state'\n\nimport type { FocusPosition } from '../types.js'\nimport { minMax } from '../utilities/minMax.js'\n\nexport function resolveFocusPosition(doc: ProseMirrorNode, position: FocusPosition = null): Selection | null {\n  if (!position) {\n    return null\n  }\n\n  const selectionAtStart = Selection.atStart(doc)\n  const selectionAtEnd = Selection.atEnd(doc)\n\n  if (position === 'start' || position === true) {\n    return selectionAtStart\n  }\n\n  if (position === 'end') {\n    return selectionAtEnd\n  }\n\n  const minPos = selectionAtStart.from\n  const maxPos = selectionAtEnd.to\n\n  if (position === 'all') {\n    return TextSelection.create(doc, minMax(0, minPos, maxPos), minMax(doc.content.size, minPos, maxPos))\n  }\n\n  return TextSelection.create(doc, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos))\n}\n","export function minMax(value = 0, min = 0, max = 0): number {\n  return Math.min(Math.max(value, min), max)\n}\n","export function isAndroid(): boolean {\n  return navigator.platform === 'Android' || /android/i.test(navigator.userAgent)\n}\n","export function isiOS(): boolean {\n  return (\n    ['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].includes(navigator.platform) ||\n    // iPad on iOS 13 detection\n    (navigator.userAgent.includes('Mac') && 'ontouchend' in document)\n  )\n}\n","/**\n * Detects if the current browser is Safari (but not iOS Safari or Chrome).\n * @returns `true` if the browser is Safari, `false` otherwise.\n * @example\n * if (isSafari()) {\n *   // Safari-specific handling\n * }\n */\nexport function isSafari(): boolean {\n  return typeof navigator !== 'undefined' ? /^((?!chrome|android).)*safari/i.test(navigator.userAgent) : false\n}\n","import { isTextSelection } from '../helpers/isTextSelection.js'\nimport { resolveFocusPosition } from '../helpers/resolveFocusPosition.js'\nimport type { FocusPosition, RawCommands } from '../types.js'\nimport { isAndroid } from '../utilities/isAndroid.js'\nimport { isiOS } from '../utilities/isiOS.js'\nimport { isSafari } from '../utilities/isSafari.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    focus: {\n      /**\n       * Focus the editor at the given position.\n       * @param position The position to focus at.\n       * @param options.scrollIntoView Scroll the focused position into view after focusing\n       * @example editor.commands.focus()\n       * @example editor.commands.focus(32, { scrollIntoView: false })\n       */\n      focus: (\n        /**\n         * The position to focus at.\n         */\n        position?: FocusPosition,\n\n        /**\n         * Optional options\n         * @default { scrollIntoView: true }\n         */\n        options?: {\n          scrollIntoView?: boolean\n        },\n      ) => ReturnType\n    }\n  }\n}\n\nexport const focus: RawCommands['focus'] =\n  (position = null, options = {}) =>\n  ({ editor, view, tr, dispatch }) => {\n    options = {\n      scrollIntoView: true,\n      ...options,\n    }\n\n    const delayedFocus = () => {\n      // focus within `requestAnimationFrame` breaks focus on iOS and Android\n      // so we have to call this\n      if (isiOS() || isAndroid()) {\n        ;(view.dom as HTMLElement).focus()\n      }\n\n      // Safari requires preventScroll to avoid the browser scrolling to the\n      // top of the editor when focus is called before the selection is set.\n      // We exclude iOS and Android since they are already handled above.\n      // see: https://github.com/ueberdosis/tiptap/issues/7318\n      if (isSafari() && !isiOS() && !isAndroid()) {\n        ;(view.dom as HTMLElement).focus({ preventScroll: true })\n      }\n\n      // For React we have to focus asynchronously. Otherwise wild things happen.\n      // see: https://github.com/ueberdosis/tiptap/issues/1520\n      requestAnimationFrame(() => {\n        if (!editor.isDestroyed) {\n          view.focus()\n\n          if (options?.scrollIntoView) {\n            editor.commands.scrollIntoView()\n          }\n        }\n      })\n    }\n\n    if ((view.hasFocus() && position === null) || position === false) {\n      return true\n    }\n\n    // we donâ€™t try to resolve a NodeSelection or CellSelection\n    if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\n      delayedFocus()\n      return true\n    }\n\n    // pass through tr.doc instead of editor.state.doc\n    // since transactions could change the editors state before this command has been run\n    const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection\n    const isSameSelection = editor.state.selection.eq(selection)\n\n    if (dispatch) {\n      if (!isSameSelection) {\n        tr.setSelection(selection)\n      }\n\n      // `tr.setSelection` resets the stored marks\n      // so weâ€™ll restore them if the selection is the same as before\n      if (isSameSelection && tr.storedMarks) {\n        tr.setStoredMarks(tr.storedMarks)\n      }\n\n      delayedFocus()\n    }\n\n    return true\n  }\n","import type { CommandProps, RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    forEach: {\n      /**\n       * Loop through an array of items.\n       */\n      forEach: <T>(\n        items: T[],\n        fn: (\n          item: T,\n          props: CommandProps & {\n            index: number\n          },\n        ) => boolean,\n      ) => ReturnType\n    }\n  }\n}\n\nexport const forEach: RawCommands['forEach'] = (items, fn) => props => {\n  return items.every((item, index) => fn(item, { ...props, index }))\n}\n","import type { Fragment, Node as ProseMirrorNode, ParseOptions } from '@tiptap/pm/model'\n\nimport type { Content, RawCommands } from '../types.js'\n\nexport interface InsertContentOptions {\n  /**\n   * Options for parsing the content.\n   */\n  parseOptions?: ParseOptions\n\n  /**\n   * Whether to update the selection after inserting the content.\n   */\n  updateSelection?: boolean\n  applyInputRules?: boolean\n  applyPasteRules?: boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    insertContent: {\n      /**\n       * Insert a node or string of HTML at the current position.\n       * @example editor.commands.insertContent('<h1>Example</h1>')\n       * @example editor.commands.insertContent('<h1>Example</h1>', { updateSelection: false })\n       */\n      insertContent: (\n        /**\n         * The ProseMirror content to insert.\n         */\n        value: Content | ProseMirrorNode | Fragment,\n\n        /**\n         * Optional options\n         */\n        options?: InsertContentOptions,\n      ) => ReturnType\n    }\n  }\n}\n\nexport const insertContent: RawCommands['insertContent'] =\n  (value, options) =>\n  ({ tr, commands }) => {\n    return commands.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options)\n  }\n","import type { Node as ProseMirrorNode, ParseOptions } from '@tiptap/pm/model'\nimport { Fragment } from '@tiptap/pm/model'\n\nimport { createNodeFromContent } from '../helpers/createNodeFromContent.js'\nimport { selectionToInsertionEnd } from '../helpers/selectionToInsertionEnd.js'\nimport type { Content, Range, RawCommands } from '../types.js'\n\nexport interface InsertContentAtOptions {\n  /**\n   * Options for parsing the content.\n   */\n  parseOptions?: ParseOptions\n\n  /**\n   * Whether to update the selection after inserting the content.\n   */\n  updateSelection?: boolean\n\n  /**\n   * Whether to apply input rules after inserting the content.\n   */\n  applyInputRules?: boolean\n\n  /**\n   * Whether to apply paste rules after inserting the content.\n   */\n  applyPasteRules?: boolean\n\n  /**\n   * Whether to throw an error if the content is invalid.\n   */\n  errorOnInvalidContent?: boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    insertContentAt: {\n      /**\n       * Insert a node or string of HTML at a specific position.\n       * @example editor.commands.insertContentAt(0, '<h1>Example</h1>')\n       */\n      insertContentAt: (\n        /**\n         * The position to insert the content at.\n         */\n        position: number | Range,\n\n        /**\n         * The ProseMirror content to insert.\n         */\n        value: Content | ProseMirrorNode | Fragment,\n\n        /**\n         * Optional options\n         */\n        options?: InsertContentAtOptions,\n      ) => ReturnType\n    }\n  }\n}\n\nconst isFragment = (nodeOrFragment: ProseMirrorNode | Fragment): nodeOrFragment is Fragment => {\n  return !('type' in nodeOrFragment)\n}\n\nexport const insertContentAt: RawCommands['insertContentAt'] =\n  (position, value, options) =>\n  ({ tr, dispatch, editor }) => {\n    if (dispatch) {\n      options = {\n        parseOptions: editor.options.parseOptions,\n        updateSelection: true,\n        applyInputRules: false,\n        applyPasteRules: false,\n        ...options,\n      }\n\n      let content: Fragment | ProseMirrorNode\n\n      const emitContentError = (error: Error) => {\n        editor.emit('contentError', {\n          editor,\n          error,\n          disableCollaboration: () => {\n            if (\n              'collaboration' in editor.storage &&\n              typeof editor.storage.collaboration === 'object' &&\n              editor.storage.collaboration\n            ) {\n              ;(editor.storage.collaboration as any).isDisabled = true\n            }\n          },\n        })\n      }\n\n      const parseOptions: ParseOptions = {\n        preserveWhitespace: 'full',\n        ...options.parseOptions,\n      }\n\n      // If `emitContentError` is enabled, we want to check the content for errors\n      // but ignore them (do not remove the invalid content from the document)\n      if (!options.errorOnInvalidContent && !editor.options.enableContentCheck && editor.options.emitContentError) {\n        try {\n          createNodeFromContent(value, editor.schema, {\n            parseOptions,\n            errorOnInvalidContent: true,\n          })\n        } catch (e) {\n          emitContentError(e as Error)\n        }\n      }\n\n      try {\n        content = createNodeFromContent(value, editor.schema, {\n          parseOptions,\n          errorOnInvalidContent: options.errorOnInvalidContent ?? editor.options.enableContentCheck,\n        })\n      } catch (e) {\n        emitContentError(e as Error)\n        return false\n      }\n\n      let { from, to } =\n        typeof position === 'number' ? { from: position, to: position } : { from: position.from, to: position.to }\n\n      let isOnlyTextContent = true\n      let isOnlyBlockContent = true\n      const nodes = isFragment(content) ? content : [content]\n\n      nodes.forEach(node => {\n        // check if added node is valid\n        node.check()\n\n        isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false\n\n        isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false\n      })\n\n      // check if we can replace the wrapping node by\n      // the newly inserted content\n      // example:\n      // replace an empty paragraph by an inserted image\n      // instead of inserting the image below the paragraph\n      if (from === to && isOnlyBlockContent) {\n        const { parent } = tr.doc.resolve(from)\n        const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount\n\n        if (isEmptyTextBlock) {\n          from -= 1\n          to += 1\n        }\n      }\n\n      let newContent\n\n      // if there is only plain text we have to use `insertText`\n      // because this will keep the current marks\n      if (isOnlyTextContent) {\n        // if value is string, we can use it directly\n        // otherwise if it is an array, we have to join it\n        if (Array.isArray(value)) {\n          newContent = value.map(v => v.text || '').join('')\n        } else if (value instanceof Fragment) {\n          let text = ''\n\n          value.forEach(node => {\n            if (node.text) {\n              text += node.text\n            }\n          })\n\n          newContent = text\n        } else if (typeof value === 'object' && !!value && !!value.text) {\n          newContent = value.text\n        } else {\n          newContent = value as string\n        }\n\n        tr.insertText(newContent, from, to)\n      } else {\n        newContent = content\n\n        const $from = tr.doc.resolve(from)\n        const $fromNode = $from.node()\n        const fromSelectionAtStart = $from.parentOffset === 0\n        const isTextSelection = $fromNode.isText || $fromNode.isTextblock\n        const hasContent = $fromNode.content.size > 0\n\n        if (fromSelectionAtStart && isTextSelection && hasContent) {\n          from = Math.max(0, from - 1)\n        }\n\n        tr.replaceWith(from, to, newContent)\n      }\n\n      // set cursor at end of inserted content\n      if (options.updateSelection) {\n        selectionToInsertionEnd(tr, tr.steps.length - 1, -1)\n      }\n\n      if (options.applyInputRules) {\n        tr.setMeta('applyInputRules', { from, text: newContent })\n      }\n\n      if (options.applyPasteRules) {\n        tr.setMeta('applyPasteRules', { from, text: newContent })\n      }\n    }\n\n    return true\n  }\n","import type { ParseOptions } from '@tiptap/pm/model'\nimport { DOMParser, Fragment, Node as ProseMirrorNode, Schema } from '@tiptap/pm/model'\n\nimport type { Content } from '../types.js'\nimport { elementFromString } from '../utilities/elementFromString.js'\n\nexport type CreateNodeFromContentOptions = {\n  slice?: boolean\n  parseOptions?: ParseOptions\n  errorOnInvalidContent?: boolean\n}\n\n/**\n * Takes a JSON or HTML content and creates a Prosemirror node or fragment from it.\n * @param content The JSON or HTML content to create the node from\n * @param schema The Prosemirror schema to use for the node\n * @param options Options for the parser\n * @returns The created Prosemirror node or fragment\n */\nexport function createNodeFromContent(\n  content: Content | ProseMirrorNode | Fragment,\n  schema: Schema,\n  options?: CreateNodeFromContentOptions,\n): ProseMirrorNode | Fragment {\n  if (content instanceof ProseMirrorNode || content instanceof Fragment) {\n    return content\n  }\n  options = {\n    slice: true,\n    parseOptions: {},\n    ...options,\n  }\n\n  const isJSONContent = typeof content === 'object' && content !== null\n  const isTextContent = typeof content === 'string'\n\n  if (isJSONContent) {\n    try {\n      const isArrayContent = Array.isArray(content) && content.length > 0\n\n      // if the JSON Content is an array of nodes, create a fragment for each node\n      if (isArrayContent) {\n        return Fragment.fromArray(content.map(item => schema.nodeFromJSON(item)))\n      }\n\n      const node = schema.nodeFromJSON(content)\n\n      if (options.errorOnInvalidContent) {\n        node.check()\n      }\n\n      return node\n    } catch (error) {\n      if (options.errorOnInvalidContent) {\n        throw new Error('[tiptap error]: Invalid JSON content', { cause: error as Error })\n      }\n\n      console.warn('[tiptap warn]: Invalid content.', 'Passed value:', content, 'Error:', error)\n\n      return createNodeFromContent('', schema, options)\n    }\n  }\n\n  if (isTextContent) {\n    // Check for invalid content\n    if (options.errorOnInvalidContent) {\n      let hasInvalidContent = false\n      let invalidContent = ''\n\n      // A copy of the current schema with a catch-all node at the end\n      const contentCheckSchema = new Schema({\n        topNode: schema.spec.topNode,\n        marks: schema.spec.marks,\n        // Prosemirror's schemas are executed such that: the last to execute, matches last\n        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle\n        nodes: schema.spec.nodes.append({\n          __tiptap__private__unknown__catch__all__node: {\n            content: 'inline*',\n            group: 'block',\n            parseDOM: [\n              {\n                tag: '*',\n                getAttrs: e => {\n                  // If this is ever called, we know that the content has something that we don't know how to handle in the schema\n                  hasInvalidContent = true\n                  // Try to stringify the element for a more helpful error message\n                  invalidContent = typeof e === 'string' ? e : e.outerHTML\n                  return null\n                },\n              },\n            ],\n          },\n        }),\n      })\n\n      if (options.slice) {\n        DOMParser.fromSchema(contentCheckSchema).parseSlice(elementFromString(content), options.parseOptions)\n      } else {\n        DOMParser.fromSchema(contentCheckSchema).parse(elementFromString(content), options.parseOptions)\n      }\n\n      if (options.errorOnInvalidContent && hasInvalidContent) {\n        throw new Error('[tiptap error]: Invalid HTML content', {\n          cause: new Error(`Invalid element found: ${invalidContent}`),\n        })\n      }\n    }\n\n    const parser = DOMParser.fromSchema(schema)\n\n    if (options.slice) {\n      return parser.parseSlice(elementFromString(content), options.parseOptions).content\n    }\n\n    return parser.parse(elementFromString(content), options.parseOptions)\n  }\n\n  return createNodeFromContent('', schema, options)\n}\n","const removeWhitespaces = (node: HTMLElement) => {\n  const children = node.childNodes\n\n  for (let i = children.length - 1; i >= 0; i -= 1) {\n    const child = children[i]\n\n    if (child.nodeType === 3 && child.nodeValue && /^(\\n\\s\\s|\\n)$/.test(child.nodeValue)) {\n      node.removeChild(child)\n    } else if (child.nodeType === 1) {\n      removeWhitespaces(child as HTMLElement)\n    }\n  }\n\n  return node\n}\n\nexport function elementFromString(value: string): HTMLElement {\n  if (typeof window === 'undefined') {\n    throw new Error('[tiptap error]: there is no window object available, so this function cannot be used')\n  }\n  // add a wrapper to preserve leading and trailing whitespace\n  const wrappedValue = `<body>${value}</body>`\n\n  const html = new window.DOMParser().parseFromString(wrappedValue, 'text/html').body\n\n  return removeWhitespaces(html)\n}\n","import type { Transaction } from '@tiptap/pm/state'\nimport { Selection } from '@tiptap/pm/state'\nimport { ReplaceAroundStep, ReplaceStep } from '@tiptap/pm/transform'\n\n// source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466\nexport function selectionToInsertionEnd(tr: Transaction, startLen: number, bias: number) {\n  const last = tr.steps.length - 1\n\n  if (last < startLen) {\n    return\n  }\n\n  const step = tr.steps[last]\n\n  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep)) {\n    return\n  }\n\n  const map = tr.mapping.maps[last]\n  let end = 0\n\n  map.forEach((_from, _to, _newFrom, newTo) => {\n    if (end === 0) {\n      end = newTo\n    }\n  })\n\n  tr.setSelection(Selection.near(tr.doc.resolve(end), bias))\n}\n","import {\n  joinBackward as originalJoinBackward,\n  joinDown as originalJoinDown,\n  joinForward as originalJoinForward,\n  joinUp as originalJoinUp,\n} from '@tiptap/pm/commands'\n\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    joinUp: {\n      /**\n       * Join the selected block or, if there is a text selection, the closest ancestor block of the selection that can be joined, with the sibling above it.\n       * @example editor.commands.joinUp()\n       */\n      joinUp: () => ReturnType\n    }\n    joinDown: {\n      /**\n       * Join the selected block, or the closest ancestor of the selection that can be joined, with the sibling after it.\n       * @example editor.commands.joinDown()\n       */\n      joinDown: () => ReturnType\n    }\n    joinBackward: {\n      /**\n       * If the selection is empty and at the start of a textblock, try to reduce the distance between that block and the one before itâ€”if there's a block directly before it that can be joined, join them.\n       * If not, try to move the selected block closer to the next one in the document structure by lifting it out of its\n       * parent or moving it into a parent of the previous block. Will use the view for accurate (bidi-aware) start-of-textblock detection if given.\n       * @example editor.commands.joinBackward()\n       */\n      joinBackward: () => ReturnType\n    }\n    joinForward: {\n      /**\n       * If the selection is empty and the cursor is at the end of a textblock, try to reduce or remove the boundary between that block and the one after it,\n       * either by joining them or by moving the other block closer to this one in the tree structure.\n       * Will use the view for accurate start-of-textblock detection if given.\n       * @example editor.commands.joinForward()\n       */\n      joinForward: () => ReturnType\n    }\n  }\n}\n\nexport const joinUp: RawCommands['joinUp'] =\n  () =>\n  ({ state, dispatch }) => {\n    return originalJoinUp(state, dispatch)\n  }\n\nexport const joinDown: RawCommands['joinDown'] =\n  () =>\n  ({ state, dispatch }) => {\n    return originalJoinDown(state, dispatch)\n  }\n\nexport const joinBackward: RawCommands['joinBackward'] =\n  () =>\n  ({ state, dispatch }) => {\n    return originalJoinBackward(state, dispatch)\n  }\n\nexport const joinForward: RawCommands['joinForward'] =\n  () =>\n  ({ state, dispatch }) => {\n    return originalJoinForward(state, dispatch)\n  }\n","import { joinPoint } from '@tiptap/pm/transform'\n\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    joinItemBackward: {\n      /**\n       * Join two items backward.\n       * @example editor.commands.joinItemBackward()\n       */\n      joinItemBackward: () => ReturnType\n    }\n  }\n}\n\nexport const joinItemBackward: RawCommands['joinItemBackward'] =\n  () =>\n  ({ state, dispatch, tr }) => {\n    try {\n      const point = joinPoint(state.doc, state.selection.$from.pos, -1)\n\n      if (point === null || point === undefined) {\n        return false\n      }\n\n      tr.join(point, 2)\n\n      if (dispatch) {\n        dispatch(tr)\n      }\n\n      return true\n    } catch {\n      return false\n    }\n  }\n","import { joinPoint } from '@tiptap/pm/transform'\n\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    joinItemForward: {\n      /**\n       * Join two items Forwards.\n       * @example editor.commands.joinItemForward()\n       */\n      joinItemForward: () => ReturnType\n    }\n  }\n}\n\nexport const joinItemForward: RawCommands['joinItemForward'] =\n  () =>\n  ({ state, dispatch, tr }) => {\n    try {\n      const point = joinPoint(state.doc, state.selection.$from.pos, +1)\n\n      if (point === null || point === undefined) {\n        return false\n      }\n\n      tr.join(point, 2)\n\n      if (dispatch) {\n        dispatch(tr)\n      }\n\n      return true\n    } catch {\n      return false\n    }\n  }\n","import { joinTextblockBackward as originalCommand } from '@tiptap/pm/commands'\n\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    joinTextblockBackward: {\n      /**\n       * A more limited form of joinBackward that only tries to join the current textblock to the one before it, if the cursor is at the start of a textblock.\n       */\n      joinTextblockBackward: () => ReturnType\n    }\n  }\n}\n\nexport const joinTextblockBackward: RawCommands['joinTextblockBackward'] =\n  () =>\n  ({ state, dispatch }) => {\n    return originalCommand(state, dispatch)\n  }\n","import { joinTextblockForward as originalCommand } from '@tiptap/pm/commands'\n\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    joinTextblockForward: {\n      /**\n       * A more limited form of joinForward that only tries to join the current textblock to the one after it, if the cursor is at the end of a textblock.\n       */\n      joinTextblockForward: () => ReturnType\n    }\n  }\n}\n\nexport const joinTextblockForward: RawCommands['joinTextblockForward'] =\n  () =>\n  ({ state, dispatch }) => {\n    return originalCommand(state, dispatch)\n  }\n","export function isMacOS(): boolean {\n  return typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false\n}\n","import type { RawCommands } from '../types.js'\nimport { isiOS } from '../utilities/isiOS.js'\nimport { isMacOS } from '../utilities/isMacOS.js'\n\nfunction normalizeKeyName(name: string) {\n  const parts = name.split(/-(?!$)/)\n  let result = parts[parts.length - 1]\n\n  if (result === 'Space') {\n    result = ' '\n  }\n\n  let alt\n  let ctrl\n  let shift\n  let meta\n\n  for (let i = 0; i < parts.length - 1; i += 1) {\n    const mod = parts[i]\n\n    if (/^(cmd|meta|m)$/i.test(mod)) {\n      meta = true\n    } else if (/^a(lt)?$/i.test(mod)) {\n      alt = true\n    } else if (/^(c|ctrl|control)$/i.test(mod)) {\n      ctrl = true\n    } else if (/^s(hift)?$/i.test(mod)) {\n      shift = true\n    } else if (/^mod$/i.test(mod)) {\n      if (isiOS() || isMacOS()) {\n        meta = true\n      } else {\n        ctrl = true\n      }\n    } else {\n      throw new Error(`Unrecognized modifier name: ${mod}`)\n    }\n  }\n\n  if (alt) {\n    result = `Alt-${result}`\n  }\n\n  if (ctrl) {\n    result = `Ctrl-${result}`\n  }\n\n  if (meta) {\n    result = `Meta-${result}`\n  }\n\n  if (shift) {\n    result = `Shift-${result}`\n  }\n\n  return result\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    keyboardShortcut: {\n      /**\n       * Trigger a keyboard shortcut.\n       * @param name The name of the keyboard shortcut.\n       * @example editor.commands.keyboardShortcut('Mod-b')\n       */\n      keyboardShortcut: (name: string) => ReturnType\n    }\n  }\n}\n\nexport const keyboardShortcut: RawCommands['keyboardShortcut'] =\n  name =>\n  ({ editor, view, tr, dispatch }) => {\n    const keys = normalizeKeyName(name).split(/-(?!$)/)\n    const key = keys.find(item => !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(item))\n    const event = new KeyboardEvent('keydown', {\n      key: key === 'Space' ? ' ' : key,\n      altKey: keys.includes('Alt'),\n      ctrlKey: keys.includes('Ctrl'),\n      metaKey: keys.includes('Meta'),\n      shiftKey: keys.includes('Shift'),\n      bubbles: true,\n      cancelable: true,\n    })\n\n    const capturedTransaction = editor.captureTransaction(() => {\n      view.someProp('handleKeyDown', f => f(view, event))\n    })\n\n    capturedTransaction?.steps.forEach(step => {\n      const newStep = step.map(tr.mapping)\n\n      if (newStep && dispatch) {\n        tr.maybeStep(newStep)\n      }\n    })\n\n    return true\n  }\n","import { lift as originalLift } from '@tiptap/pm/commands'\nimport type { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { isNodeActive } from '../helpers/isNodeActive.js'\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    lift: {\n      /**\n       * Removes an existing wrap if possible lifting the node out of it\n       * @param typeOrName The type or name of the node.\n       * @param attributes The attributes of the node.\n       * @example editor.commands.lift('paragraph')\n       * @example editor.commands.lift('heading', { level: 1 })\n       */\n      lift: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const lift: RawCommands['lift'] =\n  (typeOrName, attributes = {}) =>\n  ({ state, dispatch }) => {\n    const type = getNodeType(typeOrName, state.schema)\n    const isActive = isNodeActive(state, type, attributes)\n\n    if (!isActive) {\n      return false\n    }\n\n    return originalLift(state, dispatch)\n  }\n","import type { NodeType } from '@tiptap/pm/model'\nimport type { EditorState } from '@tiptap/pm/state'\n\nimport type { NodeRange } from '../types.js'\nimport { objectIncludes } from '../utilities/objectIncludes.js'\nimport { getNodeType } from './getNodeType.js'\n\nexport function isNodeActive(\n  state: EditorState,\n  typeOrName: NodeType | string | null,\n  attributes: Record<string, any> = {},\n): boolean {\n  const { from, to, empty } = state.selection\n  const type = typeOrName ? getNodeType(typeOrName, state.schema) : null\n\n  const nodeRanges: NodeRange[] = []\n\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    if (node.isText) {\n      return\n    }\n\n    const relativeFrom = Math.max(from, pos)\n    const relativeTo = Math.min(to, pos + node.nodeSize)\n\n    nodeRanges.push({\n      node,\n      from: relativeFrom,\n      to: relativeTo,\n    })\n  })\n\n  const selectionRange = to - from\n  const matchedNodeRanges = nodeRanges\n    .filter(nodeRange => {\n      if (!type) {\n        return true\n      }\n\n      return type.name === nodeRange.node.type.name\n    })\n    .filter(nodeRange => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }))\n\n  if (empty) {\n    return !!matchedNodeRanges.length\n  }\n\n  const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0)\n\n  return range >= selectionRange\n}\n","import { liftEmptyBlock as originalLiftEmptyBlock } from '@tiptap/pm/commands'\n\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    liftEmptyBlock: {\n      /**\n       * If the cursor is in an empty textblock that can be lifted, lift the block.\n       * @example editor.commands.liftEmptyBlock()\n       */\n      liftEmptyBlock: () => ReturnType\n    }\n  }\n}\n\nexport const liftEmptyBlock: RawCommands['liftEmptyBlock'] =\n  () =>\n  ({ state, dispatch }) => {\n    return originalLiftEmptyBlock(state, dispatch)\n  }\n","import type { NodeType } from '@tiptap/pm/model'\nimport { liftListItem as originalLiftListItem } from '@tiptap/pm/schema-list'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    liftListItem: {\n      /**\n       * Create a command to lift the list item around the selection up into a wrapping list.\n       * @param typeOrName The type or name of the node.\n       * @example editor.commands.liftListItem('listItem')\n       */\n      liftListItem: (typeOrName: string | NodeType) => ReturnType\n    }\n  }\n}\n\nexport const liftListItem: RawCommands['liftListItem'] =\n  typeOrName =>\n  ({ state, dispatch }) => {\n    const type = getNodeType(typeOrName, state.schema)\n\n    return originalLiftListItem(type)(state, dispatch)\n  }\n","import { newlineInCode as originalNewlineInCode } from '@tiptap/pm/commands'\n\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    newlineInCode: {\n      /**\n       * Add a newline character in code.\n       * @example editor.commands.newlineInCode()\n       */\n      newlineInCode: () => ReturnType\n    }\n  }\n}\n\nexport const newlineInCode: RawCommands['newlineInCode'] =\n  () =>\n  ({ state, dispatch }) => {\n    return originalNewlineInCode(state, dispatch)\n  }\n","import type { Schema } from '@tiptap/pm/model'\n\n/**\n * Get the type of a schema item by its name.\n * @param name The name of the schema item\n * @param schema The Prosemiror schema to search in\n * @returns The type of the schema item (`node` or `mark`), or null if it doesn't exist\n */\nexport function getSchemaTypeNameByName(name: string, schema: Schema): 'node' | 'mark' | null {\n  if (schema.nodes[name]) {\n    return 'node'\n  }\n\n  if (schema.marks[name]) {\n    return 'mark'\n  }\n\n  return null\n}\n","/**\n * Remove a property or an array of properties from an object\n * @param obj Object\n * @param key Key to remove\n */\nexport function deleteProps(obj: Record<string, any>, propOrProps: string | string[]): Record<string, any> {\n  const props = typeof propOrProps === 'string' ? [propOrProps] : propOrProps\n\n  return Object.keys(obj).reduce((newObj: Record<string, any>, prop) => {\n    if (!props.includes(prop)) {\n      newObj[prop] = obj[prop]\n    }\n\n    return newObj\n  }, {})\n}\n","import type { MarkType, NodeType } from '@tiptap/pm/model'\n\nimport { getMarkType } from '../helpers/getMarkType.js'\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { getSchemaTypeNameByName } from '../helpers/getSchemaTypeNameByName.js'\nimport type { RawCommands } from '../types.js'\nimport { deleteProps } from '../utilities/deleteProps.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    resetAttributes: {\n      /**\n       * Resets some node attributes to the default value.\n       * @param typeOrName The type or name of the node.\n       * @param attributes The attributes of the node to reset.\n       * @example editor.commands.resetAttributes('heading', 'level')\n       */\n      resetAttributes: (typeOrName: string | NodeType | MarkType, attributes: string | string[]) => ReturnType\n    }\n  }\n}\n\nexport const resetAttributes: RawCommands['resetAttributes'] =\n  (typeOrName, attributes) =>\n  ({ tr, state, dispatch }) => {\n    let nodeType: NodeType | null = null\n    let markType: MarkType | null = null\n\n    const schemaType = getSchemaTypeNameByName(\n      typeof typeOrName === 'string' ? typeOrName : typeOrName.name,\n      state.schema,\n    )\n\n    if (!schemaType) {\n      return false\n    }\n\n    if (schemaType === 'node') {\n      nodeType = getNodeType(typeOrName as NodeType, state.schema)\n    }\n\n    if (schemaType === 'mark') {\n      markType = getMarkType(typeOrName as MarkType, state.schema)\n    }\n\n    let canReset = false\n\n    tr.selection.ranges.forEach(range => {\n      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\n        if (nodeType && nodeType === node.type) {\n          canReset = true\n\n          if (dispatch) {\n            tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes))\n          }\n        }\n\n        if (markType && node.marks.length) {\n          node.marks.forEach(mark => {\n            if (markType === mark.type) {\n              canReset = true\n\n              if (dispatch) {\n                tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)))\n              }\n            }\n          })\n        }\n      })\n    })\n\n    return canReset\n  }\n","import type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    scrollIntoView: {\n      /**\n       * Scroll the selection into view.\n       * @example editor.commands.scrollIntoView()\n       */\n      scrollIntoView: () => ReturnType\n    }\n  }\n}\n\nexport const scrollIntoView: RawCommands['scrollIntoView'] =\n  () =>\n  ({ tr, dispatch }) => {\n    if (dispatch) {\n      tr.scrollIntoView()\n    }\n\n    return true\n  }\n","import { AllSelection } from '@tiptap/pm/state'\n\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectAll: {\n      /**\n       * Select the whole document.\n       * @example editor.commands.selectAll()\n       */\n      selectAll: () => ReturnType\n    }\n  }\n}\n\nexport const selectAll: RawCommands['selectAll'] =\n  () =>\n  ({ tr, dispatch }) => {\n    if (dispatch) {\n      const selection = new AllSelection(tr.doc)\n\n      tr.setSelection(selection)\n    }\n\n    return true\n  }\n","import { selectNodeBackward as originalSelectNodeBackward } from '@tiptap/pm/commands'\n\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectNodeBackward: {\n      /**\n       * Select a node backward.\n       * @example editor.commands.selectNodeBackward()\n       */\n      selectNodeBackward: () => ReturnType\n    }\n  }\n}\n\nexport const selectNodeBackward: RawCommands['selectNodeBackward'] =\n  () =>\n  ({ state, dispatch }) => {\n    return originalSelectNodeBackward(state, dispatch)\n  }\n","import { selectNodeForward as originalSelectNodeForward } from '@tiptap/pm/commands'\n\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectNodeForward: {\n      /**\n       * Select a node forward.\n       * @example editor.commands.selectNodeForward()\n       */\n      selectNodeForward: () => ReturnType\n    }\n  }\n}\n\nexport const selectNodeForward: RawCommands['selectNodeForward'] =\n  () =>\n  ({ state, dispatch }) => {\n    return originalSelectNodeForward(state, dispatch)\n  }\n","import { selectParentNode as originalSelectParentNode } from '@tiptap/pm/commands'\n\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectParentNode: {\n      /**\n       * Select the parent node.\n       * @example editor.commands.selectParentNode()\n       */\n      selectParentNode: () => ReturnType\n    }\n  }\n}\n\nexport const selectParentNode: RawCommands['selectParentNode'] =\n  () =>\n  ({ state, dispatch }) => {\n    return originalSelectParentNode(state, dispatch)\n  }\n","// @ts-ignore\n// TODO: add types to @types/prosemirror-commands\nimport { selectTextblockEnd as originalSelectTextblockEnd } from '@tiptap/pm/commands'\n\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectTextblockEnd: {\n      /**\n       * Moves the cursor to the end of current text block.\n       * @example editor.commands.selectTextblockEnd()\n       */\n      selectTextblockEnd: () => ReturnType\n    }\n  }\n}\n\nexport const selectTextblockEnd: RawCommands['selectTextblockEnd'] =\n  () =>\n  ({ state, dispatch }) => {\n    return originalSelectTextblockEnd(state, dispatch)\n  }\n","// @ts-ignore\n// TODO: add types to @types/prosemirror-commands\nimport { selectTextblockStart as originalSelectTextblockStart } from '@tiptap/pm/commands'\n\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    selectTextblockStart: {\n      /**\n       * Moves the cursor to the start of current text block.\n       * @example editor.commands.selectTextblockStart()\n       */\n      selectTextblockStart: () => ReturnType\n    }\n  }\n}\n\nexport const selectTextblockStart: RawCommands['selectTextblockStart'] =\n  () =>\n  ({ state, dispatch }) => {\n    return originalSelectTextblockStart(state, dispatch)\n  }\n","import type { Fragment, Node as ProseMirrorNode, ParseOptions, Schema } from '@tiptap/pm/model'\n\nimport type { Content } from '../types.js'\nimport { createNodeFromContent } from './createNodeFromContent.js'\n\n/**\n * Create a new Prosemirror document node from content.\n * @param content The JSON or HTML content to create the document from\n * @param schema The Prosemirror schema to use for the document\n * @param parseOptions Options for the parser\n * @returns The created Prosemirror document node\n */\nexport function createDocument(\n  content: Content | ProseMirrorNode | Fragment,\n  schema: Schema,\n  parseOptions: ParseOptions = {},\n  options: { errorOnInvalidContent?: boolean } = {},\n): ProseMirrorNode {\n  return createNodeFromContent(content, schema, {\n    slice: false,\n    parseOptions,\n    errorOnInvalidContent: options.errorOnInvalidContent,\n  }) as ProseMirrorNode\n}\n","import type { Fragment, Node as ProseMirrorNode, ParseOptions } from '@tiptap/pm/model'\n\nimport { createDocument } from '../helpers/createDocument.js'\nimport type { Content, RawCommands } from '../types.js'\n\nexport interface SetContentOptions {\n  /**\n   * Options for parsing the content.\n   * @default {}\n   */\n  parseOptions?: ParseOptions\n\n  /**\n   * Whether to throw an error if the content is invalid.\n   */\n  errorOnInvalidContent?: boolean\n\n  /**\n   * Whether to emit an update event.\n   * @default true\n   */\n  emitUpdate?: boolean\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setContent: {\n      /**\n       * Replace the whole document with new content.\n       * @param content The new content.\n       * @param emitUpdate Whether to emit an update event.\n       * @param parseOptions Options for parsing the content.\n       * @example editor.commands.setContent('<p>Example text</p>')\n       */\n      setContent: (\n        /**\n         * The new content.\n         */\n        content: Content | Fragment | ProseMirrorNode,\n\n        /**\n         * Options for `setContent`.\n         */\n        options?: SetContentOptions,\n      ) => ReturnType\n    }\n  }\n}\n\nexport const setContent: RawCommands['setContent'] =\n  (content, { errorOnInvalidContent, emitUpdate = true, parseOptions = {} } = {}) =>\n  ({ editor, tr, dispatch, commands }) => {\n    const { doc } = tr\n\n    // This is to keep backward compatibility with the previous behavior\n    // TODO remove this in the next major version\n    if (parseOptions.preserveWhitespace !== 'full') {\n      const document = createDocument(content, editor.schema, parseOptions, {\n        errorOnInvalidContent: errorOnInvalidContent ?? editor.options.enableContentCheck,\n      })\n\n      if (dispatch) {\n        tr.replaceWith(0, doc.content.size, document).setMeta('preventUpdate', !emitUpdate)\n      }\n      return true\n    }\n\n    if (dispatch) {\n      tr.setMeta('preventUpdate', !emitUpdate)\n    }\n\n    return commands.insertContentAt({ from: 0, to: doc.content.size }, content, {\n      parseOptions,\n      errorOnInvalidContent: errorOnInvalidContent ?? editor.options.enableContentCheck,\n    })\n  }\n","import type { Mark, MarkType } from '@tiptap/pm/model'\nimport type { EditorState } from '@tiptap/pm/state'\n\nimport { getMarkType } from './getMarkType.js'\n\nexport function getMarkAttributes(state: EditorState, typeOrName: string | MarkType): Record<string, any> {\n  const type = getMarkType(typeOrName, state.schema)\n  const { from, to, empty } = state.selection\n  const marks: Mark[] = []\n\n  if (empty) {\n    if (state.storedMarks) {\n      marks.push(...state.storedMarks)\n    }\n\n    marks.push(...state.selection.$head.marks())\n  } else {\n    state.doc.nodesBetween(from, to, node => {\n      marks.push(...node.marks)\n    })\n  }\n\n  const mark = marks.find(markItem => markItem.type.name === type.name)\n\n  if (!mark) {\n    return {}\n  }\n\n  return { ...mark.attrs }\n}\n","import type { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport type { Transaction } from '@tiptap/pm/state'\nimport { Transform } from '@tiptap/pm/transform'\n\n/**\n * Returns a new `Transform` based on all steps of the passed transactions.\n * @param oldDoc The Prosemirror node to start from\n * @param transactions The transactions to combine\n * @returns A new `Transform` with all steps of the passed transactions\n */\nexport function combineTransactionSteps(oldDoc: ProseMirrorNode, transactions: Transaction[]): Transform {\n  const transform = new Transform(oldDoc)\n\n  transactions.forEach(transaction => {\n    transaction.steps.forEach(step => {\n      transform.step(step)\n    })\n  })\n\n  return transform\n}\n","import type { ContentMatch, NodeType } from '@tiptap/pm/model'\n\n/**\n * Gets the default block type at a given match\n * @param match The content match to get the default block type from\n * @returns The default block type or null\n */\nexport function defaultBlockAt(match: ContentMatch): NodeType | null {\n  for (let i = 0; i < match.edgeCount; i += 1) {\n    const { type } = match.edge(i)\n\n    if (type.isTextblock && !type.hasRequiredAttrs()) {\n      return type\n    }\n  }\n\n  return null\n}\n","import type { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport type { NodeWithPos, Predicate } from '../types.js'\n\n/**\n * Find children inside a Prosemirror node that match a predicate.\n * @param node The Prosemirror node to search in\n * @param predicate The predicate to match\n * @returns An array of nodes with their positions\n */\nexport function findChildren(node: ProseMirrorNode, predicate: Predicate): NodeWithPos[] {\n  const nodesWithPos: NodeWithPos[] = []\n\n  node.descendants((child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos,\n      })\n    }\n  })\n\n  return nodesWithPos\n}\n","import type { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport type { NodeWithPos, Predicate, Range } from '../types.js'\n\n/**\n * Same as `findChildren` but searches only within a `range`.\n * @param node The Prosemirror node to search in\n * @param range The range to search in\n * @param predicate The predicate to match\n * @returns An array of nodes with their positions\n */\nexport function findChildrenInRange(node: ProseMirrorNode, range: Range, predicate: Predicate): NodeWithPos[] {\n  const nodesWithPos: NodeWithPos[] = []\n\n  // if (range.from === range.to) {\n  //   const nodeAt = node.nodeAt(range.from)\n\n  //   if (nodeAt) {\n  //     nodesWithPos.push({\n  //       node: nodeAt,\n  //       pos: range.from,\n  //     })\n  //   }\n  // }\n\n  node.nodesBetween(range.from, range.to, (child, pos) => {\n    if (predicate(child)) {\n      nodesWithPos.push({\n        node: child,\n        pos,\n      })\n    }\n  })\n\n  return nodesWithPos\n}\n","import type { Node as ProseMirrorNode, ResolvedPos } from '@tiptap/pm/model'\n\nimport type { Predicate } from '../types.js'\n\n/**\n * Finds the closest parent node to a resolved position that matches a predicate.\n * @param $pos The resolved position to search from\n * @param predicate The predicate to match\n * @returns The closest parent node to the resolved position that matches the predicate\n * @example ```js\n * findParentNodeClosestToPos($from, node => node.type.name === 'paragraph')\n * ```\n */\nexport function findParentNodeClosestToPos(\n  $pos: ResolvedPos,\n  predicate: Predicate,\n):\n  | {\n      pos: number\n      start: number\n      depth: number\n      node: ProseMirrorNode\n    }\n  | undefined {\n  for (let i = $pos.depth; i > 0; i -= 1) {\n    const node = $pos.node(i)\n\n    if (predicate(node)) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node,\n      }\n    }\n  }\n}\n","import type { Selection } from '@tiptap/pm/state'\n\nimport type { Predicate } from '../types.js'\nimport { findParentNodeClosestToPos } from './findParentNodeClosestToPos.js'\n\n/**\n * Finds the closest parent node to the current selection that matches a predicate.\n * @param predicate The predicate to match\n * @returns A command that finds the closest parent node to the current selection that matches the predicate\n * @example ```js\n * findParentNode(node => node.type.name === 'paragraph')\n * ```\n */\nexport function findParentNode(\n  predicate: Predicate,\n): (selection: Selection) => ReturnType<typeof findParentNodeClosestToPos> {\n  return (selection: Selection) => findParentNodeClosestToPos(selection.$from, predicate)\n}\n","import type { ExtensionConfig } from '../Extension.js'\nimport type { MarkConfig } from '../Mark.js'\nimport type { NodeConfig } from '../Node.js'\nimport type { AnyExtension, MaybeThisParameterType, RemoveThis } from '../types.js'\n\n/**\n * Returns a field from an extension\n * @param extension The Tiptap extension\n * @param field The field, for example `renderHTML` or `priority`\n * @param context The context object that should be passed as `this` into the function\n * @returns The field value\n */\nexport function getExtensionField<T = any, E extends AnyExtension = any>(\n  extension: E,\n  field: keyof ExtensionConfig | keyof MarkConfig | keyof NodeConfig,\n  context?: Omit<MaybeThisParameterType<T>, 'parent'>,\n): RemoveThis<T> {\n  if (extension.config[field as keyof typeof extension.config] === undefined && extension.parent) {\n    return getExtensionField(extension.parent, field, context)\n  }\n\n  if (typeof extension.config[field as keyof typeof extension.config] === 'function') {\n    const value = (extension.config[field as keyof typeof extension.config] as any).bind({\n      ...context,\n      parent: extension.parent ? getExtensionField(extension.parent, field, context) : null,\n    })\n\n    return value\n  }\n\n  return extension.config[field as keyof typeof extension.config] as RemoveThis<T>\n}\n","import type { AnyConfig, Extensions } from '../types.js'\nimport { getExtensionField } from './getExtensionField.js'\n\n/**\n * Create a flattened array of extensions by traversing the `addExtensions` field.\n * @param extensions An array of Tiptap extensions\n * @returns A flattened array of Tiptap extensions\n */\nexport function flattenExtensions(extensions: Extensions): Extensions {\n  return (\n    extensions\n      .map(extension => {\n        const context = {\n          name: extension.name,\n          options: extension.options,\n          storage: extension.storage,\n        }\n\n        const addExtensions = getExtensionField<AnyConfig['addExtensions']>(extension, 'addExtensions', context)\n\n        if (addExtensions) {\n          return [extension, ...flattenExtensions(addExtensions())]\n        }\n\n        return extension\n      })\n      // `Infinity` will break TypeScript so we set a number that is probably high enough\n      .flat(10)\n  )\n}\n","import { Node } from '@tiptap/pm/model'\n\nimport type { Extensions, JSONContent } from '../types.js'\nimport { getHTMLFromFragment } from './getHTMLFromFragment.js'\nimport { getSchema } from './getSchema.js'\n\n/**\n * Generate HTML from a JSONContent\n * @param doc The JSONContent to generate HTML from\n * @param extensions The extensions to use for the schema\n * @returns The generated HTML\n */\nexport function generateHTML(doc: JSONContent, extensions: Extensions): string {\n  const schema = getSchema(extensions)\n  const contentNode = Node.fromJSON(schema, doc)\n\n  return getHTMLFromFragment(contentNode.content, schema)\n}\n","import type { Fragment, Schema } from '@tiptap/pm/model'\nimport { DOMSerializer } from '@tiptap/pm/model'\n\nexport function getHTMLFromFragment(fragment: Fragment, schema: Schema): string {\n  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment)\n\n  const temporaryDocument = document.implementation.createHTMLDocument()\n  const container = temporaryDocument.createElement('div')\n\n  container.appendChild(documentFragment)\n\n  return container.innerHTML\n}\n","import type { MarkSpec, NodeSpec, TagParseRule } from '@tiptap/pm/model'\nimport { Schema } from '@tiptap/pm/model'\n\nimport type { Editor, MarkConfig, NodeConfig } from '../index.js'\nimport type { AnyConfig, Extensions } from '../types.js'\nimport { callOrReturn } from '../utilities/callOrReturn.js'\nimport { isEmptyObject } from '../utilities/isEmptyObject.js'\nimport { getAttributesFromExtensions } from './getAttributesFromExtensions.js'\nimport { getExtensionField } from './getExtensionField.js'\nimport { getRenderedAttributes } from './getRenderedAttributes.js'\nimport { injectExtensionAttributesToParseRule } from './injectExtensionAttributesToParseRule.js'\nimport { splitExtensions } from './splitExtensions.js'\n\nfunction cleanUpSchemaItem<T>(data: T) {\n  return Object.fromEntries(\n    // @ts-ignore\n    Object.entries(data).filter(([key, value]) => {\n      if (key === 'attrs' && isEmptyObject(value as object | undefined)) {\n        return false\n      }\n\n      return value !== null && value !== undefined\n    }),\n  ) as T\n}\n\n/**\n * Builds an attribute spec tuple for ProseMirror schema from an extension attribute.\n * @param extensionAttribute The extension attribute to build the spec for\n * @returns A tuple of [attributeName, spec]\n */\nfunction buildAttributeSpec(\n  extensionAttribute: ReturnType<typeof getAttributesFromExtensions>[number],\n): [string, Record<string, any>] {\n  const spec: Record<string, any> = {}\n\n  // Only include 'default' if the attribute is not required and default is set on the attribute\n  if (!extensionAttribute?.attribute?.isRequired && 'default' in (extensionAttribute?.attribute || {})) {\n    spec.default = extensionAttribute.attribute.default\n  }\n\n  // Only include 'validate' if it's defined\n  if (extensionAttribute?.attribute?.validate !== undefined) {\n    spec.validate = extensionAttribute.attribute.validate\n  }\n\n  return [extensionAttribute.name, spec]\n}\n\n/**\n * Creates a new Prosemirror schema based on the given extensions.\n * @param extensions An array of Tiptap extensions\n * @param editor The editor instance\n * @returns A Prosemirror schema\n */\nexport function getSchemaByResolvedExtensions(extensions: Extensions, editor?: Editor): Schema {\n  const allAttributes = getAttributesFromExtensions(extensions)\n  const { nodeExtensions, markExtensions } = splitExtensions(extensions)\n  const topNode = nodeExtensions.find(extension => getExtensionField(extension, 'topNode'))?.name\n\n  const nodes = Object.fromEntries(\n    nodeExtensions.map(extension => {\n      const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name)\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor,\n      }\n\n      const extraNodeFields = extensions.reduce((fields, e) => {\n        const extendNodeSchema = getExtensionField<AnyConfig['extendNodeSchema']>(e, 'extendNodeSchema', context)\n\n        return {\n          ...fields,\n          ...(extendNodeSchema ? extendNodeSchema(extension) : {}),\n        }\n      }, {})\n\n      const schema: NodeSpec = cleanUpSchemaItem({\n        ...extraNodeFields,\n        content: callOrReturn(getExtensionField<NodeConfig['content']>(extension, 'content', context)),\n        marks: callOrReturn(getExtensionField<NodeConfig['marks']>(extension, 'marks', context)),\n        group: callOrReturn(getExtensionField<NodeConfig['group']>(extension, 'group', context)),\n        inline: callOrReturn(getExtensionField<NodeConfig['inline']>(extension, 'inline', context)),\n        atom: callOrReturn(getExtensionField<NodeConfig['atom']>(extension, 'atom', context)),\n        selectable: callOrReturn(getExtensionField<NodeConfig['selectable']>(extension, 'selectable', context)),\n        draggable: callOrReturn(getExtensionField<NodeConfig['draggable']>(extension, 'draggable', context)),\n        code: callOrReturn(getExtensionField<NodeConfig['code']>(extension, 'code', context)),\n        whitespace: callOrReturn(getExtensionField<NodeConfig['whitespace']>(extension, 'whitespace', context)),\n        linebreakReplacement: callOrReturn(\n          getExtensionField<NodeConfig['linebreakReplacement']>(extension, 'linebreakReplacement', context),\n        ),\n        defining: callOrReturn(getExtensionField<NodeConfig['defining']>(extension, 'defining', context)),\n        isolating: callOrReturn(getExtensionField<NodeConfig['isolating']>(extension, 'isolating', context)),\n        attrs: Object.fromEntries(extensionAttributes.map(buildAttributeSpec)),\n      })\n\n      const parseHTML = callOrReturn(getExtensionField<NodeConfig['parseHTML']>(extension, 'parseHTML', context))\n\n      if (parseHTML) {\n        schema.parseDOM = parseHTML.map(parseRule =>\n          injectExtensionAttributesToParseRule(parseRule, extensionAttributes),\n        ) as TagParseRule[]\n      }\n\n      const renderHTML = getExtensionField<NodeConfig['renderHTML']>(extension, 'renderHTML', context)\n\n      if (renderHTML) {\n        schema.toDOM = node =>\n          renderHTML({\n            node,\n            HTMLAttributes: getRenderedAttributes(node, extensionAttributes),\n          })\n      }\n\n      const renderText = getExtensionField<NodeConfig['renderText']>(extension, 'renderText', context)\n\n      if (renderText) {\n        schema.toText = renderText\n      }\n\n      return [extension.name, schema]\n    }),\n  )\n\n  const marks = Object.fromEntries(\n    markExtensions.map(extension => {\n      const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name)\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n        editor,\n      }\n\n      const extraMarkFields = extensions.reduce((fields, e) => {\n        const extendMarkSchema = getExtensionField<AnyConfig['extendMarkSchema']>(e, 'extendMarkSchema', context)\n\n        return {\n          ...fields,\n          ...(extendMarkSchema ? extendMarkSchema(extension as any) : {}),\n        }\n      }, {})\n\n      const schema: MarkSpec = cleanUpSchemaItem({\n        ...extraMarkFields,\n        inclusive: callOrReturn(getExtensionField<MarkConfig['inclusive']>(extension, 'inclusive', context)),\n        excludes: callOrReturn(getExtensionField<MarkConfig['excludes']>(extension, 'excludes', context)),\n        group: callOrReturn(getExtensionField<MarkConfig['group']>(extension, 'group', context)),\n        spanning: callOrReturn(getExtensionField<MarkConfig['spanning']>(extension, 'spanning', context)),\n        code: callOrReturn(getExtensionField<MarkConfig['code']>(extension, 'code', context)),\n        attrs: Object.fromEntries(extensionAttributes.map(buildAttributeSpec)),\n      })\n\n      const parseHTML = callOrReturn(getExtensionField<MarkConfig['parseHTML']>(extension, 'parseHTML', context))\n\n      if (parseHTML) {\n        schema.parseDOM = parseHTML.map(parseRule =>\n          injectExtensionAttributesToParseRule(parseRule, extensionAttributes),\n        )\n      }\n\n      const renderHTML = getExtensionField<MarkConfig['renderHTML']>(extension, 'renderHTML', context)\n\n      if (renderHTML) {\n        schema.toDOM = mark =>\n          renderHTML({\n            mark,\n            HTMLAttributes: getRenderedAttributes(mark, extensionAttributes),\n          })\n      }\n\n      return [extension.name, schema]\n    }),\n  )\n\n  return new Schema({\n    topNode,\n    nodes,\n    marks,\n  })\n}\n","// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\nexport function isFunction(value: any): value is Function {\n  return typeof value === 'function'\n}\n","import type { MaybeReturnType } from '../types.js'\nimport { isFunction } from './isFunction.js'\n\n/**\n * Optionally calls `value` as a function.\n * Otherwise it is returned directly.\n * @param value Function or any value.\n * @param context Optional context to bind to function.\n * @param props Optional props to pass to function.\n */\nexport function callOrReturn<T>(value: T, context: any = undefined, ...props: any[]): MaybeReturnType<T> {\n  if (isFunction(value)) {\n    if (context) {\n      return value.bind(context)(...props)\n    }\n\n    return value(...props)\n  }\n\n  return value as MaybeReturnType<T>\n}\n","export function isEmptyObject(value = {}): boolean {\n  return Object.keys(value).length === 0 && value.constructor === Object\n}\n","import type { Extension } from '../Extension.js'\nimport type { Mark } from '../Mark.js'\nimport type { Node } from '../Node.js'\nimport type { Extensions } from '../types.js'\n\nexport function splitExtensions(extensions: Extensions) {\n  const baseExtensions = extensions.filter(extension => extension.type === 'extension') as Extension[]\n  const nodeExtensions = extensions.filter(extension => extension.type === 'node') as Node[]\n  const markExtensions = extensions.filter(extension => extension.type === 'mark') as Mark[]\n\n  return {\n    baseExtensions,\n    nodeExtensions,\n    markExtensions,\n  }\n}\n","import type { MarkConfig, NodeConfig } from '../index.js'\nimport type { AnyConfig, Attribute, Attributes, ExtensionAttribute, Extensions } from '../types.js'\nimport { getExtensionField } from './getExtensionField.js'\nimport { splitExtensions } from './splitExtensions.js'\n\n/**\n * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.\n * @param extensions List of extensions\n */\nexport function getAttributesFromExtensions(extensions: Extensions): ExtensionAttribute[] {\n  const extensionAttributes: ExtensionAttribute[] = []\n  const { nodeExtensions, markExtensions } = splitExtensions(extensions)\n  const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions]\n  const defaultAttribute: Required<Omit<Attribute, 'validate'>> & Pick<Attribute, 'validate'> = {\n    default: null,\n    validate: undefined,\n    rendered: true,\n    renderHTML: null,\n    parseHTML: null,\n    keepOnSplit: true,\n    isRequired: false,\n  }\n\n  extensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n      extensions: nodeAndMarkExtensions,\n    }\n\n    const addGlobalAttributes = getExtensionField<AnyConfig['addGlobalAttributes']>(\n      extension,\n      'addGlobalAttributes',\n      context,\n    )\n\n    if (!addGlobalAttributes) {\n      return\n    }\n\n    const globalAttributes = addGlobalAttributes()\n\n    globalAttributes.forEach(globalAttribute => {\n      globalAttribute.types.forEach(type => {\n        Object.entries(globalAttribute.attributes).forEach(([name, attribute]) => {\n          extensionAttributes.push({\n            type,\n            name,\n            attribute: {\n              ...defaultAttribute,\n              ...attribute,\n            },\n          })\n        })\n      })\n    })\n  })\n\n  nodeAndMarkExtensions.forEach(extension => {\n    const context = {\n      name: extension.name,\n      options: extension.options,\n      storage: extension.storage,\n    }\n\n    const addAttributes = getExtensionField<NodeConfig['addAttributes'] | MarkConfig['addAttributes']>(\n      extension,\n      'addAttributes',\n      context,\n    )\n\n    if (!addAttributes) {\n      return\n    }\n\n    // TODO: remove `as Attributes`\n    const attributes = addAttributes() as Attributes\n\n    Object.entries(attributes).forEach(([name, attribute]) => {\n      const mergedAttr = {\n        ...defaultAttribute,\n        ...attribute,\n      }\n\n      if (typeof mergedAttr?.default === 'function') {\n        mergedAttr.default = mergedAttr.default()\n      }\n\n      if (mergedAttr?.isRequired && mergedAttr?.default === undefined) {\n        delete mergedAttr.default\n      }\n\n      extensionAttributes.push({\n        type: extension.name,\n        name,\n        attribute: mergedAttr,\n      })\n    })\n  })\n\n  return extensionAttributes\n}\n","export function mergeAttributes(...objects: Record<string, any>[]): Record<string, any> {\n  return objects\n    .filter(item => !!item)\n    .reduce((items, item) => {\n      const mergedAttributes = { ...items }\n\n      Object.entries(item).forEach(([key, value]) => {\n        const exists = mergedAttributes[key]\n\n        if (!exists) {\n          mergedAttributes[key] = value\n\n          return\n        }\n\n        if (key === 'class') {\n          const valueClasses: string[] = value ? String(value).split(' ') : []\n          const existingClasses: string[] = mergedAttributes[key] ? mergedAttributes[key].split(' ') : []\n\n          const insertClasses = valueClasses.filter(valueClass => !existingClasses.includes(valueClass))\n\n          mergedAttributes[key] = [...existingClasses, ...insertClasses].join(' ')\n        } else if (key === 'style') {\n          const newStyles: string[] = value\n            ? value\n                .split(';')\n                .map((style: string) => style.trim())\n                .filter(Boolean)\n            : []\n          const existingStyles: string[] = mergedAttributes[key]\n            ? mergedAttributes[key]\n                .split(';')\n                .map((style: string) => style.trim())\n                .filter(Boolean)\n            : []\n\n          const styleMap = new Map<string, string>()\n\n          existingStyles.forEach(style => {\n            const [property, val] = style.split(':').map(part => part.trim())\n\n            styleMap.set(property, val)\n          })\n\n          newStyles.forEach(style => {\n            const [property, val] = style.split(':').map(part => part.trim())\n\n            styleMap.set(property, val)\n          })\n\n          mergedAttributes[key] = Array.from(styleMap.entries())\n            .map(([property, val]) => `${property}: ${val}`)\n            .join('; ')\n        } else {\n          mergedAttributes[key] = value\n        }\n      })\n\n      return mergedAttributes\n    }, {})\n}\n","import type { Mark, Node } from '@tiptap/pm/model'\n\nimport type { ExtensionAttribute } from '../types.js'\nimport { mergeAttributes } from '../utilities/mergeAttributes.js'\n\nexport function getRenderedAttributes(\n  nodeOrMark: Node | Mark,\n  extensionAttributes: ExtensionAttribute[],\n): Record<string, any> {\n  return extensionAttributes\n    .filter(attribute => attribute.type === nodeOrMark.type.name)\n    .filter(item => item.attribute.rendered)\n    .map(item => {\n      if (!item.attribute.renderHTML) {\n        return {\n          [item.name]: nodeOrMark.attrs[item.name],\n        }\n      }\n\n      return item.attribute.renderHTML(nodeOrMark.attrs) || {}\n    })\n    .reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {})\n}\n","export function fromString(value: any): any {\n  if (typeof value !== 'string') {\n    return value\n  }\n\n  if (value.match(/^[+-]?(?:\\d*\\.)?\\d+$/)) {\n    return Number(value)\n  }\n\n  if (value === 'true') {\n    return true\n  }\n\n  if (value === 'false') {\n    return false\n  }\n\n  return value\n}\n","import type { ParseRule } from '@tiptap/pm/model'\n\nimport type { ExtensionAttribute } from '../types.js'\nimport { fromString } from '../utilities/fromString.js'\n\n/**\n * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).\n * Cancels when `getAttrs` returned `false`.\n * @param parseRule ProseMirror ParseRule\n * @param extensionAttributes List of attributes to inject\n */\nexport function injectExtensionAttributesToParseRule(\n  parseRule: ParseRule,\n  extensionAttributes: ExtensionAttribute[],\n): ParseRule {\n  if ('style' in parseRule) {\n    return parseRule\n  }\n\n  return {\n    ...parseRule,\n    getAttrs: (node: HTMLElement) => {\n      const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs\n\n      if (oldAttributes === false) {\n        return false\n      }\n\n      const newAttributes = extensionAttributes.reduce((items, item) => {\n        const value = item.attribute.parseHTML\n          ? item.attribute.parseHTML(node)\n          : fromString(node.getAttribute(item.name))\n\n        if (value === null || value === undefined) {\n          return items\n        }\n\n        return {\n          ...items,\n          [item.name]: value,\n        }\n      }, {})\n\n      return { ...oldAttributes, ...newAttributes }\n    },\n  }\n}\n","/**\n * Find duplicates in an array.\n */\nexport function findDuplicates<T>(items: T[]): T[] {\n  const filtered = items.filter((el, index) => items.indexOf(el) !== index)\n\n  return Array.from(new Set(filtered))\n}\n","import type { AnyConfig, Extensions } from '../types.js'\nimport { getExtensionField } from './getExtensionField.js'\n\n/**\n * Sort extensions by priority.\n * @param extensions An array of Tiptap extensions\n * @returns A sorted array of Tiptap extensions by priority\n */\nexport function sortExtensions(extensions: Extensions): Extensions {\n  const defaultPriority = 100\n\n  return extensions.sort((a, b) => {\n    const priorityA = getExtensionField<AnyConfig['priority']>(a, 'priority') || defaultPriority\n    const priorityB = getExtensionField<AnyConfig['priority']>(b, 'priority') || defaultPriority\n\n    if (priorityA > priorityB) {\n      return -1\n    }\n\n    if (priorityA < priorityB) {\n      return 1\n    }\n\n    return 0\n  })\n}\n","import type { Extensions } from '../types.js'\nimport { findDuplicates } from '../utilities/findDuplicates.js'\nimport { flattenExtensions } from './flattenExtensions.js'\nimport { sortExtensions } from './sortExtensions.js'\n\n/**\n * Returns a flattened and sorted extension list while\n * also checking for duplicated extensions and warns the user.\n * @param extensions An array of Tiptap extensions\n * @returns An flattened and sorted array of Tiptap extensions\n */\nexport function resolveExtensions(extensions: Extensions): Extensions {\n  const resolvedExtensions = sortExtensions(flattenExtensions(extensions))\n  const duplicatedNames = findDuplicates(resolvedExtensions.map(extension => extension.name))\n\n  if (duplicatedNames.length) {\n    console.warn(\n      `[tiptap warn]: Duplicate extension names found: [${duplicatedNames\n        .map(item => `'${item}'`)\n        .join(', ')}]. This can lead to issues.`,\n    )\n  }\n\n  return resolvedExtensions\n}\n","import type { Schema } from '@tiptap/pm/model'\n\nimport type { Editor } from '../Editor.js'\nimport type { Extensions } from '../types.js'\nimport { getSchemaByResolvedExtensions } from './getSchemaByResolvedExtensions.js'\nimport { resolveExtensions } from './resolveExtensions.js'\n\nexport function getSchema(extensions: Extensions, editor?: Editor): Schema {\n  const resolvedExtensions = resolveExtensions(extensions)\n\n  return getSchemaByResolvedExtensions(resolvedExtensions, editor)\n}\n","import { DOMParser } from '@tiptap/pm/model'\n\nimport type { Extensions } from '../types.js'\nimport { elementFromString } from '../utilities/elementFromString.js'\nimport { getSchema } from './getSchema.js'\n\n/**\n * Generate JSONContent from HTML\n * @param html The HTML to generate JSONContent from\n * @param extensions The extensions to use for the schema\n * @returns The generated JSONContent\n */\nexport function generateJSON(html: string, extensions: Extensions): Record<string, any> {\n  const schema = getSchema(extensions)\n  const dom = elementFromString(html)\n\n  return DOMParser.fromSchema(schema).parse(dom).toJSON()\n}\n","import { Node } from '@tiptap/pm/model'\n\nimport type { Extensions, JSONContent, TextSerializer } from '../types.js'\nimport { getSchema } from './getSchema.js'\nimport { getText } from './getText.js'\nimport { getTextSerializersFromSchema } from './getTextSerializersFromSchema.js'\n\n/**\n * Generate raw text from a JSONContent\n * @param doc The JSONContent to generate text from\n * @param extensions The extensions to use for the schema\n * @param options Options for the text generation f.e. blockSeparator or textSerializers\n * @returns The generated text\n */\nexport function generateText(\n  doc: JSONContent,\n  extensions: Extensions,\n  options?: {\n    blockSeparator?: string\n    textSerializers?: Record<string, TextSerializer>\n  },\n): string {\n  const { blockSeparator = '\\n\\n', textSerializers = {} } = options || {}\n  const schema = getSchema(extensions)\n  const contentNode = Node.fromJSON(schema, doc)\n\n  return getText(contentNode, {\n    blockSeparator,\n    textSerializers: {\n      ...getTextSerializersFromSchema(schema),\n      ...textSerializers,\n    },\n  })\n}\n","import type { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport type { Range, TextSerializer } from '../types.js'\n\n/**\n * Gets the text between two positions in a Prosemirror node\n * and serializes it using the given text serializers and block separator (see getText)\n * @param startNode The Prosemirror node to start from\n * @param range The range of the text to get\n * @param options Options for the text serializer & block separator\n * @returns The text between the two positions\n */\nexport function getTextBetween(\n  startNode: ProseMirrorNode,\n  range: Range,\n  options?: {\n    blockSeparator?: string\n    textSerializers?: Record<string, TextSerializer>\n  },\n): string {\n  const { from, to } = range\n  const { blockSeparator = '\\n\\n', textSerializers = {} } = options || {}\n  let text = ''\n\n  startNode.nodesBetween(from, to, (node, pos, parent, index) => {\n    if (node.isBlock && pos > from) {\n      text += blockSeparator\n    }\n\n    const textSerializer = textSerializers?.[node.type.name]\n\n    if (textSerializer) {\n      if (parent) {\n        text += textSerializer({\n          node,\n          pos,\n          parent,\n          index,\n          range,\n        })\n      }\n      // do not descend into child nodes when there exists a serializer\n      return false\n    }\n\n    if (node.isText) {\n      text += node?.text?.slice(Math.max(from, pos) - pos, to - pos) // eslint-disable-line\n    }\n  })\n\n  return text\n}\n","import type { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport type { TextSerializer } from '../types.js'\nimport { getTextBetween } from './getTextBetween.js'\n\n/**\n * Gets the text of a Prosemirror node\n * @param node The Prosemirror node\n * @param options Options for the text serializer & block separator\n * @returns The text of the node\n * @example ```js\n * const text = getText(node, { blockSeparator: '\\n' })\n * ```\n */\nexport function getText(\n  node: ProseMirrorNode,\n  options?: {\n    blockSeparator?: string\n    textSerializers?: Record<string, TextSerializer>\n  },\n) {\n  const range = {\n    from: 0,\n    to: node.content.size,\n  }\n\n  return getTextBetween(node, range, options)\n}\n","import type { Schema } from '@tiptap/pm/model'\n\nimport type { TextSerializer } from '../types.js'\n\n/**\n * Find text serializers `toText` in a Prosemirror schema\n * @param schema The Prosemirror schema to search in\n * @returns A record of text serializers by node name\n */\nexport function getTextSerializersFromSchema(schema: Schema): Record<string, TextSerializer> {\n  return Object.fromEntries(\n    Object.entries(schema.nodes)\n      .filter(([, node]) => node.spec.toText)\n      .map(([name, node]) => [name, node.spec.toText]),\n  )\n}\n","import type { Node, NodeType } from '@tiptap/pm/model'\nimport type { EditorState } from '@tiptap/pm/state'\n\nimport { getNodeType } from './getNodeType.js'\n\nexport function getNodeAttributes(state: EditorState, typeOrName: string | NodeType): Record<string, any> {\n  const type = getNodeType(typeOrName, state.schema)\n  const { from, to } = state.selection\n  const nodes: Node[] = []\n\n  state.doc.nodesBetween(from, to, node => {\n    nodes.push(node)\n  })\n\n  const node = nodes.reverse().find(nodeItem => nodeItem.type.name === type.name)\n\n  if (!node) {\n    return {}\n  }\n\n  return { ...node.attrs }\n}\n","import type { MarkType, NodeType } from '@tiptap/pm/model'\nimport type { EditorState } from '@tiptap/pm/state'\n\nimport { getMarkAttributes } from './getMarkAttributes.js'\nimport { getNodeAttributes } from './getNodeAttributes.js'\nimport { getSchemaTypeNameByName } from './getSchemaTypeNameByName.js'\n\n/**\n * Get node or mark attributes by type or name on the current editor state\n * @param state The current editor state\n * @param typeOrName The node or mark type or name\n * @returns The attributes of the node or mark or an empty object\n */\nexport function getAttributes(state: EditorState, typeOrName: string | NodeType | MarkType): Record<string, any> {\n  const schemaType = getSchemaTypeNameByName(\n    typeof typeOrName === 'string' ? typeOrName : typeOrName.name,\n    state.schema,\n  )\n\n  if (schemaType === 'node') {\n    return getNodeAttributes(state, typeOrName as NodeType)\n  }\n\n  if (schemaType === 'mark') {\n    return getMarkAttributes(state, typeOrName as MarkType)\n  }\n\n  return {}\n}\n","/**\n * Removes duplicated values within an array.\n * Supports numbers, strings and objects.\n */\nexport function removeDuplicates<T>(array: T[], by = JSON.stringify): T[] {\n  const seen: Record<any, any> = {}\n\n  return array.filter(item => {\n    const key = by(item)\n\n    return Object.prototype.hasOwnProperty.call(seen, key) ? false : (seen[key] = true)\n  })\n}\n","import type { Step, Transform } from '@tiptap/pm/transform'\n\nimport type { Range } from '../types.js'\nimport { removeDuplicates } from '../utilities/removeDuplicates.js'\n\nexport type ChangedRange = {\n  oldRange: Range\n  newRange: Range\n}\n\n/**\n * Removes duplicated ranges and ranges that are\n * fully captured by other ranges.\n */\nfunction simplifyChangedRanges(changes: ChangedRange[]): ChangedRange[] {\n  const uniqueChanges = removeDuplicates(changes)\n\n  return uniqueChanges.length === 1\n    ? uniqueChanges\n    : uniqueChanges.filter((change, index) => {\n        const rest = uniqueChanges.filter((_, i) => i !== index)\n\n        return !rest.some(otherChange => {\n          return (\n            change.oldRange.from >= otherChange.oldRange.from &&\n            change.oldRange.to <= otherChange.oldRange.to &&\n            change.newRange.from >= otherChange.newRange.from &&\n            change.newRange.to <= otherChange.newRange.to\n          )\n        })\n      })\n}\n\n/**\n * Returns a list of changed ranges\n * based on the first and last state of all steps.\n */\nexport function getChangedRanges(transform: Transform): ChangedRange[] {\n  const { mapping, steps } = transform\n  const changes: ChangedRange[] = []\n\n  mapping.maps.forEach((stepMap, index) => {\n    const ranges: Range[] = []\n\n    // This accounts for step changes where no range was actually altered\n    // e.g. when setting a mark, node attribute, etc.\n    // @ts-ignore\n    if (!stepMap.ranges.length) {\n      const { from, to } = steps[index] as Step & {\n        from?: number\n        to?: number\n      }\n\n      if (from === undefined || to === undefined) {\n        return\n      }\n\n      ranges.push({ from, to })\n    } else {\n      stepMap.forEach((from, to) => {\n        ranges.push({ from, to })\n      })\n    }\n\n    ranges.forEach(({ from, to }) => {\n      const newStart = mapping.slice(index).map(from, -1)\n      const newEnd = mapping.slice(index).map(to)\n      const oldStart = mapping.invert().map(newStart, -1)\n      const oldEnd = mapping.invert().map(newEnd)\n\n      changes.push({\n        oldRange: {\n          from: oldStart,\n          to: oldEnd,\n        },\n        newRange: {\n          from: newStart,\n          to: newEnd,\n        },\n      })\n    })\n  })\n\n  return simplifyChangedRanges(changes)\n}\n","import type { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport type { JSONContent } from '../types.js'\n\ninterface DebugJSONContent extends JSONContent {\n  from: number\n  to: number\n}\n\nexport function getDebugJSON(node: ProseMirrorNode, startOffset = 0): DebugJSONContent {\n  const isTopNode = node.type === node.type.schema.topNodeType\n  const increment = isTopNode ? 0 : 1\n  const from = startOffset\n  const to = from + node.nodeSize\n  const marks = node.marks.map(mark => {\n    const output: { type: string; attrs?: Record<string, any> } = {\n      type: mark.type.name,\n    }\n\n    if (Object.keys(mark.attrs).length) {\n      output.attrs = { ...mark.attrs }\n    }\n\n    return output\n  })\n  const attrs = { ...node.attrs }\n  const output: DebugJSONContent = {\n    type: node.type.name,\n    from,\n    to,\n  }\n\n  if (Object.keys(attrs).length) {\n    output.attrs = attrs\n  }\n\n  if (marks.length) {\n    output.marks = marks\n  }\n\n  if (node.content.childCount) {\n    output.content = []\n\n    node.forEach((child, offset) => {\n      output.content?.push(getDebugJSON(child, startOffset + offset + increment))\n    })\n  }\n\n  if (node.text) {\n    output.text = node.text\n  }\n\n  return output\n}\n","import type { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\nimport type { MarkRange } from '../types.js'\nimport { getMarkRange } from './getMarkRange.js'\n\nexport function getMarksBetween(from: number, to: number, doc: ProseMirrorNode): MarkRange[] {\n  const marks: MarkRange[] = []\n\n  // get all inclusive marks on empty selection\n  if (from === to) {\n    doc\n      .resolve(from)\n      .marks()\n      .forEach(mark => {\n        const $pos = doc.resolve(from)\n        const range = getMarkRange($pos, mark.type)\n\n        if (!range) {\n          return\n        }\n\n        marks.push({\n          mark,\n          ...range,\n        })\n      })\n  } else {\n    doc.nodesBetween(from, to, (node, pos) => {\n      if (!node || node?.nodeSize === undefined) {\n        return\n      }\n\n      marks.push(\n        ...node.marks.map(mark => ({\n          from: pos,\n          to: pos + node.nodeSize,\n          mark,\n        })),\n      )\n    })\n  }\n\n  return marks\n}\n","import type { Node, NodeType } from '@tiptap/pm/model'\nimport type { EditorState } from '@tiptap/pm/state'\n\n/**\n * Finds the first node of a given type or name in the current selection.\n * @param state The editor state.\n * @param typeOrName The node type or name.\n * @param pos The position to start searching from.\n * @param maxDepth The maximum depth to search.\n * @returns The node and the depth as an array.\n */\nexport const getNodeAtPosition = (state: EditorState, typeOrName: string | NodeType, pos: number, maxDepth = 20) => {\n  const $pos = state.doc.resolve(pos)\n\n  let currentDepth = maxDepth\n  let node: Node | null = null\n\n  while (currentDepth > 0 && node === null) {\n    const currentNode = $pos.node(currentDepth)\n\n    if (currentNode?.type.name === typeOrName) {\n      node = currentNode\n    } else {\n      currentDepth -= 1\n    }\n  }\n\n  return [node, currentDepth] as [Node | null, number]\n}\n","import type { MarkType, NodeType, Schema } from '@tiptap/pm/model'\n\n/**\n * Tries to get a node or mark type by its name.\n * @param name The name of the node or mark type\n * @param schema The Prosemiror schema to search in\n * @returns The node or mark type, or null if it doesn't exist\n */\nexport function getSchemaTypeByName(name: string, schema: Schema): NodeType | MarkType | null {\n  return schema.nodes[name] || schema.marks[name] || null\n}\n","import type { ExtensionAttribute } from '../types.js'\n\n/**\n * Return attributes of an extension that should be splitted by keepOnSplit flag\n * @param extensionAttributes Array of extension attributes\n * @param typeName The type of the extension\n * @param attributes The attributes of the extension\n * @returns The splitted attributes\n */\nexport function getSplittedAttributes(\n  extensionAttributes: ExtensionAttribute[],\n  typeName: string,\n  attributes: Record<string, any>,\n): Record<string, any> {\n  return Object.fromEntries(\n    Object.entries(attributes).filter(([name]) => {\n      const extensionAttribute = extensionAttributes.find(item => {\n        return item.type === typeName && item.name === name\n      })\n\n      if (!extensionAttribute) {\n        return false\n      }\n\n      return extensionAttribute.attribute.keepOnSplit\n    }),\n  )\n}\n","import type { ResolvedPos } from '@tiptap/pm/model'\n\n/**\n * Returns the text content of a resolved prosemirror position\n * @param $from The resolved position to get the text content from\n * @param maxMatch The maximum number of characters to match\n * @returns The text content\n */\nexport const getTextContentFromNodes = ($from: ResolvedPos, maxMatch = 500) => {\n  let textBefore = ''\n\n  const sliceEndPos = $from.parentOffset\n\n  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index) => {\n    const chunk =\n      node.type.spec.toText?.({\n        node,\n        pos,\n        parent,\n        index,\n      }) ||\n      node.textContent ||\n      '%leaf%'\n\n    textBefore += node.isAtom && !node.isText ? chunk : chunk.slice(0, Math.max(0, sliceEndPos - pos))\n  })\n\n  return textBefore\n}\n","import type { MarkType } from '@tiptap/pm/model'\nimport type { EditorState } from '@tiptap/pm/state'\n\nimport type { MarkRange } from '../types.js'\nimport { objectIncludes } from '../utilities/objectIncludes.js'\nimport { getMarkType } from './getMarkType.js'\n\nexport function isMarkActive(\n  state: EditorState,\n  typeOrName: MarkType | string | null,\n  attributes: Record<string, any> = {},\n): boolean {\n  const { empty, ranges } = state.selection\n  const type = typeOrName ? getMarkType(typeOrName, state.schema) : null\n\n  if (empty) {\n    return !!(state.storedMarks || state.selection.$from.marks())\n      .filter(mark => {\n        if (!type) {\n          return true\n        }\n\n        return type.name === mark.type.name\n      })\n      .find(mark => objectIncludes(mark.attrs, attributes, { strict: false }))\n  }\n\n  let selectionRange = 0\n  const markRanges: MarkRange[] = []\n\n  ranges.forEach(({ $from, $to }) => {\n    const from = $from.pos\n    const to = $to.pos\n\n    state.doc.nodesBetween(from, to, (node, pos) => {\n      if (!node.isText && !node.marks.length) {\n        return\n      }\n\n      const relativeFrom = Math.max(from, pos)\n      const relativeTo = Math.min(to, pos + node.nodeSize)\n      const range = relativeTo - relativeFrom\n\n      selectionRange += range\n\n      markRanges.push(\n        ...node.marks.map(mark => ({\n          mark,\n          from: relativeFrom,\n          to: relativeTo,\n        })),\n      )\n    })\n  })\n\n  if (selectionRange === 0) {\n    return false\n  }\n\n  // calculate range of matched mark\n  const matchedRange = markRanges\n    .filter(markRange => {\n      if (!type) {\n        return true\n      }\n\n      return type.name === markRange.mark.type.name\n    })\n    .filter(markRange => objectIncludes(markRange.mark.attrs, attributes, { strict: false }))\n    .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0)\n\n  // calculate range of marks that excludes the searched mark\n  // for example `code` doesnâ€™t allow any other marks\n  const excludedRange = markRanges\n    .filter(markRange => {\n      if (!type) {\n        return true\n      }\n\n      return markRange.mark.type !== type && markRange.mark.type.excludes(type)\n    })\n    .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0)\n\n  // we only include the result of `excludedRange`\n  // if there is a match at all\n  const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange\n\n  return range >= selectionRange\n}\n","import type { EditorState } from '@tiptap/pm/state'\n\nimport { getSchemaTypeNameByName } from './getSchemaTypeNameByName.js'\nimport { isMarkActive } from './isMarkActive.js'\nimport { isNodeActive } from './isNodeActive.js'\n\nexport function isActive(state: EditorState, name: string | null, attributes: Record<string, any> = {}): boolean {\n  if (!name) {\n    return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes)\n  }\n\n  const schemaType = getSchemaTypeNameByName(name, state.schema)\n\n  if (schemaType === 'node') {\n    return isNodeActive(state, name, attributes)\n  }\n\n  if (schemaType === 'mark') {\n    return isMarkActive(state, name, attributes)\n  }\n\n  return false\n}\n","import type { EditorState } from '@tiptap/pm/state'\n\nimport { findParentNode } from './findParentNode.js'\n\nexport const isAtEndOfNode = (state: EditorState, nodeType?: string) => {\n  const { $from, $to, $anchor } = state.selection\n\n  if (nodeType) {\n    const parentNode = findParentNode(node => node.type.name === nodeType)(state.selection)\n\n    if (!parentNode) {\n      return false\n    }\n\n    const $parentPos = state.doc.resolve(parentNode.pos + 1)\n\n    if ($anchor.pos + 1 === $parentPos.end()) {\n      return true\n    }\n\n    return false\n  }\n\n  if ($to.parentOffset < $to.parent.nodeSize - 2 || $from.pos !== $to.pos) {\n    return false\n  }\n\n  return true\n}\n","import type { EditorState } from '@tiptap/pm/state'\n\nexport const isAtStartOfNode = (state: EditorState) => {\n  const { $from, $to } = state.selection\n\n  if ($from.parentOffset > 0 || $from.pos !== $to.pos) {\n    return false\n  }\n\n  return true\n}\n","import type { AnyExtension, EnableRules } from '../types.js'\n\nexport function isExtensionRulesEnabled(extension: AnyExtension, enabled: EnableRules): boolean {\n  if (Array.isArray(enabled)) {\n    return enabled.some(enabledExtension => {\n      const name = typeof enabledExtension === 'string' ? enabledExtension : enabledExtension.name\n\n      return name === extension.name\n    })\n  }\n\n  return enabled\n}\n","import { getExtensionField } from '../helpers/getExtensionField.js'\nimport type { NodeConfig } from '../index.js'\nimport type { Extensions } from '../types.js'\nimport { callOrReturn } from '../utilities/callOrReturn.js'\nimport { splitExtensions } from './splitExtensions.js'\n\nexport function isList(name: string, extensions: Extensions): boolean {\n  const { nodeExtensions } = splitExtensions(extensions)\n  const extension = nodeExtensions.find(item => item.name === name)\n\n  if (!extension) {\n    return false\n  }\n\n  const context = {\n    name: extension.name,\n    options: extension.options,\n    storage: extension.storage,\n  }\n  const group = callOrReturn(getExtensionField<NodeConfig['group']>(extension, 'group', context))\n\n  if (typeof group !== 'string') {\n    return false\n  }\n\n  return group.split(' ').includes('list')\n}\n","import type { Node as ProseMirrorNode } from '@tiptap/pm/model'\n\n/**\n * Returns true if the given prosemirror node is empty.\n */\nexport function isNodeEmpty(\n  node: ProseMirrorNode,\n  {\n    checkChildren = true,\n    ignoreWhitespace = false,\n  }: {\n    /**\n     * When true (default), it will also check if all children are empty.\n     */\n    checkChildren?: boolean\n    /**\n     * When true, it will ignore whitespace when checking for emptiness.\n     */\n    ignoreWhitespace?: boolean\n  } = {},\n): boolean {\n  if (ignoreWhitespace) {\n    if (node.type.name === 'hardBreak') {\n      // Hard breaks are considered empty\n      return true\n    }\n    if (node.isText) {\n      return /^\\s*$/m.test(node.text ?? '')\n    }\n  }\n\n  if (node.isText) {\n    return !node.text\n  }\n\n  if (node.isAtom || node.isLeaf) {\n    return false\n  }\n\n  if (node.content.childCount === 0) {\n    return true\n  }\n\n  if (checkChildren) {\n    let isContentEmpty = true\n\n    node.content.forEach(childNode => {\n      if (isContentEmpty === false) {\n        // Exit early for perf\n        return\n      }\n\n      if (!isNodeEmpty(childNode, { ignoreWhitespace, checkChildren })) {\n        isContentEmpty = false\n      }\n    })\n\n    return isContentEmpty\n  }\n\n  return false\n}\n","import { NodeSelection } from '@tiptap/pm/state'\n\nexport function isNodeSelection(value: unknown): value is NodeSelection {\n  return value instanceof NodeSelection\n}\n","import type { Transaction } from '@tiptap/pm/state'\nimport type { MapResult } from '@tiptap/pm/transform'\n\n/**\n * A class that represents a mappable position in the editor. It can be extended\n * by other extensions to add additional position mapping capabilities.\n */\nexport class MappablePosition {\n  /**\n   * The absolute position in the editor.\n   */\n  public position: number\n\n  constructor(position: number) {\n    this.position = position\n  }\n\n  /**\n   * Creates a MappablePosition from a JSON object.\n   */\n  static fromJSON(json: any): MappablePosition {\n    return new MappablePosition(json.position)\n  }\n\n  /**\n   * Converts the MappablePosition to a JSON object.\n   */\n  toJSON(): any {\n    return {\n      position: this.position,\n    }\n  }\n}\n\n/**\n * The result of the getUpdatedPosition function.\n */\nexport interface GetUpdatedPositionResult {\n  position: MappablePosition\n  mapResult: MapResult | null\n}\n\n/**\n * Calculates the new position after applying a transaction.\n *\n * @returns The new mappable position and the map result.\n */\nexport function getUpdatedPosition(position: MappablePosition, transaction: Transaction): GetUpdatedPositionResult {\n  const mapResult = transaction.mapping.mapResult(position.position)\n  return {\n    position: new MappablePosition(mapResult.pos),\n    mapResult,\n  }\n}\n\n/**\n * Creates a MappablePosition from a position number. This is the default\n * implementation for Tiptap core. It can be overridden by other Tiptap\n * extensions.\n *\n * @param position The position (as a number) where the MappablePosition will be created.\n * @returns A new MappablePosition instance at the given position.\n */\nexport function createMappablePosition(position: number): MappablePosition {\n  return new MappablePosition(position)\n}\n","import type { EditorView } from '@tiptap/pm/view'\n\nimport { minMax } from '../utilities/minMax.js'\n\nexport function posToDOMRect(view: EditorView, from: number, to: number): DOMRect {\n  const minPos = 0\n  const maxPos = view.state.doc.content.size\n  const resolvedFrom = minMax(from, minPos, maxPos)\n  const resolvedEnd = minMax(to, minPos, maxPos)\n  const start = view.coordsAtPos(resolvedFrom)\n  const end = view.coordsAtPos(resolvedEnd, -1)\n  const top = Math.min(start.top, end.top)\n  const bottom = Math.max(start.bottom, end.bottom)\n  const left = Math.min(start.left, end.left)\n  const right = Math.max(start.right, end.right)\n  const width = right - left\n  const height = bottom - top\n  const x = left\n  const y = top\n  const data = {\n    top,\n    bottom,\n    left,\n    right,\n    width,\n    height,\n    x,\n    y,\n  }\n\n  return {\n    ...data,\n    toJSON: () => data,\n  }\n}\n","import type { Schema } from '@tiptap/pm/model'\n\nimport type { JSONContent } from '../types.js'\n\ntype RewriteUnknownContentOptions = {\n  /**\n   * If true, unknown nodes will be treated as paragraphs\n   * @default true\n   */\n  fallbackToParagraph?: boolean\n}\n\ntype RewrittenContent = {\n  /**\n   * The original JSON content that was rewritten\n   */\n  original: JSONContent\n  /**\n   * The name of the node or mark that was unsupported\n   */\n  unsupported: string\n}[]\n\n/**\n * The actual implementation of the rewriteUnknownContent function\n */\nfunction rewriteUnknownContentInner({\n  json,\n  validMarks,\n  validNodes,\n  options,\n  rewrittenContent = [],\n}: {\n  json: JSONContent\n  validMarks: Set<string>\n  validNodes: Set<string>\n  options?: RewriteUnknownContentOptions\n  rewrittenContent?: RewrittenContent\n}): {\n  /**\n   * The cleaned JSON content\n   */\n  json: JSONContent | null\n  /**\n   * The array of nodes and marks that were rewritten\n   */\n  rewrittenContent: RewrittenContent\n} {\n  if (json.marks && Array.isArray(json.marks)) {\n    json.marks = json.marks.filter(mark => {\n      const name = typeof mark === 'string' ? mark : mark.type\n\n      if (validMarks.has(name)) {\n        return true\n      }\n\n      rewrittenContent.push({\n        original: JSON.parse(JSON.stringify(mark)),\n        unsupported: name,\n      })\n      // Just ignore any unknown marks\n      return false\n    })\n  }\n\n  if (json.content && Array.isArray(json.content)) {\n    json.content = json.content\n      .map(\n        value =>\n          rewriteUnknownContentInner({\n            json: value,\n            validMarks,\n            validNodes,\n            options,\n            rewrittenContent,\n          }).json,\n      )\n      .filter(a => a !== null && a !== undefined)\n  }\n\n  if (json.type && !validNodes.has(json.type)) {\n    rewrittenContent.push({\n      original: JSON.parse(JSON.stringify(json)),\n      unsupported: json.type,\n    })\n\n    if (json.content && Array.isArray(json.content) && options?.fallbackToParagraph !== false) {\n      // Just treat it like a paragraph and hope for the best\n      json.type = 'paragraph'\n\n      return {\n        json,\n        rewrittenContent,\n      }\n    }\n\n    // or just omit it entirely\n    return {\n      json: null,\n      rewrittenContent,\n    }\n  }\n\n  return { json, rewrittenContent }\n}\n\n/**\n * Rewrite unknown nodes and marks within JSON content\n * Allowing for user within the editor\n */\nexport function rewriteUnknownContent(\n  /**\n   * The JSON content to clean of unknown nodes and marks\n   */\n  json: JSONContent,\n  /**\n   * The schema to use for validation\n   */\n  schema: Schema,\n  /**\n   * Options for the cleaning process\n   */\n  options?: RewriteUnknownContentOptions,\n): {\n  /**\n   * The cleaned JSON content\n   */\n  json: JSONContent | null\n  /**\n   * The array of nodes and marks that were rewritten\n   */\n  rewrittenContent: {\n    /**\n     * The original JSON content that was rewritten\n     */\n    original: JSONContent\n    /**\n     * The name of the node or mark that was unsupported\n     */\n    unsupported: string\n  }[]\n} {\n  return rewriteUnknownContentInner({\n    json,\n    validNodes: new Set(Object.keys(schema.nodes)),\n    validMarks: new Set(Object.keys(schema.marks)),\n    options,\n  })\n}\n","import type { MarkType, ResolvedPos } from '@tiptap/pm/model'\nimport type { EditorState, Transaction } from '@tiptap/pm/state'\n\nimport { getMarkAttributes } from '../helpers/getMarkAttributes.js'\nimport { getMarkType } from '../helpers/getMarkType.js'\nimport { isTextSelection } from '../helpers/index.js'\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setMark: {\n      /**\n       * Add a mark with new attributes.\n       * @param typeOrName The mark type or name.\n       * @example editor.commands.setMark('bold', { level: 1 })\n       */\n      setMark: (typeOrName: string | MarkType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nfunction canSetMark(state: EditorState, tr: Transaction, newMarkType: MarkType) {\n  const { selection } = tr\n  let cursor: ResolvedPos | null = null\n\n  if (isTextSelection(selection)) {\n    cursor = selection.$cursor\n  }\n\n  if (cursor) {\n    const currentMarks = state.storedMarks ?? cursor.marks()\n    const parentAllowsMarkType = cursor.parent.type.allowsMarkType(newMarkType)\n\n    // There can be no current marks that exclude the new mark, and the parent must allow this mark type\n    return (\n      parentAllowsMarkType &&\n      (!!newMarkType.isInSet(currentMarks) || !currentMarks.some(mark => mark.type.excludes(newMarkType)))\n    )\n  }\n\n  const { ranges } = selection\n\n  return ranges.some(({ $from, $to }) => {\n    let someNodeSupportsMark =\n      $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false\n\n    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {\n      // If we already found a mark that we can enable, return false to bypass the remaining search\n      if (someNodeSupportsMark) {\n        return false\n      }\n\n      if (node.isInline) {\n        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType)\n        const currentMarksAllowMarkType =\n          !!newMarkType.isInSet(node.marks) || !node.marks.some(otherMark => otherMark.type.excludes(newMarkType))\n\n        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType\n      }\n      return !someNodeSupportsMark\n    })\n\n    return someNodeSupportsMark\n  })\n}\nexport const setMark: RawCommands['setMark'] =\n  (typeOrName, attributes = {}) =>\n  ({ tr, state, dispatch }) => {\n    const { selection } = tr\n    const { empty, ranges } = selection\n    const type = getMarkType(typeOrName, state.schema)\n\n    if (dispatch) {\n      if (empty) {\n        const oldAttributes = getMarkAttributes(state, type)\n\n        tr.addStoredMark(\n          type.create({\n            ...oldAttributes,\n            ...attributes,\n          }),\n        )\n      } else {\n        ranges.forEach(range => {\n          const from = range.$from.pos\n          const to = range.$to.pos\n\n          state.doc.nodesBetween(from, to, (node, pos) => {\n            const trimmedFrom = Math.max(pos, from)\n            const trimmedTo = Math.min(pos + node.nodeSize, to)\n            const someHasMark = node.marks.find(mark => mark.type === type)\n\n            // if there is already a mark of this type\n            // we know that we have to merge its attributes\n            // otherwise we add a fresh new mark\n            if (someHasMark) {\n              node.marks.forEach(mark => {\n                if (type === mark.type) {\n                  tr.addMark(\n                    trimmedFrom,\n                    trimmedTo,\n                    type.create({\n                      ...mark.attrs,\n                      ...attributes,\n                    }),\n                  )\n                }\n              })\n            } else {\n              tr.addMark(trimmedFrom, trimmedTo, type.create(attributes))\n            }\n          })\n        })\n      }\n    }\n\n    return canSetMark(state, tr, type)\n  }\n","import type { Plugin, PluginKey } from '@tiptap/pm/state'\n\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setMeta: {\n      /**\n       * Store a metadata property in the current transaction.\n       * @param key The key of the metadata property.\n       * @param value The value to store.\n       * @example editor.commands.setMeta('foo', 'bar')\n       */\n      setMeta: (key: string | Plugin | PluginKey, value: any) => ReturnType\n    }\n  }\n}\n\nexport const setMeta: RawCommands['setMeta'] =\n  (key, value) =>\n  ({ tr }) => {\n    tr.setMeta(key, value)\n\n    return true\n  }\n","import { setBlockType } from '@tiptap/pm/commands'\nimport type { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setNode: {\n      /**\n       * Replace a given range with a node.\n       * @param typeOrName The type or name of the node\n       * @param attributes The attributes of the node\n       * @example editor.commands.setNode('paragraph')\n       */\n      setNode: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const setNode: RawCommands['setNode'] =\n  (typeOrName, attributes = {}) =>\n  ({ state, dispatch, chain }) => {\n    const type = getNodeType(typeOrName, state.schema)\n\n    let attributesToCopy: Record<string, any> | undefined\n\n    if (state.selection.$anchor.sameParent(state.selection.$head)) {\n      // only copy attributes if the selection is pointing to a node of the same type\n      attributesToCopy = state.selection.$anchor.parent.attrs\n    }\n\n    // TODO: use a fallback like insertContent?\n    if (!type.isTextblock) {\n      console.warn('[tiptap warn]: Currently \"setNode()\" only supports text block nodes.')\n\n      return false\n    }\n\n    return (\n      chain()\n        // try to convert node to default node if needed\n        .command(({ commands }) => {\n          const canSetBlock = setBlockType(type, { ...attributesToCopy, ...attributes })(state)\n\n          if (canSetBlock) {\n            return true\n          }\n\n          return commands.clearNodes()\n        })\n        .command(({ state: updatedState }) => {\n          return setBlockType(type, { ...attributesToCopy, ...attributes })(updatedState, dispatch)\n        })\n        .run()\n    )\n  }\n","import { NodeSelection } from '@tiptap/pm/state'\n\nimport type { RawCommands } from '../types.js'\nimport { minMax } from '../utilities/minMax.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setNodeSelection: {\n      /**\n       * Creates a NodeSelection.\n       * @param position - Position of the node.\n       * @example editor.commands.setNodeSelection(10)\n       */\n      setNodeSelection: (position: number) => ReturnType\n    }\n  }\n}\n\nexport const setNodeSelection: RawCommands['setNodeSelection'] =\n  position =>\n  ({ tr, dispatch }) => {\n    if (dispatch) {\n      const { doc } = tr\n      const from = minMax(position, 0, doc.content.size)\n      const selection = NodeSelection.create(doc, from)\n\n      tr.setSelection(selection)\n    }\n\n    return true\n  }\n","import type { Range, RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setTextDirection: {\n      /**\n       * Set the text direction for nodes.\n       * If no position is provided, it will use the current selection.\n       * @param direction The text direction to set ('ltr', 'rtl', or 'auto')\n       * @param position Optional position or range to apply the direction to\n       * @example editor.commands.setTextDirection('rtl')\n       * @example editor.commands.setTextDirection('ltr', { from: 0, to: 10 })\n       */\n      setTextDirection: (direction: 'ltr' | 'rtl' | 'auto', position?: number | Range) => ReturnType\n    }\n  }\n}\n\nexport const setTextDirection: RawCommands['setTextDirection'] =\n  (direction, position) =>\n  ({ tr, state, dispatch }) => {\n    const { selection } = state\n    let from: number\n    let to: number\n\n    if (typeof position === 'number') {\n      from = position\n      to = position\n    } else if (position && 'from' in position && 'to' in position) {\n      from = position.from\n      to = position.to\n    } else {\n      from = selection.from\n      to = selection.to\n    }\n\n    if (dispatch) {\n      tr.doc.nodesBetween(from, to, (node, pos) => {\n        if (node.isText) {\n          return\n        }\n\n        tr.setNodeMarkup(pos, undefined, {\n          ...node.attrs,\n          dir: direction,\n        })\n      })\n    }\n\n    return true\n  }\n","import { TextSelection } from '@tiptap/pm/state'\n\nimport type { Range, RawCommands } from '../types.js'\nimport { minMax } from '../utilities/minMax.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    setTextSelection: {\n      /**\n       * Creates a TextSelection.\n       * @param position The position of the selection.\n       * @example editor.commands.setTextSelection(10)\n       */\n      setTextSelection: (position: number | Range) => ReturnType\n    }\n  }\n}\n\nexport const setTextSelection: RawCommands['setTextSelection'] =\n  position =>\n  ({ tr, dispatch }) => {\n    if (dispatch) {\n      const { doc } = tr\n      const { from, to } = typeof position === 'number' ? { from: position, to: position } : position\n      const minPos = TextSelection.atStart(doc).from\n      const maxPos = TextSelection.atEnd(doc).to\n      const resolvedFrom = minMax(from, minPos, maxPos)\n      const resolvedEnd = minMax(to, minPos, maxPos)\n      const selection = TextSelection.create(doc, resolvedFrom, resolvedEnd)\n\n      tr.setSelection(selection)\n    }\n\n    return true\n  }\n","import type { NodeType } from '@tiptap/pm/model'\nimport { sinkListItem as originalSinkListItem } from '@tiptap/pm/schema-list'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    sinkListItem: {\n      /**\n       * Sink the list item down into an inner list.\n       * @param typeOrName The type or name of the node.\n       * @example editor.commands.sinkListItem('listItem')\n       */\n      sinkListItem: (typeOrName: string | NodeType) => ReturnType\n    }\n  }\n}\n\nexport const sinkListItem: RawCommands['sinkListItem'] =\n  typeOrName =>\n  ({ state, dispatch }) => {\n    const type = getNodeType(typeOrName, state.schema)\n\n    return originalSinkListItem(type)(state, dispatch)\n  }\n","import type { EditorState } from '@tiptap/pm/state'\nimport { NodeSelection, TextSelection } from '@tiptap/pm/state'\nimport { canSplit } from '@tiptap/pm/transform'\n\nimport { defaultBlockAt } from '../helpers/defaultBlockAt.js'\nimport { getSplittedAttributes } from '../helpers/getSplittedAttributes.js'\nimport type { RawCommands } from '../types.js'\n\nfunction ensureMarks(state: EditorState, splittableMarks?: string[]) {\n  const marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks())\n\n  if (marks) {\n    const filteredMarks = marks.filter(mark => splittableMarks?.includes(mark.type.name))\n\n    state.tr.ensureMarks(filteredMarks)\n  }\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    splitBlock: {\n      /**\n       * Forks a new node from an existing node.\n       * @param options.keepMarks Keep marks from the previous node.\n       * @example editor.commands.splitBlock()\n       * @example editor.commands.splitBlock({ keepMarks: true })\n       */\n      splitBlock: (options?: { keepMarks?: boolean }) => ReturnType\n    }\n  }\n}\n\nexport const splitBlock: RawCommands['splitBlock'] =\n  ({ keepMarks = true } = {}) =>\n  ({ tr, state, dispatch, editor }) => {\n    const { selection, doc } = tr\n    const { $from, $to } = selection\n    const extensionAttributes = editor.extensionManager.attributes\n    const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs)\n\n    if (selection instanceof NodeSelection && selection.node.isBlock) {\n      if (!$from.parentOffset || !canSplit(doc, $from.pos)) {\n        return false\n      }\n\n      if (dispatch) {\n        if (keepMarks) {\n          ensureMarks(state, editor.extensionManager.splittableMarks)\n        }\n\n        tr.split($from.pos).scrollIntoView()\n      }\n\n      return true\n    }\n\n    if (!$from.parent.isBlock) {\n      return false\n    }\n\n    const atEnd = $to.parentOffset === $to.parent.content.size\n\n    const deflt = $from.depth === 0 ? undefined : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)))\n\n    let types =\n      atEnd && deflt\n        ? [\n            {\n              type: deflt,\n              attrs: newAttributes,\n            },\n          ]\n        : undefined\n\n    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types)\n\n    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : undefined)) {\n      can = true\n      types = deflt\n        ? [\n            {\n              type: deflt,\n              attrs: newAttributes,\n            },\n          ]\n        : undefined\n    }\n\n    if (dispatch) {\n      if (can) {\n        if (selection instanceof TextSelection) {\n          tr.deleteSelection()\n        }\n\n        tr.split(tr.mapping.map($from.pos), 1, types)\n\n        if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {\n          const first = tr.mapping.map($from.before())\n          const $first = tr.doc.resolve(first)\n\n          if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {\n            tr.setNodeMarkup(tr.mapping.map($from.before()), deflt)\n          }\n        }\n      }\n\n      if (keepMarks) {\n        ensureMarks(state, editor.extensionManager.splittableMarks)\n      }\n\n      tr.scrollIntoView()\n    }\n\n    return can\n  }\n","import type { Node as ProseMirrorNode, NodeType } from '@tiptap/pm/model'\nimport { Fragment, Slice } from '@tiptap/pm/model'\nimport { TextSelection } from '@tiptap/pm/state'\nimport { canSplit } from '@tiptap/pm/transform'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { getSplittedAttributes } from '../helpers/getSplittedAttributes.js'\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    splitListItem: {\n      /**\n       * Splits one list item into two list items.\n       * @param typeOrName The type or name of the node.\n       * @param overrideAttrs The attributes to ensure on the new node.\n       * @example editor.commands.splitListItem('listItem')\n       */\n      splitListItem: (typeOrName: string | NodeType, overrideAttrs?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const splitListItem: RawCommands['splitListItem'] =\n  (typeOrName, overrideAttrs = {}) =>\n  ({ tr, state, dispatch, editor }) => {\n    const type = getNodeType(typeOrName, state.schema)\n    const { $from, $to } = state.selection\n\n    // @ts-ignore\n    // eslint-disable-next-line\n    const node: ProseMirrorNode = state.selection.node\n\n    if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) {\n      return false\n    }\n\n    const grandParent = $from.node(-1)\n\n    if (grandParent.type !== type) {\n      return false\n    }\n\n    const extensionAttributes = editor.extensionManager.attributes\n\n    if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n      // In an empty block. If this is a nested list, the wrapping\n      // list item should be split. Otherwise, bail out and let next\n      // command handle lifting.\n      if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {\n        return false\n      }\n\n      if (dispatch) {\n        let wrap = Fragment.empty\n        // eslint-disable-next-line\n        const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3\n\n        // Build a fragment containing empty versions of the structure\n        // from the outer list item to the parent node of the cursor\n        for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {\n          wrap = Fragment.from($from.node(d).copy(wrap))\n        }\n\n        const depthAfter =\n          // eslint-disable-next-line no-nested-ternary\n          $from.indexAfter(-1) < $from.node(-2).childCount\n            ? 1\n            : $from.indexAfter(-2) < $from.node(-3).childCount\n              ? 2\n              : 3\n\n        // Add a second list item with an empty default start node\n        const newNextTypeAttributes = {\n          ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),\n          ...overrideAttrs,\n        }\n        const nextType = type.contentMatch.defaultType?.createAndFill(newNextTypeAttributes) || undefined\n\n        wrap = wrap.append(Fragment.from(type.createAndFill(null, nextType) || undefined))\n\n        const start = $from.before($from.depth - (depthBefore - 1))\n\n        tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0))\n\n        let sel = -1\n\n        tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {\n          if (sel > -1) {\n            return false\n          }\n\n          if (n.isTextblock && n.content.size === 0) {\n            sel = pos + 1\n          }\n        })\n\n        if (sel > -1) {\n          tr.setSelection(TextSelection.near(tr.doc.resolve(sel)))\n        }\n\n        tr.scrollIntoView()\n      }\n\n      return true\n    }\n\n    const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null\n\n    const newTypeAttributes = {\n      ...getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs),\n      ...overrideAttrs,\n    }\n    const newNextTypeAttributes = {\n      ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),\n      ...overrideAttrs,\n    }\n\n    tr.delete($from.pos, $to.pos)\n\n    const types = nextType\n      ? [\n          { type, attrs: newTypeAttributes },\n          { type: nextType, attrs: newNextTypeAttributes },\n        ]\n      : [{ type, attrs: newTypeAttributes }]\n\n    if (!canSplit(tr.doc, $from.pos, 2)) {\n      return false\n    }\n\n    if (dispatch) {\n      const { selection, storedMarks } = state\n      const { splittableMarks } = editor.extensionManager\n      const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks())\n\n      tr.split($from.pos, 2, types).scrollIntoView()\n\n      if (!marks || !dispatch) {\n        return true\n      }\n\n      const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name))\n\n      tr.ensureMarks(filteredMarks)\n    }\n\n    return true\n  }\n","import type { NodeType } from '@tiptap/pm/model'\nimport type { Transaction } from '@tiptap/pm/state'\nimport { canJoin } from '@tiptap/pm/transform'\n\nimport { findParentNode } from '../helpers/findParentNode.js'\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { isList } from '../helpers/isList.js'\nimport type { RawCommands } from '../types.js'\n\nconst joinListBackwards = (tr: Transaction, listType: NodeType): boolean => {\n  const list = findParentNode(node => node.type === listType)(tr.selection)\n\n  if (!list) {\n    return true\n  }\n\n  const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth)\n\n  if (before === undefined) {\n    return true\n  }\n\n  const nodeBefore = tr.doc.nodeAt(before)\n  const canJoinBackwards = list.node.type === nodeBefore?.type && canJoin(tr.doc, list.pos)\n\n  if (!canJoinBackwards) {\n    return true\n  }\n\n  tr.join(list.pos)\n\n  return true\n}\n\nconst joinListForwards = (tr: Transaction, listType: NodeType): boolean => {\n  const list = findParentNode(node => node.type === listType)(tr.selection)\n\n  if (!list) {\n    return true\n  }\n\n  const after = tr.doc.resolve(list.start).after(list.depth)\n\n  if (after === undefined) {\n    return true\n  }\n\n  const nodeAfter = tr.doc.nodeAt(after)\n  const canJoinForwards = list.node.type === nodeAfter?.type && canJoin(tr.doc, after)\n\n  if (!canJoinForwards) {\n    return true\n  }\n\n  tr.join(after)\n\n  return true\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    toggleList: {\n      /**\n       * Toggle between different list types.\n       * @param listTypeOrName The type or name of the list.\n       * @param itemTypeOrName The type or name of the list item.\n       * @param keepMarks Keep marks when toggling.\n       * @param attributes Attributes for the new list.\n       * @example editor.commands.toggleList('bulletList', 'listItem')\n       */\n      toggleList: (\n        listTypeOrName: string | NodeType,\n        itemTypeOrName: string | NodeType,\n        keepMarks?: boolean,\n        attributes?: Record<string, any>,\n      ) => ReturnType\n    }\n  }\n}\n\nexport const toggleList: RawCommands['toggleList'] =\n  (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) =>\n  ({ editor, tr, state, dispatch, chain, commands, can }) => {\n    const { extensions, splittableMarks } = editor.extensionManager\n    const listType = getNodeType(listTypeOrName, state.schema)\n    const itemType = getNodeType(itemTypeOrName, state.schema)\n    const { selection, storedMarks } = state\n    const { $from, $to } = selection\n    const range = $from.blockRange($to)\n\n    const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks())\n\n    if (!range) {\n      return false\n    }\n\n    const parentList = findParentNode(node => isList(node.type.name, extensions))(selection)\n\n    if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n      // remove list\n      if (parentList.node.type === listType) {\n        return commands.liftListItem(itemType)\n      }\n\n      // change list type\n      if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {\n        return chain()\n          .command(() => {\n            tr.setNodeMarkup(parentList.pos, listType)\n\n            return true\n          })\n          .command(() => joinListBackwards(tr, listType))\n          .command(() => joinListForwards(tr, listType))\n          .run()\n      }\n    }\n    if (!keepMarks || !marks || !dispatch) {\n      return (\n        chain()\n          // try to convert node to default node if needed\n          .command(() => {\n            const canWrapInList = can().wrapInList(listType, attributes)\n\n            if (canWrapInList) {\n              return true\n            }\n\n            return commands.clearNodes()\n          })\n          .wrapInList(listType, attributes)\n          .command(() => joinListBackwards(tr, listType))\n          .command(() => joinListForwards(tr, listType))\n          .run()\n      )\n    }\n\n    return (\n      chain()\n        // try to convert node to default node if needed\n        .command(() => {\n          const canWrapInList = can().wrapInList(listType, attributes)\n\n          const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name))\n\n          tr.ensureMarks(filteredMarks)\n\n          if (canWrapInList) {\n            return true\n          }\n\n          return commands.clearNodes()\n        })\n        .wrapInList(listType, attributes)\n        .command(() => joinListBackwards(tr, listType))\n        .command(() => joinListForwards(tr, listType))\n        .run()\n    )\n  }\n","import type { MarkType } from '@tiptap/pm/model'\n\nimport { getMarkType } from '../helpers/getMarkType.js'\nimport { isMarkActive } from '../helpers/isMarkActive.js'\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    toggleMark: {\n      /**\n       * Toggle a mark on and off.\n       * @param typeOrName The mark type or name.\n       * @param attributes The attributes of the mark.\n       * @param options.extendEmptyMarkRange Removes the mark even across the current selection. Defaults to `false`.\n       * @example editor.commands.toggleMark('bold')\n       */\n      toggleMark: (\n        /**\n         * The mark type or name.\n         */\n        typeOrName: string | MarkType,\n\n        /**\n         * The attributes of the mark.\n         */\n        attributes?: Record<string, any>,\n\n        options?: {\n          /**\n           * Removes the mark even across the current selection. Defaults to `false`.\n           */\n          extendEmptyMarkRange?: boolean\n        },\n      ) => ReturnType\n    }\n  }\n}\n\nexport const toggleMark: RawCommands['toggleMark'] =\n  (typeOrName, attributes = {}, options = {}) =>\n  ({ state, commands }) => {\n    const { extendEmptyMarkRange = false } = options\n    const type = getMarkType(typeOrName, state.schema)\n    const isActive = isMarkActive(state, type, attributes)\n\n    if (isActive) {\n      return commands.unsetMark(type, { extendEmptyMarkRange })\n    }\n\n    return commands.setMark(type, attributes)\n  }\n","import type { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { isNodeActive } from '../helpers/isNodeActive.js'\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    toggleNode: {\n      /**\n       * Toggle a node with another node.\n       * @param typeOrName The type or name of the node.\n       * @param toggleTypeOrName The type or name of the node to toggle.\n       * @param attributes The attributes of the node.\n       * @example editor.commands.toggleNode('heading', 'paragraph')\n       */\n      toggleNode: (\n        typeOrName: string | NodeType,\n        toggleTypeOrName: string | NodeType,\n        attributes?: Record<string, any>,\n      ) => ReturnType\n    }\n  }\n}\n\nexport const toggleNode: RawCommands['toggleNode'] =\n  (typeOrName, toggleTypeOrName, attributes = {}) =>\n  ({ state, commands }) => {\n    const type = getNodeType(typeOrName, state.schema)\n    const toggleType = getNodeType(toggleTypeOrName, state.schema)\n    const isActive = isNodeActive(state, type, attributes)\n\n    let attributesToCopy: Record<string, any> | undefined\n\n    if (state.selection.$anchor.sameParent(state.selection.$head)) {\n      // only copy attributes if the selection is pointing to a node of the same type\n      attributesToCopy = state.selection.$anchor.parent.attrs\n    }\n\n    if (isActive) {\n      return commands.setNode(toggleType, attributesToCopy)\n    }\n\n    // If the node is not active, we want to set the new node type with the given attributes\n    // Copying over the attributes from the current node if the selection is pointing to a node of the same type\n    return commands.setNode(type, { ...attributesToCopy, ...attributes })\n  }\n","import type { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { isNodeActive } from '../helpers/isNodeActive.js'\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    toggleWrap: {\n      /**\n       * Wraps nodes in another node, or removes an existing wrap.\n       * @param typeOrName The type or name of the node.\n       * @param attributes The attributes of the node.\n       * @example editor.commands.toggleWrap('blockquote')\n       */\n      toggleWrap: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const toggleWrap: RawCommands['toggleWrap'] =\n  (typeOrName, attributes = {}) =>\n  ({ state, commands }) => {\n    const type = getNodeType(typeOrName, state.schema)\n    const isActive = isNodeActive(state, type, attributes)\n\n    if (isActive) {\n      return commands.lift(type)\n    }\n\n    return commands.wrapIn(type, attributes)\n  }\n","import type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    undoInputRule: {\n      /**\n       * Undo an input rule.\n       * @example editor.commands.undoInputRule()\n       */\n      undoInputRule: () => ReturnType\n    }\n  }\n}\n\nexport const undoInputRule: RawCommands['undoInputRule'] =\n  () =>\n  ({ state, dispatch }) => {\n    const plugins = state.plugins\n\n    for (let i = 0; i < plugins.length; i += 1) {\n      const plugin = plugins[i]\n      let undoable\n\n      // @ts-ignore\n      // eslint-disable-next-line\n      if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n        if (dispatch) {\n          const tr = state.tr\n          const toUndo = undoable.transform\n\n          for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {\n            tr.step(toUndo.steps[j].invert(toUndo.docs[j]))\n          }\n\n          if (undoable.text) {\n            const marks = tr.doc.resolve(undoable.from).marks()\n\n            tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks))\n          } else {\n            tr.delete(undoable.from, undoable.to)\n          }\n        }\n\n        return true\n      }\n    }\n\n    return false\n  }\n","import type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    unsetAllMarks: {\n      /**\n       * Remove all marks in the current selection.\n       * @example editor.commands.unsetAllMarks()\n       */\n      unsetAllMarks: () => ReturnType\n    }\n  }\n}\n\nexport const unsetAllMarks: RawCommands['unsetAllMarks'] =\n  () =>\n  ({ tr, dispatch }) => {\n    const { selection } = tr\n    const { empty, ranges } = selection\n\n    if (empty) {\n      return true\n    }\n\n    if (dispatch) {\n      ranges.forEach(range => {\n        tr.removeMark(range.$from.pos, range.$to.pos)\n      })\n    }\n\n    return true\n  }\n","import type { MarkType } from '@tiptap/pm/model'\n\nimport { getMarkRange } from '../helpers/getMarkRange.js'\nimport { getMarkType } from '../helpers/getMarkType.js'\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    unsetMark: {\n      /**\n       * Remove all marks in the current selection.\n       * @param typeOrName The mark type or name.\n       * @param options.extendEmptyMarkRange Removes the mark even across the current selection. Defaults to `false`.\n       * @example editor.commands.unsetMark('bold')\n       */\n      unsetMark: (\n        /**\n         * The mark type or name.\n         */\n        typeOrName: string | MarkType,\n\n        options?: {\n          /**\n           * Removes the mark even across the current selection. Defaults to `false`.\n           */\n          extendEmptyMarkRange?: boolean\n        },\n      ) => ReturnType\n    }\n  }\n}\n\nexport const unsetMark: RawCommands['unsetMark'] =\n  (typeOrName, options = {}) =>\n  ({ tr, state, dispatch }) => {\n    const { extendEmptyMarkRange = false } = options\n    const { selection } = tr\n    const type = getMarkType(typeOrName, state.schema)\n    const { $from, empty, ranges } = selection\n\n    if (!dispatch) {\n      return true\n    }\n\n    if (empty && extendEmptyMarkRange) {\n      let { from, to } = selection\n      const attrs = $from.marks().find(mark => mark.type === type)?.attrs\n      const range = getMarkRange($from, type, attrs)\n\n      if (range) {\n        from = range.from\n        to = range.to\n      }\n\n      tr.removeMark(from, to, type)\n    } else {\n      ranges.forEach(range => {\n        tr.removeMark(range.$from.pos, range.$to.pos, type)\n      })\n    }\n\n    tr.removeStoredMark(type)\n\n    return true\n  }\n","import type { Range, RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    unsetTextDirection: {\n      /**\n       * Remove the text direction attribute from nodes.\n       * If no position is provided, it will use the current selection.\n       * @param position Optional position or range to remove the direction from\n       * @example editor.commands.unsetTextDirection()\n       * @example editor.commands.unsetTextDirection({ from: 0, to: 10 })\n       */\n      unsetTextDirection: (position?: number | Range) => ReturnType\n    }\n  }\n}\n\nexport const unsetTextDirection: RawCommands['unsetTextDirection'] =\n  position =>\n  ({ tr, state, dispatch }) => {\n    const { selection } = state\n    let from: number\n    let to: number\n\n    if (typeof position === 'number') {\n      from = position\n      to = position\n    } else if (position && 'from' in position && 'to' in position) {\n      from = position.from\n      to = position.to\n    } else {\n      from = selection.from\n      to = selection.to\n    }\n\n    if (dispatch) {\n      tr.doc.nodesBetween(from, to, (node, pos) => {\n        if (node.isText) {\n          return\n        }\n\n        const newAttrs = { ...node.attrs }\n\n        delete newAttrs.dir\n\n        tr.setNodeMarkup(pos, undefined, newAttrs)\n      })\n    }\n\n    return true\n  }\n","import type { Mark, MarkType, Node, NodeType } from '@tiptap/pm/model'\nimport type { SelectionRange } from '@tiptap/pm/state'\n\nimport { getMarkType } from '../helpers/getMarkType.js'\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport { getSchemaTypeNameByName } from '../helpers/getSchemaTypeNameByName.js'\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    updateAttributes: {\n      /**\n       * Update attributes of a node or mark.\n       * @param typeOrName The type or name of the node or mark.\n       * @param attributes The attributes of the node or mark.\n       * @example editor.commands.updateAttributes('mention', { userId: \"2\" })\n       */\n      updateAttributes: (\n        /**\n         * The type or name of the node or mark.\n         */\n        typeOrName: string | NodeType | MarkType,\n\n        /**\n         * The attributes of the node or mark.\n         */\n        attributes: Record<string, any>,\n      ) => ReturnType\n    }\n  }\n}\n\nexport const updateAttributes: RawCommands['updateAttributes'] =\n  (typeOrName, attributes = {}) =>\n  ({ tr, state, dispatch }) => {\n    let nodeType: NodeType | null = null\n    let markType: MarkType | null = null\n\n    const schemaType = getSchemaTypeNameByName(\n      typeof typeOrName === 'string' ? typeOrName : typeOrName.name,\n      state.schema,\n    )\n\n    if (!schemaType) {\n      return false\n    }\n\n    if (schemaType === 'node') {\n      nodeType = getNodeType(typeOrName as NodeType, state.schema)\n    }\n\n    if (schemaType === 'mark') {\n      markType = getMarkType(typeOrName as MarkType, state.schema)\n    }\n\n    let canUpdate = false\n\n    tr.selection.ranges.forEach((range: SelectionRange) => {\n      const from = range.$from.pos\n      const to = range.$to.pos\n\n      let lastPos: number | undefined\n      let lastNode: Node | undefined\n      let trimmedFrom: number\n      let trimmedTo: number\n\n      if (tr.selection.empty) {\n        state.doc.nodesBetween(from, to, (node: Node, pos: number) => {\n          if (nodeType && nodeType === node.type) {\n            canUpdate = true\n            trimmedFrom = Math.max(pos, from)\n            trimmedTo = Math.min(pos + node.nodeSize, to)\n            lastPos = pos\n            lastNode = node\n          }\n        })\n      } else {\n        state.doc.nodesBetween(from, to, (node: Node, pos: number) => {\n          if (pos < from && nodeType && nodeType === node.type) {\n            canUpdate = true\n            trimmedFrom = Math.max(pos, from)\n            trimmedTo = Math.min(pos + node.nodeSize, to)\n            lastPos = pos\n            lastNode = node\n          }\n\n          if (pos >= from && pos <= to) {\n            if (nodeType && nodeType === node.type) {\n              canUpdate = true\n\n              if (dispatch) {\n                tr.setNodeMarkup(pos, undefined, {\n                  ...node.attrs,\n                  ...attributes,\n                })\n              }\n            }\n\n            if (markType && node.marks.length) {\n              node.marks.forEach((mark: Mark) => {\n                if (markType === mark.type) {\n                  canUpdate = true\n\n                  if (dispatch) {\n                    const trimmedFrom2 = Math.max(pos, from)\n                    const trimmedTo2 = Math.min(pos + node.nodeSize, to)\n\n                    tr.addMark(\n                      trimmedFrom2,\n                      trimmedTo2,\n                      markType.create({\n                        ...mark.attrs,\n                        ...attributes,\n                      }),\n                    )\n                  }\n                }\n              })\n            }\n          }\n        })\n      }\n\n      if (lastNode) {\n        if (lastPos !== undefined && dispatch) {\n          tr.setNodeMarkup(lastPos, undefined, {\n            ...lastNode.attrs,\n            ...attributes,\n          })\n        }\n\n        if (markType && lastNode.marks.length) {\n          lastNode.marks.forEach((mark: Mark) => {\n            if (markType === mark.type && dispatch) {\n              tr.addMark(\n                trimmedFrom,\n                trimmedTo,\n                markType.create({\n                  ...mark.attrs,\n                  ...attributes,\n                }),\n              )\n            }\n          })\n        }\n      }\n    })\n\n    return canUpdate\n  }\n","import { wrapIn as originalWrapIn } from '@tiptap/pm/commands'\nimport type { NodeType } from '@tiptap/pm/model'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    wrapIn: {\n      /**\n       * Wraps nodes in another node.\n       * @param typeOrName The type or name of the node.\n       * @param attributes The attributes of the node.\n       * @example editor.commands.wrapIn('blockquote')\n       */\n      wrapIn: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const wrapIn: RawCommands['wrapIn'] =\n  (typeOrName, attributes = {}) =>\n  ({ state, dispatch }) => {\n    const type = getNodeType(typeOrName, state.schema)\n\n    return originalWrapIn(type, attributes)(state, dispatch)\n  }\n","import type { NodeType } from '@tiptap/pm/model'\nimport { wrapInList as originalWrapInList } from '@tiptap/pm/schema-list'\n\nimport { getNodeType } from '../helpers/getNodeType.js'\nimport type { RawCommands } from '../types.js'\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    wrapInList: {\n      /**\n       * Wrap a node in a list.\n       * @param typeOrName The type or name of the node.\n       * @param attributes The attributes of the node.\n       * @example editor.commands.wrapInList('bulletList')\n       */\n      wrapInList: (typeOrName: string | NodeType, attributes?: Record<string, any>) => ReturnType\n    }\n  }\n}\n\nexport const wrapInList: RawCommands['wrapInList'] =\n  (typeOrName, attributes = {}) =>\n  ({ state, dispatch }) => {\n    const type = getNodeType(typeOrName, state.schema)\n\n    return originalWrapInList(type, attributes)(state, dispatch)\n  }\n","/* eslint-disable @typescript-eslint/no-empty-object-type */\nimport type { MarkType, Node as ProseMirrorNode, NodeType, Schema } from '@tiptap/pm/model'\nimport type { Plugin, PluginKey, Transaction } from '@tiptap/pm/state'\nimport { EditorState } from '@tiptap/pm/state'\nimport { EditorView } from '@tiptap/pm/view'\n\nimport { CommandManager } from './CommandManager.js'\nimport { EventEmitter } from './EventEmitter.js'\nimport { ExtensionManager } from './ExtensionManager.js'\nimport {\n  ClipboardTextSerializer,\n  Commands,\n  Delete,\n  Drop,\n  Editable,\n  FocusEvents,\n  Keymap,\n  Paste,\n  Tabindex,\n  TextDirection,\n} from './extensions/index.js'\nimport { createDocument } from './helpers/createDocument.js'\nimport { getAttributes } from './helpers/getAttributes.js'\nimport { getHTMLFromFragment } from './helpers/getHTMLFromFragment.js'\nimport { getText } from './helpers/getText.js'\nimport { getTextSerializersFromSchema } from './helpers/getTextSerializersFromSchema.js'\nimport { isActive } from './helpers/isActive.js'\nimport { isNodeEmpty } from './helpers/isNodeEmpty.js'\nimport { createMappablePosition, getUpdatedPosition } from './helpers/MappablePosition.js'\nimport { resolveFocusPosition } from './helpers/resolveFocusPosition.js'\nimport type { Storage } from './index.js'\nimport { NodePos } from './NodePos.js'\nimport { style } from './style.js'\nimport type {\n  CanCommands,\n  ChainedCommands,\n  DocumentType,\n  EditorEvents,\n  EditorOptions,\n  NodeType as TNodeType,\n  SingleCommands,\n  TextSerializer,\n  TextType as TTextType,\n  Utils,\n} from './types.js'\nimport { createStyleTag } from './utilities/createStyleTag.js'\nimport { isFunction } from './utilities/isFunction.js'\n\nexport * as extensions from './extensions/index.js'\n\n// @ts-ignore\nexport interface TiptapEditorHTMLElement extends HTMLElement {\n  editor?: Editor\n}\n\nexport class Editor extends EventEmitter<EditorEvents> {\n  private commandManager!: CommandManager\n\n  public extensionManager!: ExtensionManager\n\n  private css: HTMLStyleElement | null = null\n\n  private className = 'tiptap'\n\n  public schema!: Schema\n\n  private editorView: EditorView | null = null\n\n  public isFocused = false\n\n  private editorState!: EditorState\n\n  /**\n   * The editor is considered initialized after the `create` event has been emitted.\n   */\n  public isInitialized = false\n\n  public extensionStorage: Storage = {} as Storage\n\n  /**\n   * A unique ID for this editor instance.\n   */\n  public instanceId = Math.random().toString(36).slice(2, 9)\n\n  public options: EditorOptions = {\n    element: typeof document !== 'undefined' ? document.createElement('div') : null,\n    content: '',\n    injectCSS: true,\n    injectNonce: undefined,\n    extensions: [],\n    autofocus: false,\n    editable: true,\n    textDirection: undefined,\n    editorProps: {},\n    parseOptions: {},\n    coreExtensionOptions: {},\n    enableInputRules: true,\n    enablePasteRules: true,\n    enableCoreExtensions: true,\n    enableContentCheck: false,\n    emitContentError: false,\n    onBeforeCreate: () => null,\n    onCreate: () => null,\n    onMount: () => null,\n    onUnmount: () => null,\n    onUpdate: () => null,\n    onSelectionUpdate: () => null,\n    onTransaction: () => null,\n    onFocus: () => null,\n    onBlur: () => null,\n    onDestroy: () => null,\n    onContentError: ({ error }) => {\n      throw error\n    },\n    onPaste: () => null,\n    onDrop: () => null,\n    onDelete: () => null,\n    enableExtensionDispatchTransaction: true,\n  }\n\n  constructor(options: Partial<EditorOptions> = {}) {\n    super()\n    this.setOptions(options)\n    this.createExtensionManager()\n    this.createCommandManager()\n    this.createSchema()\n    this.on('beforeCreate', this.options.onBeforeCreate)\n    this.emit('beforeCreate', { editor: this })\n    this.on('mount', this.options.onMount)\n    this.on('unmount', this.options.onUnmount)\n    this.on('contentError', this.options.onContentError)\n    this.on('create', this.options.onCreate)\n    this.on('update', this.options.onUpdate)\n    this.on('selectionUpdate', this.options.onSelectionUpdate)\n    this.on('transaction', this.options.onTransaction)\n    this.on('focus', this.options.onFocus)\n    this.on('blur', this.options.onBlur)\n    this.on('destroy', this.options.onDestroy)\n    this.on('drop', ({ event, slice, moved }) => this.options.onDrop(event, slice, moved))\n    this.on('paste', ({ event, slice }) => this.options.onPaste(event, slice))\n    this.on('delete', this.options.onDelete)\n\n    const initialDoc = this.createDoc()\n    const selection = resolveFocusPosition(initialDoc, this.options.autofocus)\n\n    // Set editor state immediately, so that it's available independently from the view\n    this.editorState = EditorState.create({\n      doc: initialDoc,\n      schema: this.schema,\n      selection: selection || undefined,\n    })\n\n    if (this.options.element) {\n      this.mount(this.options.element)\n    }\n  }\n\n  /**\n   * Attach the editor to the DOM, creating a new editor view.\n   */\n  public mount(el: NonNullable<EditorOptions['element']> & {}) {\n    if (typeof document === 'undefined') {\n      throw new Error(\n        `[tiptap error]: The editor cannot be mounted because there is no 'document' defined in this environment.`,\n      )\n    }\n    this.createView(el)\n    this.emit('mount', { editor: this })\n\n    if (this.css && !document.head.contains(this.css)) {\n      document.head.appendChild(this.css)\n    }\n\n    window.setTimeout(() => {\n      if (this.isDestroyed) {\n        return\n      }\n\n      if (this.options.autofocus !== false && this.options.autofocus !== null) {\n        this.commands.focus(this.options.autofocus)\n      }\n      this.emit('create', { editor: this })\n      this.isInitialized = true\n    }, 0)\n  }\n\n  /**\n   * Remove the editor from the DOM, but still allow remounting at a different point in time\n   */\n  public unmount() {\n    if (this.editorView) {\n      // Cleanup our reference to prevent circular references which caused memory leaks\n      // @ts-ignore\n      const dom = this.editorView.dom as TiptapEditorHTMLElement\n\n      if (dom?.editor) {\n        delete dom.editor\n      }\n      this.editorView.destroy()\n    }\n    this.editorView = null\n    this.isInitialized = false\n\n    // Safely remove CSS element with fallback for test environments\n    // Only remove CSS if no other editors exist in the document after unmount\n    if (this.css && !document.querySelectorAll(`.${this.className}`).length) {\n      try {\n        if (typeof this.css.remove === 'function') {\n          this.css.remove()\n        } else if (this.css.parentNode) {\n          this.css.parentNode.removeChild(this.css)\n        }\n      } catch (error) {\n        // Silently handle any unexpected DOM removal errors in test environments\n        console.warn('Failed to remove CSS element:', error)\n      }\n    }\n    this.css = null\n    this.emit('unmount', { editor: this })\n  }\n\n  /**\n   * Returns the editor storage.\n   */\n  public get storage(): Storage {\n    return this.extensionStorage\n  }\n\n  /**\n   * An object of all registered commands.\n   */\n  public get commands(): SingleCommands {\n    return this.commandManager.commands\n  }\n\n  /**\n   * Create a command chain to call multiple commands at once.\n   */\n  public chain(): ChainedCommands {\n    return this.commandManager.chain()\n  }\n\n  /**\n   * Check if a command or a command chain can be executed. Without executing it.\n   */\n  public can(): CanCommands {\n    return this.commandManager.can()\n  }\n\n  /**\n   * Inject CSS styles.\n   */\n  private injectCSS(): void {\n    if (this.options.injectCSS && typeof document !== 'undefined') {\n      this.css = createStyleTag(style, this.options.injectNonce)\n    }\n  }\n\n  /**\n   * Update editor options.\n   *\n   * @param options A list of options\n   */\n  public setOptions(options: Partial<EditorOptions> = {}): void {\n    this.options = {\n      ...this.options,\n      ...options,\n    }\n\n    if (!this.editorView || !this.state || this.isDestroyed) {\n      return\n    }\n\n    if (this.options.editorProps) {\n      this.view.setProps(this.options.editorProps)\n    }\n\n    this.view.updateState(this.state)\n  }\n\n  /**\n   * Update editable state of the editor.\n   */\n  public setEditable(editable: boolean, emitUpdate = true): void {\n    this.setOptions({ editable })\n\n    if (emitUpdate) {\n      this.emit('update', { editor: this, transaction: this.state.tr, appendedTransactions: [] })\n    }\n  }\n\n  /**\n   * Returns whether the editor is editable.\n   */\n  public get isEditable(): boolean {\n    // since plugins are applied after creating the view\n    // `editable` is always `true` for one tick.\n    // thatâ€™s why we also have to check for `options.editable`\n    return this.options.editable && this.view && this.view.editable\n  }\n\n  /**\n   * Returns the editor state.\n   */\n  public get view(): EditorView {\n    if (this.editorView) {\n      return this.editorView\n    }\n\n    return new Proxy(\n      {\n        state: this.editorState,\n        updateState: (state: EditorState): ReturnType<EditorView['updateState']> => {\n          this.editorState = state\n        },\n        dispatch: (tr: Transaction): ReturnType<EditorView['dispatch']> => {\n          this.dispatchTransaction(tr)\n        },\n\n        // Stub some commonly accessed properties to prevent errors\n        composing: false,\n        dragging: null,\n        editable: true,\n        isDestroyed: false,\n      } as EditorView,\n      {\n        get: (obj, key) => {\n          if (this.editorView) {\n            // If the editor view is available, but the caller has a stale reference to the proxy,\n            // Just return what the editor view has.\n            return this.editorView[key as keyof EditorView]\n          }\n          // Specifically always return the most recent editorState\n          if (key === 'state') {\n            return this.editorState\n          }\n          if (key in obj) {\n            return Reflect.get(obj, key)\n          }\n\n          // We throw an error here, because we know the view is not available\n          throw new Error(\n            `[tiptap error]: The editor view is not available. Cannot access view['${key as string}']. The editor may not be mounted yet.`,\n          )\n        },\n      },\n    ) as EditorView\n  }\n\n  /**\n   * Returns the editor state.\n   */\n  public get state(): EditorState {\n    if (this.editorView) {\n      this.editorState = this.view.state\n    }\n\n    return this.editorState\n  }\n\n  /**\n   * Register a ProseMirror plugin.\n   *\n   * @param plugin A ProseMirror plugin\n   * @param handlePlugins Control how to merge the plugin into the existing plugins.\n   * @returns The new editor state\n   */\n  public registerPlugin(\n    plugin: Plugin,\n    handlePlugins?: (newPlugin: Plugin, plugins: Plugin[]) => Plugin[],\n  ): EditorState {\n    const plugins = isFunction(handlePlugins)\n      ? handlePlugins(plugin, [...this.state.plugins])\n      : [...this.state.plugins, plugin]\n\n    const state = this.state.reconfigure({ plugins })\n\n    this.view.updateState(state)\n\n    return state\n  }\n\n  /**\n   * Unregister a ProseMirror plugin.\n   *\n   * @param nameOrPluginKeyToRemove The plugins name\n   * @returns The new editor state or undefined if the editor is destroyed\n   */\n  public unregisterPlugin(\n    nameOrPluginKeyToRemove: string | PluginKey | (string | PluginKey)[],\n  ): EditorState | undefined {\n    if (this.isDestroyed) {\n      return undefined\n    }\n\n    const prevPlugins = this.state.plugins\n    let plugins = prevPlugins\n\n    ;([] as (string | PluginKey)[]).concat(nameOrPluginKeyToRemove).forEach(nameOrPluginKey => {\n      // @ts-ignore\n      const name = typeof nameOrPluginKey === 'string' ? `${nameOrPluginKey}$` : nameOrPluginKey.key\n\n      // @ts-ignore\n      plugins = plugins.filter(plugin => !plugin.key.startsWith(name))\n    })\n\n    if (prevPlugins.length === plugins.length) {\n      // No plugin was removed, so we donâ€™t need to update the state\n      return undefined\n    }\n\n    const state = this.state.reconfigure({\n      plugins,\n    })\n\n    this.view.updateState(state)\n\n    return state\n  }\n\n  /**\n   * Creates an extension manager.\n   */\n  private createExtensionManager(): void {\n    const coreExtensions = this.options.enableCoreExtensions\n      ? [\n          Editable,\n          ClipboardTextSerializer.configure({\n            blockSeparator: this.options.coreExtensionOptions?.clipboardTextSerializer?.blockSeparator,\n          }),\n          Commands,\n          FocusEvents,\n          Keymap,\n          Tabindex,\n          Drop,\n          Paste,\n          Delete,\n          TextDirection.configure({\n            direction: this.options.textDirection,\n          }),\n        ].filter(ext => {\n          if (typeof this.options.enableCoreExtensions === 'object') {\n            return (\n              this.options.enableCoreExtensions[ext.name as keyof typeof this.options.enableCoreExtensions] !== false\n            )\n          }\n          return true\n        })\n      : []\n    const allExtensions = [...coreExtensions, ...this.options.extensions].filter(extension => {\n      return ['extension', 'node', 'mark'].includes(extension?.type)\n    })\n\n    this.extensionManager = new ExtensionManager(allExtensions, this)\n  }\n\n  /**\n   * Creates an command manager.\n   */\n  private createCommandManager(): void {\n    this.commandManager = new CommandManager({\n      editor: this,\n    })\n  }\n\n  /**\n   * Creates a ProseMirror schema.\n   */\n  private createSchema(): void {\n    this.schema = this.extensionManager.schema\n  }\n\n  /**\n   * Creates the initial document.\n   */\n  private createDoc(): ProseMirrorNode {\n    let doc: ProseMirrorNode\n\n    try {\n      doc = createDocument(this.options.content, this.schema, this.options.parseOptions, {\n        errorOnInvalidContent: this.options.enableContentCheck,\n      })\n    } catch (e) {\n      if (\n        !(e instanceof Error) ||\n        !['[tiptap error]: Invalid JSON content', '[tiptap error]: Invalid HTML content'].includes(e.message)\n      ) {\n        // Not the content error we were expecting\n        throw e\n      }\n      this.emit('contentError', {\n        editor: this,\n        error: e as Error,\n        disableCollaboration: () => {\n          if (\n            'collaboration' in this.storage &&\n            typeof this.storage.collaboration === 'object' &&\n            this.storage.collaboration\n          ) {\n            ;(this.storage.collaboration as any).isDisabled = true\n          }\n          // To avoid syncing back invalid content, reinitialize the extensions without the collaboration extension\n          this.options.extensions = this.options.extensions.filter(extension => extension.name !== 'collaboration')\n\n          // Restart the initialization process by recreating the extension manager with the new set of extensions\n          this.createExtensionManager()\n        },\n      })\n\n      // Content is invalid, but attempt to create it anyway, stripping out the invalid parts\n      doc = createDocument(this.options.content, this.schema, this.options.parseOptions, {\n        errorOnInvalidContent: false,\n      })\n    }\n    return doc\n  }\n\n  /**\n   * Creates a ProseMirror view.\n   */\n  private createView(element: NonNullable<EditorOptions['element']>): void {\n    const { editorProps, enableExtensionDispatchTransaction } = this.options\n    // If a user provided a custom `dispatchTransaction` through `editorProps`,\n    // we use that as the base dispatch function.\n    // Otherwise, we use Tiptap's internal `dispatchTransaction` method.\n    const baseDispatch = (editorProps as any).dispatchTransaction || this.dispatchTransaction.bind(this)\n    const dispatch = enableExtensionDispatchTransaction\n      ? this.extensionManager.dispatchTransaction(baseDispatch)\n      : baseDispatch\n\n    this.editorView = new EditorView(element, {\n      ...editorProps,\n      attributes: {\n        // add `role=\"textbox\"` to the editor element\n        role: 'textbox',\n        ...editorProps?.attributes,\n      },\n      dispatchTransaction: dispatch,\n      state: this.editorState,\n      markViews: this.extensionManager.markViews,\n      nodeViews: this.extensionManager.nodeViews,\n    })\n\n    // `editor.view` is not yet available at this time.\n    // Therefore we will add all plugins and node views directly afterwards.\n    const newState = this.state.reconfigure({\n      plugins: this.extensionManager.plugins,\n    })\n\n    this.view.updateState(newState)\n\n    this.prependClass()\n    this.injectCSS()\n\n    // Letâ€™s store the editor instance in the DOM element.\n    // So weâ€™ll have access to it for tests.\n    // @ts-ignore\n    const dom = this.view.dom as TiptapEditorHTMLElement\n\n    dom.editor = this\n  }\n\n  /**\n   * Creates all node and mark views.\n   */\n  public createNodeViews(): void {\n    if (this.view.isDestroyed) {\n      return\n    }\n\n    this.view.setProps({\n      markViews: this.extensionManager.markViews,\n      nodeViews: this.extensionManager.nodeViews,\n    })\n  }\n\n  /**\n   * Prepend class name to element.\n   */\n  public prependClass(): void {\n    this.view.dom.className = `${this.className} ${this.view.dom.className}`\n  }\n\n  public isCapturingTransaction = false\n\n  private capturedTransaction: Transaction | null = null\n\n  public captureTransaction(fn: () => void) {\n    this.isCapturingTransaction = true\n    fn()\n    this.isCapturingTransaction = false\n\n    const tr = this.capturedTransaction\n\n    this.capturedTransaction = null\n\n    return tr\n  }\n\n  /**\n   * The callback over which to send transactions (state updates) produced by the view.\n   *\n   * @param transaction An editor state transaction\n   */\n  private dispatchTransaction(transaction: Transaction): void {\n    // if the editor / the view of the editor was destroyed\n    // the transaction should not be dispatched as there is no view anymore.\n    if (this.view.isDestroyed) {\n      return\n    }\n\n    if (this.isCapturingTransaction) {\n      if (!this.capturedTransaction) {\n        this.capturedTransaction = transaction\n\n        return\n      }\n\n      transaction.steps.forEach(step => this.capturedTransaction?.step(step))\n\n      return\n    }\n\n    // Apply transaction and get resulting state and transactions\n    const { state, transactions } = this.state.applyTransaction(transaction)\n    const selectionHasChanged = !this.state.selection.eq(state.selection)\n    const rootTrWasApplied = transactions.includes(transaction)\n    const prevState = this.state\n\n    this.emit('beforeTransaction', {\n      editor: this,\n      transaction,\n      nextState: state,\n    })\n\n    // If transaction was filtered out, we can return early\n    if (!rootTrWasApplied) {\n      return\n    }\n\n    this.view.updateState(state)\n\n    // Emit transaction event with appended transactions info\n    this.emit('transaction', {\n      editor: this,\n      transaction,\n      appendedTransactions: transactions.slice(1),\n    })\n\n    if (selectionHasChanged) {\n      this.emit('selectionUpdate', {\n        editor: this,\n        transaction,\n      })\n    }\n\n    // Only emit the latest between focus and blur events\n    const mostRecentFocusTr = transactions.findLast(tr => tr.getMeta('focus') || tr.getMeta('blur'))\n    const focus = mostRecentFocusTr?.getMeta('focus')\n    const blur = mostRecentFocusTr?.getMeta('blur')\n\n    if (focus) {\n      this.emit('focus', {\n        editor: this,\n        event: focus.event,\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        transaction: mostRecentFocusTr!,\n      })\n    }\n\n    if (blur) {\n      this.emit('blur', {\n        editor: this,\n        event: blur.event,\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        transaction: mostRecentFocusTr!,\n      })\n    }\n\n    // Compare states for update event\n    if (\n      transaction.getMeta('preventUpdate') ||\n      !transactions.some(tr => tr.docChanged) ||\n      prevState.doc.eq(state.doc)\n    ) {\n      return\n    }\n\n    this.emit('update', {\n      editor: this,\n      transaction,\n      appendedTransactions: transactions.slice(1),\n    })\n  }\n\n  /**\n   * Get attributes of the currently selected node or mark.\n   */\n  public getAttributes(nameOrType: string | NodeType | MarkType): Record<string, any> {\n    return getAttributes(this.state, nameOrType)\n  }\n\n  /**\n   * Returns if the currently selected node or mark is active.\n   *\n   * @param name Name of the node or mark\n   * @param attributes Attributes of the node or mark\n   */\n  public isActive(name: string, attributes?: {}): boolean\n  public isActive(attributes: {}): boolean\n  public isActive(nameOrAttributes: string, attributesOrUndefined?: {}): boolean {\n    const name = typeof nameOrAttributes === 'string' ? nameOrAttributes : null\n\n    const attributes = typeof nameOrAttributes === 'string' ? attributesOrUndefined : nameOrAttributes\n\n    return isActive(this.state, name, attributes)\n  }\n\n  /**\n   * Get the document as JSON.\n   */\n  public getJSON(): DocumentType<\n    Record<string, any> | undefined,\n    TNodeType<string, undefined | Record<string, any>, any, (TNodeType | TTextType)[]>[]\n  > {\n    return this.state.doc.toJSON()\n  }\n\n  /**\n   * Get the document as HTML.\n   */\n  public getHTML(): string {\n    return getHTMLFromFragment(this.state.doc.content, this.schema)\n  }\n\n  /**\n   * Get the document as text.\n   */\n  public getText(options?: { blockSeparator?: string; textSerializers?: Record<string, TextSerializer> }): string {\n    const { blockSeparator = '\\n\\n', textSerializers = {} } = options || {}\n\n    return getText(this.state.doc, {\n      blockSeparator,\n      textSerializers: {\n        ...getTextSerializersFromSchema(this.schema),\n        ...textSerializers,\n      },\n    })\n  }\n\n  /**\n   * Check if there is no content.\n   */\n  public get isEmpty(): boolean {\n    return isNodeEmpty(this.state.doc)\n  }\n\n  /**\n   * Destroy the editor.\n   */\n  public destroy(): void {\n    this.emit('destroy')\n\n    this.unmount()\n\n    this.removeAllListeners()\n  }\n\n  /**\n   * Check if the editor is already destroyed.\n   */\n  public get isDestroyed(): boolean {\n    return this.editorView?.isDestroyed ?? true\n  }\n\n  public $node(selector: string, attributes?: { [key: string]: any }): NodePos | null {\n    return this.$doc?.querySelector(selector, attributes) || null\n  }\n\n  public $nodes(selector: string, attributes?: { [key: string]: any }): NodePos[] | null {\n    return this.$doc?.querySelectorAll(selector, attributes) || null\n  }\n\n  public $pos(pos: number) {\n    const $pos = this.state.doc.resolve(pos)\n\n    return new NodePos($pos, this)\n  }\n\n  get $doc() {\n    return this.$pos(0)\n  }\n\n  /**\n   * Returns a set of utilities for working with positions and ranges.\n   */\n  public utils: Utils = {\n    getUpdatedPosition,\n    createMappablePosition,\n  }\n}\n","type StringKeyOf<T> = Extract<keyof T, string>\ntype CallbackType<T extends Record<string, any>, EventName extends StringKeyOf<T>> = T[EventName] extends any[]\n  ? T[EventName]\n  : [T[EventName]]\ntype CallbackFunction<T extends Record<string, any>, EventName extends StringKeyOf<T>> = (\n  ...props: CallbackType<T, EventName>\n) => any\n\nexport class EventEmitter<T extends Record<string, any>> {\n  private callbacks: { [key: string]: Array<(...args: any[]) => void> } = {}\n\n  public on<EventName extends StringKeyOf<T>>(event: EventName, fn: CallbackFunction<T, EventName>): this {\n    if (!this.callbacks[event]) {\n      this.callbacks[event] = []\n    }\n\n    this.callbacks[event].push(fn)\n\n    return this\n  }\n\n  public emit<EventName extends StringKeyOf<T>>(event: EventName, ...args: CallbackType<T, EventName>): this {\n    const callbacks = this.callbacks[event]\n\n    if (callbacks) {\n      callbacks.forEach(callback => callback.apply(this, args))\n    }\n\n    return this\n  }\n\n  public off<EventName extends StringKeyOf<T>>(event: EventName, fn?: CallbackFunction<T, EventName>): this {\n    const callbacks = this.callbacks[event]\n\n    if (callbacks) {\n      if (fn) {\n        this.callbacks[event] = callbacks.filter(callback => callback !== fn)\n      } else {\n        delete this.callbacks[event]\n      }\n    }\n\n    return this\n  }\n\n  public once<EventName extends StringKeyOf<T>>(event: EventName, fn: CallbackFunction<T, EventName>): this {\n    const onceFn = (...args: CallbackType<T, EventName>) => {\n      this.off(event, onceFn)\n      fn.apply(this, args)\n    }\n\n    return this.on(event, onceFn)\n  }\n\n  public removeAllListeners(): void {\n    this.callbacks = {}\n  }\n}\n","import { keymap } from '@tiptap/pm/keymap'\nimport type { Schema } from '@tiptap/pm/model'\nimport type { Plugin, Transaction } from '@tiptap/pm/state'\nimport type { MarkViewConstructor, NodeViewConstructor } from '@tiptap/pm/view'\n\nimport type { Editor } from './Editor.js'\nimport {\n  flattenExtensions,\n  getAttributesFromExtensions,\n  getExtensionField,\n  getNodeType,\n  getRenderedAttributes,\n  getSchemaByResolvedExtensions,\n  getSchemaTypeByName,\n  isExtensionRulesEnabled,\n  resolveExtensions,\n  sortExtensions,\n  splitExtensions,\n} from './helpers/index.js'\nimport { type MarkConfig, type NodeConfig, type Storage, getMarkType, updateMarkViewAttributes } from './index.js'\nimport { inputRulesPlugin } from './InputRule.js'\nimport { Mark } from './Mark.js'\nimport { pasteRulesPlugin } from './PasteRule.js'\nimport type { AnyConfig, Extensions, RawCommands } from './types.js'\nimport { callOrReturn } from './utilities/callOrReturn.js'\n\nexport class ExtensionManager {\n  editor: Editor\n\n  schema: Schema\n\n  /**\n   * A flattened and sorted array of all extensions\n   */\n  extensions: Extensions\n\n  /**\n   * A non-flattened array of base extensions (no sub-extensions)\n   */\n  baseExtensions: Extensions\n\n  splittableMarks: string[] = []\n\n  constructor(extensions: Extensions, editor: Editor) {\n    this.editor = editor\n    this.baseExtensions = extensions\n    this.extensions = resolveExtensions(extensions)\n    this.schema = getSchemaByResolvedExtensions(this.extensions, editor)\n    this.setupExtensions()\n  }\n\n  static resolve = resolveExtensions\n\n  static sort = sortExtensions\n\n  static flatten = flattenExtensions\n\n  /**\n   * Get all commands from the extensions.\n   * @returns An object with all commands where the key is the command name and the value is the command function\n   */\n  get commands(): RawCommands {\n    return this.extensions.reduce((commands, extension) => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: this.editor.extensionStorage[extension.name as keyof Storage],\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema),\n      }\n\n      const addCommands = getExtensionField<AnyConfig['addCommands']>(extension, 'addCommands', context)\n\n      if (!addCommands) {\n        return commands\n      }\n\n      return {\n        ...commands,\n        ...addCommands(),\n      }\n    }, {} as RawCommands)\n  }\n\n  /**\n   * Get all registered Prosemirror plugins from the extensions.\n   * @returns An array of Prosemirror plugins\n   */\n  get plugins(): Plugin[] {\n    const { editor } = this\n\n    // With ProseMirror, first plugins within an array are executed first.\n    // In Tiptap, we provide the ability to override plugins,\n    // so it feels more natural to run plugins at the end of an array first.\n    // Thatâ€™s why we have to reverse the `extensions` array and sort again\n    // based on the `priority` option.\n    const extensions = sortExtensions([...this.extensions].reverse())\n\n    const allPlugins = extensions.flatMap(extension => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: this.editor.extensionStorage[extension.name as keyof Storage],\n        editor,\n        type: getSchemaTypeByName(extension.name, this.schema),\n      }\n\n      const plugins: Plugin[] = []\n\n      const addKeyboardShortcuts = getExtensionField<AnyConfig['addKeyboardShortcuts']>(\n        extension,\n        'addKeyboardShortcuts',\n        context,\n      )\n\n      let defaultBindings: Record<string, () => boolean> = {}\n\n      // bind exit handling\n      if (extension.type === 'mark' && getExtensionField<MarkConfig['exitable']>(extension, 'exitable', context)) {\n        defaultBindings.ArrowRight = () => Mark.handleExit({ editor, mark: extension as Mark })\n      }\n\n      if (addKeyboardShortcuts) {\n        const bindings = Object.fromEntries(\n          Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {\n            return [shortcut, () => method({ editor })]\n          }),\n        )\n\n        defaultBindings = { ...defaultBindings, ...bindings }\n      }\n\n      const keyMapPlugin = keymap(defaultBindings)\n\n      plugins.push(keyMapPlugin)\n\n      const addInputRules = getExtensionField<AnyConfig['addInputRules']>(extension, 'addInputRules', context)\n\n      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {\n        const rules = addInputRules()\n\n        if (rules && rules.length) {\n          const inputResult = inputRulesPlugin({\n            editor,\n            rules,\n          })\n\n          const inputPlugins = Array.isArray(inputResult) ? inputResult : [inputResult]\n\n          plugins.push(...inputPlugins)\n        }\n      }\n\n      const addPasteRules = getExtensionField<AnyConfig['addPasteRules']>(extension, 'addPasteRules', context)\n\n      if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {\n        const rules = addPasteRules()\n\n        if (rules && rules.length) {\n          const pasteRules = pasteRulesPlugin({ editor, rules })\n\n          plugins.push(...pasteRules)\n        }\n      }\n\n      const addProseMirrorPlugins = getExtensionField<AnyConfig['addProseMirrorPlugins']>(\n        extension,\n        'addProseMirrorPlugins',\n        context,\n      )\n\n      if (addProseMirrorPlugins) {\n        const proseMirrorPlugins = addProseMirrorPlugins()\n\n        plugins.push(...proseMirrorPlugins)\n      }\n\n      return plugins\n    })\n\n    return allPlugins\n  }\n\n  /**\n   * Get all attributes from the extensions.\n   * @returns An array of attributes\n   */\n  get attributes() {\n    return getAttributesFromExtensions(this.extensions)\n  }\n\n  /**\n   * Get all node views from the extensions.\n   * @returns An object with all node views where the key is the node name and the value is the node view function\n   */\n  get nodeViews(): Record<string, NodeViewConstructor> {\n    const { editor } = this\n    const { nodeExtensions } = splitExtensions(this.extensions)\n\n    return Object.fromEntries(\n      nodeExtensions\n        .filter(extension => !!getExtensionField(extension, 'addNodeView'))\n        .map(extension => {\n          const extensionAttributes = this.attributes.filter(attribute => attribute.type === extension.name)\n          const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: this.editor.extensionStorage[extension.name as keyof Storage],\n            editor,\n            type: getNodeType(extension.name, this.schema),\n          }\n          const addNodeView = getExtensionField<NodeConfig['addNodeView']>(extension, 'addNodeView', context)\n\n          if (!addNodeView) {\n            return []\n          }\n\n          const nodeViewResult = addNodeView()\n\n          if (!nodeViewResult) {\n            return []\n          }\n\n          const nodeview: NodeViewConstructor = (node, view, getPos, decorations, innerDecorations) => {\n            const HTMLAttributes = getRenderedAttributes(node, extensionAttributes)\n\n            return nodeViewResult({\n              // pass-through\n              node,\n              view,\n              getPos: getPos as () => number,\n              decorations,\n              innerDecorations,\n              // tiptap-specific\n              editor,\n              extension,\n              HTMLAttributes,\n            })\n          }\n\n          return [extension.name, nodeview]\n        }),\n    )\n  }\n\n  /**\n   * Get the composed dispatchTransaction function from all extensions.\n   * @param baseDispatch The base dispatch function (e.g. from the editor or user props)\n   * @returns A composed dispatch function\n   */\n  dispatchTransaction(baseDispatch: (tr: Transaction) => void): (tr: Transaction) => void {\n    const { editor } = this\n    const extensions = sortExtensions([...this.extensions].reverse())\n\n    return extensions.reduceRight((next, extension) => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: this.editor.extensionStorage[extension.name as keyof Storage],\n        editor,\n        type: getSchemaTypeByName(extension.name, this.schema),\n      }\n\n      const dispatchTransaction = getExtensionField<AnyConfig['dispatchTransaction']>(\n        extension,\n        'dispatchTransaction',\n        context,\n      )\n\n      if (!dispatchTransaction) {\n        return next\n      }\n\n      return (transaction: Transaction) => {\n        dispatchTransaction.call(context, { transaction, next })\n      }\n    }, baseDispatch)\n  }\n\n  get markViews(): Record<string, MarkViewConstructor> {\n    const { editor } = this\n    const { markExtensions } = splitExtensions(this.extensions)\n\n    return Object.fromEntries(\n      markExtensions\n        .filter(extension => !!getExtensionField(extension, 'addMarkView'))\n        .map(extension => {\n          const extensionAttributes = this.attributes.filter(attribute => attribute.type === extension.name)\n          const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: this.editor.extensionStorage[extension.name as keyof Storage],\n            editor,\n            type: getMarkType(extension.name, this.schema),\n          }\n          const addMarkView = getExtensionField<MarkConfig['addMarkView']>(extension, 'addMarkView', context)\n\n          if (!addMarkView) {\n            return []\n          }\n\n          const markView: MarkViewConstructor = (mark, view, inline) => {\n            const HTMLAttributes = getRenderedAttributes(mark, extensionAttributes)\n\n            return addMarkView()({\n              // pass-through\n              mark,\n              view,\n              inline,\n              // tiptap-specific\n              editor,\n              extension,\n              HTMLAttributes,\n              updateAttributes: (attrs: Record<string, any>) => {\n                updateMarkViewAttributes(mark, editor, attrs)\n              },\n            })\n          }\n\n          return [extension.name, markView]\n        }),\n    )\n  }\n\n  /**\n   * Go through all extensions, create extension storages & setup marks\n   * & bind editor event listener.\n   */\n  private setupExtensions() {\n    const extensions = this.extensions\n    // re-initialize the extension storage object instance\n    this.editor.extensionStorage = Object.fromEntries(\n      extensions.map(extension => [extension.name, extension.storage]),\n    ) as unknown as Storage\n\n    extensions.forEach(extension => {\n      const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: this.editor.extensionStorage[extension.name as keyof Storage],\n        editor: this.editor,\n        type: getSchemaTypeByName(extension.name, this.schema),\n      }\n\n      if (extension.type === 'mark') {\n        const keepOnSplit = callOrReturn(getExtensionField(extension, 'keepOnSplit', context)) ?? true\n\n        if (keepOnSplit) {\n          this.splittableMarks.push(extension.name)\n        }\n      }\n\n      const onBeforeCreate = getExtensionField<AnyConfig['onBeforeCreate']>(extension, 'onBeforeCreate', context)\n      const onCreate = getExtensionField<AnyConfig['onCreate']>(extension, 'onCreate', context)\n      const onUpdate = getExtensionField<AnyConfig['onUpdate']>(extension, 'onUpdate', context)\n      const onSelectionUpdate = getExtensionField<AnyConfig['onSelectionUpdate']>(\n        extension,\n        'onSelectionUpdate',\n        context,\n      )\n      const onTransaction = getExtensionField<AnyConfig['onTransaction']>(extension, 'onTransaction', context)\n      const onFocus = getExtensionField<AnyConfig['onFocus']>(extension, 'onFocus', context)\n      const onBlur = getExtensionField<AnyConfig['onBlur']>(extension, 'onBlur', context)\n      const onDestroy = getExtensionField<AnyConfig['onDestroy']>(extension, 'onDestroy', context)\n\n      if (onBeforeCreate) {\n        this.editor.on('beforeCreate', onBeforeCreate)\n      }\n\n      if (onCreate) {\n        this.editor.on('create', onCreate)\n      }\n\n      if (onUpdate) {\n        this.editor.on('update', onUpdate)\n      }\n\n      if (onSelectionUpdate) {\n        this.editor.on('selectionUpdate', onSelectionUpdate)\n      }\n\n      if (onTransaction) {\n        this.editor.on('transaction', onTransaction)\n      }\n\n      if (onFocus) {\n        this.editor.on('focus', onFocus)\n      }\n\n      if (onBlur) {\n        this.editor.on('blur', onBlur)\n      }\n\n      if (onDestroy) {\n        this.editor.on('destroy', onDestroy)\n      }\n    })\n  }\n}\n","import type { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { Fragment } from '@tiptap/pm/model'\nimport type { EditorState, TextSelection } from '@tiptap/pm/state'\nimport { Plugin } from '@tiptap/pm/state'\n\nimport { CommandManager } from './CommandManager.js'\nimport type { Editor } from './Editor.js'\nimport { createChainableState } from './helpers/createChainableState.js'\nimport { getHTMLFromFragment } from './helpers/getHTMLFromFragment.js'\nimport { getTextContentFromNodes } from './helpers/getTextContentFromNodes.js'\nimport type { CanCommands, ChainedCommands, ExtendedRegExpMatchArray, Range, SingleCommands } from './types.js'\nimport { isRegExp } from './utilities/isRegExp.js'\n\nexport type InputRuleMatch = {\n  index: number\n  text: string\n  replaceWith?: string\n  match?: RegExpMatchArray\n  data?: Record<string, any>\n}\n\nexport type InputRuleFinder = RegExp | ((text: string) => InputRuleMatch | null)\n\nexport class InputRule {\n  find: InputRuleFinder\n\n  handler: (props: {\n    state: EditorState\n    range: Range\n    match: ExtendedRegExpMatchArray\n    commands: SingleCommands\n    chain: () => ChainedCommands\n    can: () => CanCommands\n  }) => void | null\n\n  undoable: boolean\n\n  constructor(config: {\n    find: InputRuleFinder\n    handler: (props: {\n      state: EditorState\n      range: Range\n      match: ExtendedRegExpMatchArray\n      commands: SingleCommands\n      chain: () => ChainedCommands\n      can: () => CanCommands\n    }) => void | null\n    undoable?: boolean\n  }) {\n    this.find = config.find\n    this.handler = config.handler\n    this.undoable = config.undoable ?? true\n  }\n}\n\nconst inputRuleMatcherHandler = (text: string, find: InputRuleFinder): ExtendedRegExpMatchArray | null => {\n  if (isRegExp(find)) {\n    return find.exec(text)\n  }\n\n  const inputRuleMatch = find(text)\n\n  if (!inputRuleMatch) {\n    return null\n  }\n\n  const result: ExtendedRegExpMatchArray = [inputRuleMatch.text]\n\n  result.index = inputRuleMatch.index\n  result.input = text\n  result.data = inputRuleMatch.data\n\n  if (inputRuleMatch.replaceWith) {\n    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {\n      console.warn('[tiptap warn]: \"inputRuleMatch.replaceWith\" must be part of \"inputRuleMatch.text\".')\n    }\n\n    result.push(inputRuleMatch.replaceWith)\n  }\n\n  return result\n}\n\nfunction run(config: {\n  editor: Editor\n  from: number\n  to: number\n  text: string\n  rules: InputRule[]\n  plugin: Plugin\n}): boolean {\n  const { editor, from, to, text, rules, plugin } = config\n  const { view } = editor\n\n  if (view.composing) {\n    return false\n  }\n\n  const $from = view.state.doc.resolve(from)\n\n  if (\n    // check for code node\n    $from.parent.type.spec.code ||\n    // check for code mark\n    !!($from.nodeBefore || $from.nodeAfter)?.marks.find(mark => mark.type.spec.code)\n  ) {\n    return false\n  }\n\n  let matched = false\n\n  const textBefore = getTextContentFromNodes($from) + text\n\n  rules.forEach(rule => {\n    if (matched) {\n      return\n    }\n\n    const match = inputRuleMatcherHandler(textBefore, rule.find)\n\n    if (!match) {\n      return\n    }\n\n    const tr = view.state.tr\n    const state = createChainableState({\n      state: view.state,\n      transaction: tr,\n    })\n    const range = {\n      from: from - (match[0].length - text.length),\n      to,\n    }\n\n    const { commands, chain, can } = new CommandManager({\n      editor,\n      state,\n    })\n\n    const handler = rule.handler({\n      state,\n      range,\n      match,\n      commands,\n      chain,\n      can,\n    })\n\n    // stop if there are no changes\n    if (handler === null || !tr.steps.length) {\n      return\n    }\n\n    // store transform as meta data\n    // so we can undo input rules within the `undoInputRules` command\n    if (rule.undoable) {\n      tr.setMeta(plugin, {\n        transform: tr,\n        from,\n        to,\n        text,\n      })\n    }\n\n    view.dispatch(tr)\n    matched = true\n  })\n\n  return matched\n}\n\n/**\n * Create an input rules plugin. When enabled, it will cause text\n * input that matches any of the given rules to trigger the ruleâ€™s\n * action.\n */\nexport function inputRulesPlugin(props: { editor: Editor; rules: InputRule[] }): Plugin {\n  const { editor, rules } = props\n  const plugin = new Plugin({\n    state: {\n      init() {\n        return null\n      },\n      apply(tr, prev, state) {\n        const stored = tr.getMeta(plugin)\n\n        if (stored) {\n          return stored\n        }\n\n        // if InputRule is triggered by insertContent()\n        const simulatedInputMeta = tr.getMeta('applyInputRules') as\n          | undefined\n          | {\n              from: number\n              text: string | ProseMirrorNode | Fragment\n            }\n        const isSimulatedInput = !!simulatedInputMeta\n\n        if (isSimulatedInput) {\n          setTimeout(() => {\n            let { text } = simulatedInputMeta\n\n            if (typeof text === 'string') {\n              text = text as string\n            } else {\n              text = getHTMLFromFragment(Fragment.from(text), state.schema)\n            }\n\n            const { from } = simulatedInputMeta\n            const to = from + text.length\n\n            run({\n              editor,\n              from,\n              to,\n              text,\n              rules,\n              plugin,\n            })\n          })\n        }\n\n        return tr.selectionSet || tr.docChanged ? null : prev\n      },\n    },\n\n    props: {\n      handleTextInput(view, from, to, text) {\n        return run({\n          editor,\n          from,\n          to,\n          text,\n          rules,\n          plugin,\n        })\n      },\n\n      handleDOMEvents: {\n        compositionend: view => {\n          setTimeout(() => {\n            const { $cursor } = view.state.selection as TextSelection\n\n            if ($cursor) {\n              run({\n                editor,\n                from: $cursor.pos,\n                to: $cursor.pos,\n                text: '',\n                rules,\n                plugin,\n              })\n            }\n          })\n\n          return false\n        },\n      },\n\n      // add support for input rules to trigger on enter\n      // this is useful for example for code blocks\n      handleKeyDown(view, event) {\n        if (event.key !== 'Enter') {\n          return false\n        }\n\n        const { $cursor } = view.state.selection as TextSelection\n\n        if ($cursor) {\n          return run({\n            editor,\n            from: $cursor.pos,\n            to: $cursor.pos,\n            text: '\\n',\n            rules,\n            plugin,\n          })\n        }\n\n        return false\n      },\n    },\n\n    // @ts-ignore\n    isInputRules: true,\n  }) as Plugin\n\n  return plugin\n}\n","// see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts\n\nfunction getType(value: any): string {\n  return Object.prototype.toString.call(value).slice(8, -1)\n}\n\nexport function isPlainObject(value: any): value is Record<string, any> {\n  if (getType(value) !== 'Object') {\n    return false\n  }\n\n  return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype\n}\n","import { isPlainObject } from './isPlainObject.js'\n\nexport function mergeDeep(target: Record<string, any>, source: Record<string, any>): Record<string, any> {\n  const output = { ...target }\n\n  if (isPlainObject(target) && isPlainObject(source)) {\n    Object.keys(source).forEach(key => {\n      if (isPlainObject(source[key]) && isPlainObject(target[key])) {\n        output[key] = mergeDeep(target[key], source[key])\n      } else {\n        output[key] = source[key]\n      }\n    })\n  }\n\n  return output\n}\n","import type { Plugin } from '@tiptap/pm/state'\n\nimport type { Editor } from './Editor.js'\nimport { getExtensionField } from './helpers/getExtensionField.js'\nimport type { ExtensionConfig, MarkConfig, NodeConfig } from './index.js'\nimport type { InputRule } from './InputRule.js'\nimport type { Mark } from './Mark.js'\nimport type { Node } from './Node.js'\nimport type { PasteRule } from './PasteRule.js'\nimport type {\n  AnyConfig,\n  DispatchTransactionProps,\n  EditorEvents,\n  Extensions,\n  GlobalAttributes,\n  JSONContent,\n  KeyboardShortcutCommand,\n  MarkdownParseHelpers,\n  MarkdownParseResult,\n  MarkdownRendererHelpers,\n  MarkdownToken,\n  MarkdownTokenizer,\n  ParentConfig,\n  RawCommands,\n  RenderContext,\n} from './types.js'\nimport { callOrReturn } from './utilities/callOrReturn.js'\nimport { mergeDeep } from './utilities/mergeDeep.js'\n\nexport interface ExtendableConfig<\n  Options = any,\n  Storage = any,\n  Config extends\n    | ExtensionConfig<Options, Storage>\n    | NodeConfig<Options, Storage>\n    | MarkConfig<Options, Storage>\n    | ExtendableConfig<Options, Storage> = ExtendableConfig<Options, Storage, any, any>,\n  PMType = any,\n> {\n  /**\n   * The extension name - this must be unique.\n   * It will be used to identify the extension.\n   *\n   * @example 'myExtension'\n   */\n  name: string\n\n  /**\n   * The priority of your extension. The higher, the earlier it will be called\n   * and will take precedence over other extensions with a lower priority.\n   * @default 100\n   * @example 101\n   */\n  priority?: number\n\n  /**\n   * This method will add options to this extension\n   * @see https://tiptap.dev/docs/editor/guide/custom-extensions#settings\n   * @example\n   * addOptions() {\n   *  return {\n   *    myOption: 'foo',\n   *    myOtherOption: 10,\n   * }\n   */\n  addOptions?: (this: { name: string; parent: ParentConfig<Config>['addOptions'] }) => Options\n\n  /**\n   * The default storage this extension can save data to.\n   * @see https://tiptap.dev/docs/editor/guide/custom-extensions#storage\n   * @example\n   * defaultStorage: {\n   *   prefetchedUsers: [],\n   *   loading: false,\n   * }\n   */\n  addStorage?: (this: { name: string; options: Options; parent: ParentConfig<Config>['addStorage'] }) => Storage\n\n  /**\n   * This function adds globalAttributes to specific nodes.\n   * @see https://tiptap.dev/docs/editor/guide/custom-extensions#global-attributes\n   * @example\n   * addGlobalAttributes() {\n   *   return [\n   *     {\n           // Extend the following extensions\n   *       types: [\n   *         'heading',\n   *         'paragraph',\n   *       ],\n   *       // â€¦ with those attributes\n   *       attributes: {\n   *         textAlign: {\n   *           default: 'left',\n   *           renderHTML: attributes => ({\n   *             style: `text-align: ${attributes.textAlign}`,\n   *           }),\n   *           parseHTML: element => element.style.textAlign || 'left',\n   *         },\n   *       },\n   *     },\n   *   ]\n   * }\n   */\n  addGlobalAttributes?: (this: {\n    name: string\n    options: Options\n    storage: Storage\n    extensions: (Node | Mark)[]\n    parent: ParentConfig<Config>['addGlobalAttributes']\n  }) => GlobalAttributes\n\n  /**\n   * This function adds commands to the editor\n   * @see https://tiptap.dev/docs/editor/guide/custom-extensions#commands\n   * @example\n   * addCommands() {\n   *   return {\n   *     myCommand: () => ({ chain }) => chain().setMark('type', 'foo').run(),\n   *   }\n   * }\n   */\n  addCommands?: (this: {\n    name: string\n    options: Options\n    storage: Storage\n    editor: Editor\n    type: PMType\n    parent: ParentConfig<Config>['addCommands']\n  }) => Partial<RawCommands>\n\n  /**\n   * This function registers keyboard shortcuts.\n   * @see https://tiptap.dev/docs/editor/guide/custom-extensions#keyboard-shortcuts\n   * @example\n   * addKeyboardShortcuts() {\n   *   return {\n   *     'Mod-l': () => this.editor.commands.toggleBulletList(),\n   *   }\n   * },\n   */\n  addKeyboardShortcuts?: (this: {\n    name: string\n    options: Options\n    storage: Storage\n    editor: Editor\n    type: PMType\n    parent: ParentConfig<Config>['addKeyboardShortcuts']\n  }) => {\n    [key: string]: KeyboardShortcutCommand\n  }\n\n  /**\n   * This function adds input rules to the editor.\n   * @see https://tiptap.dev/docs/editor/guide/custom-extensions#input-rules\n   * @example\n   * addInputRules() {\n   *   return [\n   *     markInputRule({\n   *       find: inputRegex,\n   *       type: this.type,\n   *     }),\n   *   ]\n   * },\n   */\n  addInputRules?: (this: {\n    name: string\n    options: Options\n    storage: Storage\n    editor: Editor\n    type: PMType\n    parent: ParentConfig<Config>['addInputRules']\n  }) => InputRule[]\n\n  /**\n   * This function adds paste rules to the editor.\n   * @see https://tiptap.dev/docs/editor/guide/custom-extensions#paste-rules\n   * @example\n   * addPasteRules() {\n   *   return [\n   *     markPasteRule({\n   *       find: pasteRegex,\n   *       type: this.type,\n   *     }),\n   *   ]\n   * },\n   */\n  addPasteRules?: (this: {\n    name: string\n    options: Options\n    storage: Storage\n    editor: Editor\n    type: PMType\n    parent: ParentConfig<Config>['addPasteRules']\n  }) => PasteRule[]\n\n  /**\n   * This function adds Prosemirror plugins to the editor\n   * @see https://tiptap.dev/docs/editor/guide/custom-extensions#prosemirror-plugins\n   * @example\n   * addProseMirrorPlugins() {\n   *   return [\n   *     customPlugin(),\n   *   ]\n   * }\n   */\n  addProseMirrorPlugins?: (this: {\n    name: string\n    options: Options\n    storage: Storage\n    editor: Editor\n    type: PMType\n    parent: ParentConfig<Config>['addProseMirrorPlugins']\n  }) => Plugin[]\n\n  /**\n   * This function adds additional extensions to the editor. This is useful for\n   * building extension kits.\n   * @example\n   * addExtensions() {\n   *   return [\n   *     BulletList,\n   *     OrderedList,\n   *     ListItem\n   *   ]\n   * }\n   */\n  addExtensions?: (this: {\n    name: string\n    options: Options\n    storage: Storage\n    parent: ParentConfig<Config>['addExtensions']\n  }) => Extensions\n\n  /**\n   * The markdown token name\n   *\n   * This is the name of the token that this extension uses to parse and render markdown and comes from the Marked Lexer.\n   *\n   * @see https://github.com/markedjs/marked/blob/master/src/Tokens.ts\n   *\n   */\n  markdownTokenName?: string\n\n  /**\n   * The parse function used by the markdown parser to convert markdown tokens to ProseMirror nodes.\n   */\n  parseMarkdown?: (token: MarkdownToken, helpers: MarkdownParseHelpers) => MarkdownParseResult\n\n  /**\n   * The serializer function used by the markdown serializer to convert ProseMirror nodes to markdown tokens.\n   */\n  renderMarkdown?: (node: JSONContent, helpers: MarkdownRendererHelpers, ctx: RenderContext) => string\n\n  /**\n   * The markdown tokenizer responsible for turning a markdown string into tokens\n   *\n   * Custom tokenizers are only needed when you want to parse non-standard markdown token.\n   */\n  markdownTokenizer?: MarkdownTokenizer\n\n  /**\n   * Optional markdown options for indentation\n   */\n  markdownOptions?: {\n    /**\n     * Defines if this markdown element should indent it's child elements\n     */\n    indentsContent?: boolean\n  }\n\n  /**\n   * This function extends the schema of the node.\n   * @example\n   * extendNodeSchema() {\n   *   return {\n   *     group: 'inline',\n   *     selectable: false,\n   *   }\n   * }\n   */\n  extendNodeSchema?:\n    | ((\n        this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<Config>['extendNodeSchema']\n        },\n        extension: Node,\n      ) => Record<string, any>)\n    | null\n\n  /**\n   * This function extends the schema of the mark.\n   * @example\n   * extendMarkSchema() {\n   *   return {\n   *     group: 'inline',\n   *     selectable: false,\n   *   }\n   * }\n   */\n  extendMarkSchema?:\n    | ((\n        this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<Config>['extendMarkSchema']\n        },\n        extension: Mark,\n      ) => Record<string, any>)\n    | null\n\n  /**\n   * The editor is not ready yet.\n   */\n  onBeforeCreate?:\n    | ((\n        this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: PMType\n          parent: ParentConfig<Config>['onBeforeCreate']\n        },\n        event: EditorEvents['beforeCreate'],\n      ) => void)\n    | null\n\n  /**\n   * The editor is ready.\n   */\n  onCreate?:\n    | ((\n        this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: PMType\n          parent: ParentConfig<Config>['onCreate']\n        },\n        event: EditorEvents['create'],\n      ) => void)\n    | null\n\n  /**\n   * The content has changed.\n   */\n  onUpdate?:\n    | ((\n        this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: PMType\n          parent: ParentConfig<Config>['onUpdate']\n        },\n        event: EditorEvents['update'],\n      ) => void)\n    | null\n\n  /**\n   * The selection has changed.\n   */\n  onSelectionUpdate?:\n    | ((\n        this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: PMType\n          parent: ParentConfig<Config>['onSelectionUpdate']\n        },\n        event: EditorEvents['selectionUpdate'],\n      ) => void)\n    | null\n\n  /**\n   * The editor state has changed.\n   */\n  onTransaction?:\n    | ((\n        this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: PMType\n          parent: ParentConfig<Config>['onTransaction']\n        },\n        event: EditorEvents['transaction'],\n      ) => void)\n    | null\n\n  /**\n   * The editor is focused.\n   */\n  onFocus?:\n    | ((\n        this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: PMType\n          parent: ParentConfig<Config>['onFocus']\n        },\n        event: EditorEvents['focus'],\n      ) => void)\n    | null\n\n  /**\n   * The editor isnâ€™t focused anymore.\n   */\n  onBlur?:\n    | ((\n        this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: PMType\n          parent: ParentConfig<Config>['onBlur']\n        },\n        event: EditorEvents['blur'],\n      ) => void)\n    | null\n\n  /**\n   * The editor is destroyed.\n   */\n  onDestroy?:\n    | ((\n        this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: PMType\n          parent: ParentConfig<Config>['onDestroy']\n        },\n        event: EditorEvents['destroy'],\n      ) => void)\n    | null\n\n  /**\n   * This hook allows you to intercept and modify transactions before they are dispatched.\n   *\n   * Example\n   * ```ts\n   * dispatchTransaction({ transaction, next }) {\n   *   console.log('Dispatching transaction:', transaction)\n   *   next(transaction)\n   * }\n   * ```\n   *\n   * @param props - The dispatch transaction props\n   */\n  dispatchTransaction?:\n    | ((\n        this: {\n          name: string\n          options: Options\n          storage: Storage\n          editor: Editor\n          type: PMType\n          parent: ParentConfig<Config>['dispatchTransaction']\n        },\n        props: DispatchTransactionProps,\n      ) => void)\n    | null\n}\n\nexport class Extendable<\n  Options = any,\n  Storage = any,\n  Config = ExtensionConfig<Options, Storage> | NodeConfig<Options, Storage> | MarkConfig<Options, Storage>,\n> {\n  type = 'extendable'\n  parent: Extendable | null = null\n\n  child: Extendable | null = null\n\n  name = ''\n\n  config: Config = {\n    name: this.name,\n  } as Config\n\n  constructor(config: Partial<Config> = {}) {\n    this.config = {\n      ...this.config,\n      ...config,\n    }\n\n    this.name = (this.config as any).name\n  }\n\n  get options(): Options {\n    return {\n      ...(callOrReturn(\n        getExtensionField<AnyConfig['addOptions']>(this as any, 'addOptions', {\n          name: this.name,\n        }),\n      ) || {}),\n    }\n  }\n\n  get storage(): Readonly<Storage> {\n    return {\n      ...(callOrReturn(\n        getExtensionField<AnyConfig['addStorage']>(this as any, 'addStorage', {\n          name: this.name,\n          options: this.options,\n        }),\n      ) || {}),\n    }\n  }\n\n  configure(options: Partial<Options> = {}) {\n    const extension = this.extend<Options, Storage, Config>({\n      ...this.config,\n      addOptions: () => {\n        return mergeDeep(this.options as Record<string, any>, options) as Options\n      },\n    })\n\n    extension.name = this.name\n    extension.parent = this.parent\n\n    return extension\n  }\n\n  extend<\n    ExtendedOptions = Options,\n    ExtendedStorage = Storage,\n    ExtendedConfig =\n      | ExtensionConfig<ExtendedOptions, ExtendedStorage>\n      | NodeConfig<ExtendedOptions, ExtendedStorage>\n      | MarkConfig<ExtendedOptions, ExtendedStorage>,\n  >(extendedConfig: Partial<ExtendedConfig> = {}): Extendable<ExtendedOptions, ExtendedStorage> {\n    const extension = new (this.constructor as any)({ ...this.config, ...extendedConfig })\n\n    extension.parent = this\n    this.child = extension\n    extension.name = 'name' in extendedConfig ? extendedConfig.name : extension.parent.name\n\n    return extension\n  }\n}\n","import type { DOMOutputSpec, Mark as ProseMirrorMark, MarkSpec, MarkType } from '@tiptap/pm/model'\n\nimport type { Editor } from './Editor.js'\nimport type { ExtendableConfig } from './Extendable.js'\nimport { Extendable } from './Extendable.js'\nimport type { Attributes, MarkViewRenderer, ParentConfig } from './types.js'\n\nexport interface MarkConfig<Options = any, Storage = any>\n  extends ExtendableConfig<Options, Storage, MarkConfig<Options, Storage>, MarkType> {\n  /**\n   * Mark View\n   */\n  addMarkView?:\n    | ((this: {\n        name: string\n        options: Options\n        storage: Storage\n        editor: Editor\n        type: MarkType\n        parent: ParentConfig<MarkConfig<Options, Storage>>['addMarkView']\n      }) => MarkViewRenderer)\n    | null\n\n  /**\n   * Keep mark after split node\n   */\n  keepOnSplit?: boolean | (() => boolean)\n\n  /**\n   * Inclusive\n   */\n  inclusive?:\n    | MarkSpec['inclusive']\n    | ((this: {\n        name: string\n        options: Options\n        storage: Storage\n        parent: ParentConfig<MarkConfig<Options, Storage>>['inclusive']\n        editor?: Editor\n      }) => MarkSpec['inclusive'])\n\n  /**\n   * Excludes\n   */\n  excludes?:\n    | MarkSpec['excludes']\n    | ((this: {\n        name: string\n        options: Options\n        storage: Storage\n        parent: ParentConfig<MarkConfig<Options, Storage>>['excludes']\n        editor?: Editor\n      }) => MarkSpec['excludes'])\n\n  /**\n   * Marks this Mark as exitable\n   */\n  exitable?: boolean | (() => boolean)\n\n  /**\n   * Group\n   */\n  group?:\n    | MarkSpec['group']\n    | ((this: {\n        name: string\n        options: Options\n        storage: Storage\n        parent: ParentConfig<MarkConfig<Options, Storage>>['group']\n        editor?: Editor\n      }) => MarkSpec['group'])\n\n  /**\n   * Spanning\n   */\n  spanning?:\n    | MarkSpec['spanning']\n    | ((this: {\n        name: string\n        options: Options\n        storage: Storage\n        parent: ParentConfig<MarkConfig<Options, Storage>>['spanning']\n        editor?: Editor\n      }) => MarkSpec['spanning'])\n\n  /**\n   * Code\n   */\n  code?:\n    | boolean\n    | ((this: {\n        name: string\n        options: Options\n        storage: Storage\n        parent: ParentConfig<MarkConfig<Options, Storage>>['code']\n        editor?: Editor\n      }) => boolean)\n\n  /**\n   * Parse HTML\n   */\n  parseHTML?: (this: {\n    name: string\n    options: Options\n    storage: Storage\n    parent: ParentConfig<MarkConfig<Options, Storage>>['parseHTML']\n    editor?: Editor\n  }) => MarkSpec['parseDOM']\n\n  /**\n   * Render HTML\n   */\n  renderHTML?:\n    | ((\n        this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<MarkConfig<Options, Storage>>['renderHTML']\n          editor?: Editor\n        },\n        props: {\n          mark: ProseMirrorMark\n          HTMLAttributes: Record<string, any>\n        },\n      ) => DOMOutputSpec)\n    | null\n\n  /**\n   * Attributes\n   */\n  addAttributes?: (this: {\n    name: string\n    options: Options\n    storage: Storage\n    parent: ParentConfig<MarkConfig<Options, Storage>>['addAttributes']\n    editor?: Editor\n    // eslint-disable-next-line @typescript-eslint/no-empty-object-type\n  }) => Attributes | {}\n}\n\n/**\n * The Mark class is used to create custom mark extensions.\n * @see https://tiptap.dev/api/extensions#create-a-new-extension\n */\nexport class Mark<Options = any, Storage = any> extends Extendable<Options, Storage, MarkConfig<Options, Storage>> {\n  type = 'mark'\n\n  /**\n   * Create a new Mark instance\n   * @param config - Mark configuration object or a function that returns a configuration object\n   */\n  static create<O = any, S = any>(config: Partial<MarkConfig<O, S>> | (() => Partial<MarkConfig<O, S>>) = {}) {\n    // If the config is a function, execute it to get the configuration object\n    const resolvedConfig = typeof config === 'function' ? config() : config\n    return new Mark<O, S>(resolvedConfig)\n  }\n\n  static handleExit({ editor, mark }: { editor: Editor; mark: Mark }) {\n    const { tr } = editor.state\n    const currentPos = editor.state.selection.$from\n    const isAtEnd = currentPos.pos === currentPos.end()\n\n    if (isAtEnd) {\n      const currentMarks = currentPos.marks()\n      const isInMark = !!currentMarks.find(m => m?.type.name === mark.name)\n\n      if (!isInMark) {\n        return false\n      }\n\n      const removeMark = currentMarks.find(m => m?.type.name === mark.name)\n\n      if (removeMark) {\n        tr.removeStoredMark(removeMark)\n      }\n      tr.insertText(' ', currentPos.pos)\n\n      editor.view.dispatch(tr)\n\n      return true\n    }\n\n    return false\n  }\n\n  configure(options?: Partial<Options>) {\n    return super.configure(options) as Mark<Options, Storage>\n  }\n\n  extend<\n    ExtendedOptions = Options,\n    ExtendedStorage = Storage,\n    ExtendedConfig extends MarkConfig<ExtendedOptions, ExtendedStorage> = MarkConfig<ExtendedOptions, ExtendedStorage>,\n  >(\n    extendedConfig?:\n      | (() => Partial<ExtendedConfig>)\n      | (Partial<ExtendedConfig> &\n          ThisType<{\n            name: string\n            options: ExtendedOptions\n            storage: ExtendedStorage\n            editor: Editor\n            type: MarkType\n          }>),\n  ): Mark<ExtendedOptions, ExtendedStorage> {\n    // If the extended config is a function, execute it to get the configuration object\n    const resolvedConfig = typeof extendedConfig === 'function' ? extendedConfig() : extendedConfig\n    return super.extend(resolvedConfig) as Mark<ExtendedOptions, ExtendedStorage>\n  }\n}\n","import type { Node as ProseMirrorNode } from '@tiptap/pm/model'\nimport { Fragment } from '@tiptap/pm/model'\nimport type { EditorState } from '@tiptap/pm/state'\nimport { Plugin } from '@tiptap/pm/state'\n\nimport { CommandManager } from './CommandManager.js'\nimport type { Editor } from './Editor.js'\nimport { createChainableState } from './helpers/createChainableState.js'\nimport { getHTMLFromFragment } from './helpers/getHTMLFromFragment.js'\nimport type { CanCommands, ChainedCommands, ExtendedRegExpMatchArray, Range, SingleCommands } from './types.js'\nimport { isNumber } from './utilities/isNumber.js'\nimport { isRegExp } from './utilities/isRegExp.js'\n\nexport type PasteRuleMatch = {\n  index: number\n  text: string\n  replaceWith?: string\n  match?: RegExpMatchArray\n  data?: Record<string, any>\n}\n\nexport type PasteRuleFinder =\n  | RegExp\n  | ((text: string, event?: ClipboardEvent | null) => PasteRuleMatch[] | null | undefined)\n\n/**\n * Paste rules are used to react to pasted content.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#paste-rules\n */\nexport class PasteRule {\n  find: PasteRuleFinder\n\n  handler: (props: {\n    state: EditorState\n    range: Range\n    match: ExtendedRegExpMatchArray\n    commands: SingleCommands\n    chain: () => ChainedCommands\n    can: () => CanCommands\n    pasteEvent: ClipboardEvent | null\n    dropEvent: DragEvent | null\n  }) => void | null\n\n  constructor(config: {\n    find: PasteRuleFinder\n    handler: (props: {\n      can: () => CanCommands\n      chain: () => ChainedCommands\n      commands: SingleCommands\n      dropEvent: DragEvent | null\n      match: ExtendedRegExpMatchArray\n      pasteEvent: ClipboardEvent | null\n      range: Range\n      state: EditorState\n    }) => void | null\n  }) {\n    this.find = config.find\n    this.handler = config.handler\n  }\n}\n\nconst pasteRuleMatcherHandler = (\n  text: string,\n  find: PasteRuleFinder,\n  event?: ClipboardEvent | null,\n): ExtendedRegExpMatchArray[] => {\n  if (isRegExp(find)) {\n    return [...text.matchAll(find)]\n  }\n\n  const matches = find(text, event)\n\n  if (!matches) {\n    return []\n  }\n\n  return matches.map(pasteRuleMatch => {\n    const result: ExtendedRegExpMatchArray = [pasteRuleMatch.text]\n\n    result.index = pasteRuleMatch.index\n    result.input = text\n    result.data = pasteRuleMatch.data\n\n    if (pasteRuleMatch.replaceWith) {\n      if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {\n        console.warn('[tiptap warn]: \"pasteRuleMatch.replaceWith\" must be part of \"pasteRuleMatch.text\".')\n      }\n\n      result.push(pasteRuleMatch.replaceWith)\n    }\n\n    return result\n  })\n}\n\nfunction run(config: {\n  editor: Editor\n  state: EditorState\n  from: number\n  to: number\n  rule: PasteRule\n  pasteEvent: ClipboardEvent | null\n  dropEvent: DragEvent | null\n}): boolean {\n  const { editor, state, from, to, rule, pasteEvent, dropEvent } = config\n\n  const { commands, chain, can } = new CommandManager({\n    editor,\n    state,\n  })\n\n  const handlers: (void | null)[] = []\n\n  state.doc.nodesBetween(from, to, (node, pos) => {\n    // Skip code blocks and non-textual nodes.\n    // Be defensive: `node` may be a Fragment without a `type`. Only text,\n    // inline, or textblock nodes are processed by paste rules.\n    if (node.type?.spec?.code || !(node.isText || node.isTextblock || node.isInline)) {\n      return\n    }\n\n    // For textblock and inline/text nodes, compute the range relative to the node.\n    // Prefer `node.nodeSize` when available (some Node shapes expose this),\n    // otherwise fall back to `node.content?.size`. Default to 0 if neither exists.\n    const contentSize = node.content?.size ?? node.nodeSize ?? 0\n    const resolvedFrom = Math.max(from, pos)\n    const resolvedTo = Math.min(to, pos + contentSize)\n\n    // If the resolved range is empty or invalid for this node, skip it. This\n    // avoids calling `textBetween` with start > end which can cause internal\n    // Fragment/Node traversal to access undefined `nodeSize` values.\n    if (resolvedFrom >= resolvedTo) {\n      return\n    }\n\n    const textToMatch = node.isText\n      ? node.text || ''\n      : node.textBetween(resolvedFrom - pos, resolvedTo - pos, undefined, '\\ufffc')\n\n    const matches = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent)\n\n    matches.forEach(match => {\n      if (match.index === undefined) {\n        return\n      }\n\n      const start = resolvedFrom + match.index + 1\n      const end = start + match[0].length\n      const range = {\n        from: state.tr.mapping.map(start),\n        to: state.tr.mapping.map(end),\n      }\n\n      const handler = rule.handler({\n        state,\n        range,\n        match,\n        commands,\n        chain,\n        can,\n        pasteEvent,\n        dropEvent,\n      })\n\n      handlers.push(handler)\n    })\n  })\n\n  const success = handlers.every(handler => handler !== null)\n\n  return success\n}\n\n// When dragging across editors, must get another editor instance to delete selection content.\nlet tiptapDragFromOtherEditor: Editor | null = null\n\nconst createClipboardPasteEvent = (text: string) => {\n  const event = new ClipboardEvent('paste', {\n    clipboardData: new DataTransfer(),\n  })\n\n  event.clipboardData?.setData('text/html', text)\n\n  return event\n}\n\n/**\n * Create an paste rules plugin. When enabled, it will cause pasted\n * text that matches any of the given rules to trigger the ruleâ€™s\n * action.\n */\nexport function pasteRulesPlugin(props: { editor: Editor; rules: PasteRule[] }): Plugin[] {\n  const { editor, rules } = props\n  let dragSourceElement: Element | null = null\n  let isPastedFromProseMirror = false\n  let isDroppedFromProseMirror = false\n  let pasteEvent = typeof ClipboardEvent !== 'undefined' ? new ClipboardEvent('paste') : null\n  let dropEvent: DragEvent | null\n\n  try {\n    dropEvent = typeof DragEvent !== 'undefined' ? new DragEvent('drop') : null\n  } catch {\n    dropEvent = null\n  }\n\n  const processEvent = ({\n    state,\n    from,\n    to,\n    rule,\n    pasteEvt,\n  }: {\n    state: EditorState\n    from: number\n    to: { b: number }\n    rule: PasteRule\n    pasteEvt: ClipboardEvent | null\n  }) => {\n    const tr = state.tr\n    const chainableState = createChainableState({\n      state,\n      transaction: tr,\n    })\n\n    const handler = run({\n      editor,\n      state: chainableState,\n      from: Math.max(from - 1, 0),\n      to: to.b - 1,\n      rule,\n      pasteEvent: pasteEvt,\n      dropEvent,\n    })\n\n    if (!handler || !tr.steps.length) {\n      return\n    }\n\n    try {\n      dropEvent = typeof DragEvent !== 'undefined' ? new DragEvent('drop') : null\n    } catch {\n      dropEvent = null\n    }\n    pasteEvent = typeof ClipboardEvent !== 'undefined' ? new ClipboardEvent('paste') : null\n\n    return tr\n  }\n\n  const plugins = rules.map(rule => {\n    return new Plugin({\n      // we register a global drag handler to track the current drag source element\n      view(view) {\n        const handleDragstart = (event: DragEvent) => {\n          dragSourceElement = view.dom.parentElement?.contains(event.target as Element) ? view.dom.parentElement : null\n\n          if (dragSourceElement) {\n            tiptapDragFromOtherEditor = editor\n          }\n        }\n\n        const handleDragend = () => {\n          if (tiptapDragFromOtherEditor) {\n            tiptapDragFromOtherEditor = null\n          }\n        }\n\n        window.addEventListener('dragstart', handleDragstart)\n        window.addEventListener('dragend', handleDragend)\n\n        return {\n          destroy() {\n            window.removeEventListener('dragstart', handleDragstart)\n            window.removeEventListener('dragend', handleDragend)\n          },\n        }\n      },\n\n      props: {\n        handleDOMEvents: {\n          drop: (view, event: Event) => {\n            isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement\n            dropEvent = event as DragEvent\n\n            if (!isDroppedFromProseMirror) {\n              const dragFromOtherEditor = tiptapDragFromOtherEditor\n\n              if (dragFromOtherEditor?.isEditable) {\n                // setTimeout to avoid the wrong content after drop, timeout arg can't be empty or 0\n                setTimeout(() => {\n                  const selection = dragFromOtherEditor.state.selection\n\n                  if (selection) {\n                    dragFromOtherEditor.commands.deleteRange({ from: selection.from, to: selection.to })\n                  }\n                }, 10)\n              }\n            }\n            return false\n          },\n\n          paste: (_view, event: Event) => {\n            const html = (event as ClipboardEvent).clipboardData?.getData('text/html')\n\n            pasteEvent = event as ClipboardEvent\n\n            isPastedFromProseMirror = !!html?.includes('data-pm-slice')\n\n            return false\n          },\n        },\n      },\n\n      appendTransaction: (transactions, oldState, state) => {\n        const transaction = transactions[0]\n        const isPaste = transaction.getMeta('uiEvent') === 'paste' && !isPastedFromProseMirror\n        const isDrop = transaction.getMeta('uiEvent') === 'drop' && !isDroppedFromProseMirror\n\n        // if PasteRule is triggered by insertContent()\n        const simulatedPasteMeta = transaction.getMeta('applyPasteRules') as\n          | undefined\n          | { from: number; text: string | ProseMirrorNode | Fragment }\n        const isSimulatedPaste = !!simulatedPasteMeta\n\n        if (!isPaste && !isDrop && !isSimulatedPaste) {\n          return\n        }\n\n        // Handle simulated paste\n        if (isSimulatedPaste) {\n          let { text } = simulatedPasteMeta\n\n          if (typeof text === 'string') {\n            text = text as string\n          } else {\n            text = getHTMLFromFragment(Fragment.from(text), state.schema)\n          }\n\n          const { from } = simulatedPasteMeta\n          const to = from + text.length\n\n          const pasteEvt = createClipboardPasteEvent(text)\n\n          return processEvent({\n            rule,\n            state,\n            from,\n            to: { b: to },\n            pasteEvt,\n          })\n        }\n\n        // handle actual paste/drop\n        const from = oldState.doc.content.findDiffStart(state.doc.content)\n        const to = oldState.doc.content.findDiffEnd(state.doc.content)\n\n        // stop if there is no changed range\n        if (!isNumber(from) || !to || from === to.b) {\n          return\n        }\n\n        return processEvent({\n          rule,\n          state,\n          from,\n          to,\n          pasteEvt: pasteEvent,\n        })\n      },\n    })\n  })\n\n  return plugins\n}\n","export function isNumber(value: any): value is number {\n  return typeof value === 'number'\n}\n","export { ClipboardTextSerializer } from './clipboardTextSerializer.js'\nexport { Commands } from './commands.js'\nexport { Delete } from './delete.js'\nexport { Drop } from './drop.js'\nexport { Editable } from './editable.js'\nexport { FocusEvents, focusEventsPluginKey } from './focusEvents.js'\nexport { Keymap } from './keymap.js'\nexport { Paste } from './paste.js'\nexport { Tabindex } from './tabindex.js'\nexport { TextDirection } from './textDirection.js'\n","import { Plugin, PluginKey } from '@tiptap/pm/state'\n\nimport { Extension } from '../Extension.js'\nimport { getTextBetween } from '../helpers/getTextBetween.js'\nimport { getTextSerializersFromSchema } from '../helpers/getTextSerializersFromSchema.js'\n\nexport type ClipboardTextSerializerOptions = {\n  blockSeparator?: string\n}\n\nexport const ClipboardTextSerializer = Extension.create<ClipboardTextSerializerOptions>({\n  name: 'clipboardTextSerializer',\n\n  addOptions() {\n    return {\n      blockSeparator: undefined,\n    }\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('clipboardTextSerializer'),\n        props: {\n          clipboardTextSerializer: () => {\n            const { editor } = this\n            const { state, schema } = editor\n            const { doc, selection } = state\n            const { ranges } = selection\n            const from = Math.min(...ranges.map(range => range.$from.pos))\n            const to = Math.max(...ranges.map(range => range.$to.pos))\n            const textSerializers = getTextSerializersFromSchema(schema)\n            const range = { from, to }\n\n            return getTextBetween(doc, range, {\n              ...(this.options.blockSeparator !== undefined ? { blockSeparator: this.options.blockSeparator } : {}),\n              textSerializers,\n            })\n          },\n        },\n      }),\n    ]\n  },\n})\n","import type { Editor } from './Editor.js'\nimport { type ExtendableConfig, Extendable } from './Extendable.js'\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport interface ExtensionConfig<Options = any, Storage = any>\n  extends ExtendableConfig<Options, Storage, ExtensionConfig<Options, Storage>, null> {}\n\n/**\n * The Extension class is the base class for all extensions.\n * @see https://tiptap.dev/api/extensions#create-a-new-extension\n */\nexport class Extension<Options = any, Storage = any> extends Extendable<\n  Options,\n  Storage,\n  ExtensionConfig<Options, Storage>\n> {\n  type = 'extension'\n\n  /**\n   * Create a new Extension instance\n   * @param config - Extension configuration object or a function that returns a configuration object\n   */\n  static create<O = any, S = any>(\n    config: Partial<ExtensionConfig<O, S>> | (() => Partial<ExtensionConfig<O, S>>) = {},\n  ) {\n    // If the config is a function, execute it to get the configuration object\n    const resolvedConfig = typeof config === 'function' ? config() : config\n    return new Extension<O, S>(resolvedConfig)\n  }\n\n  configure(options?: Partial<Options>) {\n    return super.configure(options) as Extension<Options, Storage>\n  }\n\n  extend<\n    ExtendedOptions = Options,\n    ExtendedStorage = Storage,\n    ExtendedConfig = ExtensionConfig<ExtendedOptions, ExtendedStorage>,\n  >(\n    extendedConfig?:\n      | (() => Partial<ExtendedConfig>)\n      | (Partial<ExtendedConfig> &\n          ThisType<{\n            name: string\n            options: ExtendedOptions\n            storage: ExtendedStorage\n            editor: Editor\n            type: null\n          }>),\n  ): Extension<ExtendedOptions, ExtendedStorage> {\n    // If the extended config is a function, execute it to get the configuration object\n    const resolvedConfig = typeof extendedConfig === 'function' ? extendedConfig() : extendedConfig\n    return super.extend(resolvedConfig) as Extension<ExtendedOptions, ExtendedStorage>\n  }\n}\n","import * as commands from '../commands/index.js'\nimport { Extension } from '../Extension.js'\n\nexport * from '../commands/index.js'\n\nexport const Commands = Extension.create({\n  name: 'commands',\n\n  addCommands() {\n    return {\n      ...commands,\n    }\n  },\n})\n","import { RemoveMarkStep } from '@tiptap/pm/transform'\n\nimport { Extension } from '../Extension.js'\nimport { combineTransactionSteps, getChangedRanges } from '../helpers/index.js'\n\n/**\n * This extension allows you to be notified when the user deletes content you are interested in.\n */\nexport const Delete = Extension.create({\n  name: 'delete',\n\n  onUpdate({ transaction, appendedTransactions }) {\n    const callback = () => {\n      if (\n        this.editor.options.coreExtensionOptions?.delete?.filterTransaction?.(transaction) ??\n        transaction.getMeta('y-sync$')\n      ) {\n        return\n      }\n      const nextTransaction = combineTransactionSteps(transaction.before, [transaction, ...appendedTransactions])\n      const changes = getChangedRanges(nextTransaction)\n\n      changes.forEach(change => {\n        if (\n          nextTransaction.mapping.mapResult(change.oldRange.from).deletedAfter &&\n          nextTransaction.mapping.mapResult(change.oldRange.to).deletedBefore\n        ) {\n          nextTransaction.before.nodesBetween(change.oldRange.from, change.oldRange.to, (node, from) => {\n            const to = from + node.nodeSize - 2\n            const isFullyWithinRange = change.oldRange.from <= from && to <= change.oldRange.to\n\n            this.editor.emit('delete', {\n              type: 'node',\n              node,\n              from,\n              to,\n              newFrom: nextTransaction.mapping.map(from),\n              newTo: nextTransaction.mapping.map(to),\n              deletedRange: change.oldRange,\n              newRange: change.newRange,\n              partial: !isFullyWithinRange,\n              editor: this.editor,\n              transaction,\n              combinedTransform: nextTransaction,\n            })\n          })\n        }\n      })\n\n      const mapping = nextTransaction.mapping\n      nextTransaction.steps.forEach((step, index) => {\n        if (step instanceof RemoveMarkStep) {\n          const newStart = mapping.slice(index).map(step.from, -1)\n          const newEnd = mapping.slice(index).map(step.to)\n          const oldStart = mapping.invert().map(newStart, -1)\n          const oldEnd = mapping.invert().map(newEnd)\n\n          const foundBeforeMark = nextTransaction.doc.nodeAt(newStart - 1)?.marks.some(mark => mark.eq(step.mark))\n          const foundAfterMark = nextTransaction.doc.nodeAt(newEnd)?.marks.some(mark => mark.eq(step.mark))\n\n          this.editor.emit('delete', {\n            type: 'mark',\n            mark: step.mark,\n            from: step.from,\n            to: step.to,\n            deletedRange: {\n              from: oldStart,\n              to: oldEnd,\n            },\n            newRange: {\n              from: newStart,\n              to: newEnd,\n            },\n            partial: Boolean(foundAfterMark || foundBeforeMark),\n            editor: this.editor,\n            transaction,\n            combinedTransform: nextTransaction,\n          })\n        }\n      })\n    }\n\n    if (this.editor.options.coreExtensionOptions?.delete?.async ?? true) {\n      setTimeout(callback, 0)\n    } else {\n      callback()\n    }\n  },\n})\n","import { Plugin, PluginKey } from '@tiptap/pm/state'\n\nimport { Extension } from '../Extension.js'\n\nexport const Drop = Extension.create({\n  name: 'drop',\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('tiptapDrop'),\n\n        props: {\n          handleDrop: (_, e, slice, moved) => {\n            this.editor.emit('drop', {\n              editor: this.editor,\n              event: e,\n              slice,\n              moved,\n            })\n          },\n        },\n      }),\n    ]\n  },\n})\n","import { Plugin, PluginKey } from '@tiptap/pm/state'\n\nimport { Extension } from '../Extension.js'\n\nexport const Editable = Extension.create({\n  name: 'editable',\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('editable'),\n        props: {\n          editable: () => this.editor.options.editable,\n        },\n      }),\n    ]\n  },\n})\n","import { Plugin, PluginKey } from '@tiptap/pm/state'\n\nimport { Extension } from '../Extension.js'\n\nexport const focusEventsPluginKey = new PluginKey('focusEvents')\n\nexport const FocusEvents = Extension.create({\n  name: 'focusEvents',\n\n  addProseMirrorPlugins() {\n    const { editor } = this\n\n    return [\n      new Plugin({\n        key: focusEventsPluginKey,\n        props: {\n          handleDOMEvents: {\n            focus: (view, event: Event) => {\n              editor.isFocused = true\n\n              const transaction = editor.state.tr.setMeta('focus', { event }).setMeta('addToHistory', false)\n\n              view.dispatch(transaction)\n\n              return false\n            },\n            blur: (view, event: Event) => {\n              editor.isFocused = false\n\n              const transaction = editor.state.tr.setMeta('blur', { event }).setMeta('addToHistory', false)\n\n              view.dispatch(transaction)\n\n              return false\n            },\n          },\n        },\n      }),\n    ]\n  },\n})\n","import { Plugin, PluginKey, Selection } from '@tiptap/pm/state'\n\nimport { CommandManager } from '../CommandManager.js'\nimport { Extension } from '../Extension.js'\nimport { createChainableState } from '../helpers/createChainableState.js'\nimport { isNodeEmpty } from '../helpers/isNodeEmpty.js'\nimport { isiOS } from '../utilities/isiOS.js'\nimport { isMacOS } from '../utilities/isMacOS.js'\n\nexport const Keymap = Extension.create({\n  name: 'keymap',\n\n  addKeyboardShortcuts() {\n    const handleBackspace = () =>\n      this.editor.commands.first(({ commands }) => [\n        () => commands.undoInputRule(),\n\n        // maybe convert first text block node to default node\n        () =>\n          commands.command(({ tr }) => {\n            const { selection, doc } = tr\n            const { empty, $anchor } = selection\n            const { pos, parent } = $anchor\n            const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr.doc.resolve(pos - 1) : $anchor\n            const parentIsIsolating = $parentPos.parent.type.spec.isolating\n\n            const parentPos = $anchor.pos - $anchor.parentOffset\n\n            const isAtStart =\n              parentIsIsolating && $parentPos.parent.childCount === 1\n                ? parentPos === $anchor.pos\n                : Selection.atStart(doc).from === pos\n\n            if (\n              !empty ||\n              !parent.type.isTextblock ||\n              parent.textContent.length ||\n              !isAtStart ||\n              (isAtStart && $anchor.parent.type.name === 'paragraph') // prevent clearNodes when no nodes to clear, otherwise history stack is appended\n            ) {\n              return false\n            }\n\n            return commands.clearNodes()\n          }),\n\n        () => commands.deleteSelection(),\n        () => commands.joinBackward(),\n        () => commands.selectNodeBackward(),\n      ])\n\n    const handleDelete = () =>\n      this.editor.commands.first(({ commands }) => [\n        () => commands.deleteSelection(),\n        () => commands.deleteCurrentNode(),\n        () => commands.joinForward(),\n        () => commands.selectNodeForward(),\n      ])\n\n    const handleEnter = () =>\n      this.editor.commands.first(({ commands }) => [\n        () => commands.newlineInCode(),\n        () => commands.createParagraphNear(),\n        () => commands.liftEmptyBlock(),\n        () => commands.splitBlock(),\n      ])\n\n    const baseKeymap = {\n      Enter: handleEnter,\n      'Mod-Enter': () => this.editor.commands.exitCode(),\n      Backspace: handleBackspace,\n      'Mod-Backspace': handleBackspace,\n      'Shift-Backspace': handleBackspace,\n      Delete: handleDelete,\n      'Mod-Delete': handleDelete,\n      'Mod-a': () => this.editor.commands.selectAll(),\n    }\n\n    const pcKeymap = {\n      ...baseKeymap,\n    }\n\n    const macKeymap = {\n      ...baseKeymap,\n      'Ctrl-h': handleBackspace,\n      'Alt-Backspace': handleBackspace,\n      'Ctrl-d': handleDelete,\n      'Ctrl-Alt-Backspace': handleDelete,\n      'Alt-Delete': handleDelete,\n      'Alt-d': handleDelete,\n      'Ctrl-a': () => this.editor.commands.selectTextblockStart(),\n      'Ctrl-e': () => this.editor.commands.selectTextblockEnd(),\n    }\n\n    if (isiOS() || isMacOS()) {\n      return macKeymap\n    }\n\n    return pcKeymap\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      // With this plugin we check if the whole document was selected and deleted.\n      // In this case we will additionally call `clearNodes()` to convert e.g. a heading\n      // to a paragraph if necessary.\n      // This is an alternative to ProseMirror's `AllSelection`, which doesnâ€™t work well\n      // with many other commands.\n      new Plugin({\n        key: new PluginKey('clearDocument'),\n        appendTransaction: (transactions, oldState, newState) => {\n          if (transactions.some(tr => tr.getMeta('composition'))) {\n            return\n          }\n\n          const docChanges = transactions.some(transaction => transaction.docChanged) && !oldState.doc.eq(newState.doc)\n\n          const ignoreTr = transactions.some(transaction => transaction.getMeta('preventClearDocument'))\n\n          if (!docChanges || ignoreTr) {\n            return\n          }\n\n          const { empty, from, to } = oldState.selection\n          const allFrom = Selection.atStart(oldState.doc).from\n          const allEnd = Selection.atEnd(oldState.doc).to\n          const allWasSelected = from === allFrom && to === allEnd\n\n          if (empty || !allWasSelected) {\n            return\n          }\n\n          const isEmpty = isNodeEmpty(newState.doc)\n\n          if (!isEmpty) {\n            return\n          }\n\n          const tr = newState.tr\n          const state = createChainableState({\n            state: newState,\n            transaction: tr,\n          })\n          const { commands } = new CommandManager({\n            editor: this.editor,\n            state,\n          })\n\n          commands.clearNodes()\n\n          if (!tr.steps.length) {\n            return\n          }\n\n          return tr\n        },\n      }),\n    ]\n  },\n})\n","import { Plugin, PluginKey } from '@tiptap/pm/state'\n\nimport { Extension } from '../Extension.js'\n\nexport const Paste = Extension.create({\n  name: 'paste',\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('tiptapPaste'),\n\n        props: {\n          handlePaste: (_view, e, slice) => {\n            this.editor.emit('paste', {\n              editor: this.editor,\n              event: e,\n              slice,\n            })\n          },\n        },\n      }),\n    ]\n  },\n})\n","import { Plugin, PluginKey } from '@tiptap/pm/state'\n\nimport { Extension } from '../Extension.js'\n\nexport const Tabindex = Extension.create({\n  name: 'tabindex',\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('tabindex'),\n        props: {\n          attributes: (): { [name: string]: string } => (this.editor.isEditable ? { tabindex: '0' } : {}),\n        },\n      }),\n    ]\n  },\n})\n","import { Plugin, PluginKey } from '@tiptap/pm/state'\n\nimport { Extension } from '../Extension.js'\nimport { splitExtensions } from '../helpers/splitExtensions.js'\n\nexport interface TextDirectionOptions {\n  direction: 'ltr' | 'rtl' | 'auto' | undefined\n}\n\n/**\n * The TextDirection extension adds support for setting text direction (LTR/RTL/auto)\n * on all nodes in the editor.\n *\n * This extension adds a global `dir` attribute to all node types, which can be used\n * to control bidirectional text rendering. The direction can be set globally via\n * editor options or per-node using commands.\n */\nexport const TextDirection = Extension.create<TextDirectionOptions>({\n  name: 'textDirection',\n\n  addOptions() {\n    return {\n      direction: undefined,\n    }\n  },\n\n  addGlobalAttributes() {\n    // Only add the dir attribute to nodes if text direction is configured\n    // This prevents null/undefined values from appearing in JSON exports\n    if (!this.options.direction) {\n      return []\n    }\n\n    const { nodeExtensions } = splitExtensions(this.extensions)\n\n    return [\n      {\n        types: nodeExtensions.filter(extension => extension.name !== 'text').map(extension => extension.name),\n        attributes: {\n          dir: {\n            default: this.options.direction,\n            parseHTML: element => {\n              const dir = element.getAttribute('dir')\n\n              if (dir && (dir === 'ltr' || dir === 'rtl' || dir === 'auto')) {\n                return dir\n              }\n\n              return this.options.direction\n            },\n            renderHTML: attributes => {\n              if (!attributes.dir) {\n                return {}\n              }\n\n              return {\n                dir: attributes.dir,\n              }\n            },\n          },\n        },\n      },\n    ]\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      new Plugin({\n        key: new PluginKey('textDirection'),\n        props: {\n          attributes: (): { [name: string]: string } => {\n            const direction = this.options.direction\n\n            if (!direction) {\n              return {}\n            }\n\n            return {\n              dir: direction,\n            }\n          },\n        },\n      }),\n    ]\n  },\n})\n","import type { Fragment, Node, ResolvedPos } from '@tiptap/pm/model'\n\nimport type { Editor } from './Editor.js'\nimport type { Content, Range } from './types.js'\n\nexport class NodePos {\n  private resolvedPos: ResolvedPos\n\n  private isBlock: boolean\n\n  private editor: Editor\n\n  private get name(): string {\n    return this.node.type.name\n  }\n\n  constructor(pos: ResolvedPos, editor: Editor, isBlock = false, node: Node | null = null) {\n    this.isBlock = isBlock\n    this.resolvedPos = pos\n    this.editor = editor\n    this.currentNode = node\n  }\n\n  private currentNode: Node | null = null\n\n  get node(): Node {\n    return this.currentNode || this.resolvedPos.node()\n  }\n\n  get element(): HTMLElement {\n    return this.editor.view.domAtPos(this.pos).node as HTMLElement\n  }\n\n  public actualDepth: number | null = null\n\n  get depth(): number {\n    return this.actualDepth ?? this.resolvedPos.depth\n  }\n\n  get pos(): number {\n    return this.resolvedPos.pos\n  }\n\n  get content(): Fragment {\n    return this.node.content\n  }\n\n  set content(content: Content) {\n    let from = this.from\n    let to = this.to\n\n    if (this.isBlock) {\n      if (this.content.size === 0) {\n        console.error(`You canâ€™t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`)\n        return\n      }\n\n      from = this.from + 1\n      to = this.to - 1\n    }\n\n    this.editor.commands.insertContentAt({ from, to }, content)\n  }\n\n  get attributes(): { [key: string]: any } {\n    return this.node.attrs\n  }\n\n  get textContent(): string {\n    return this.node.textContent\n  }\n\n  get size(): number {\n    return this.node.nodeSize\n  }\n\n  get from(): number {\n    if (this.isBlock) {\n      return this.pos\n    }\n\n    return this.resolvedPos.start(this.resolvedPos.depth)\n  }\n\n  get range(): Range {\n    return {\n      from: this.from,\n      to: this.to,\n    }\n  }\n\n  get to(): number {\n    if (this.isBlock) {\n      return this.pos + this.size\n    }\n\n    return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1)\n  }\n\n  get parent(): NodePos | null {\n    if (this.depth === 0) {\n      return null\n    }\n\n    const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1)\n    const $pos = this.resolvedPos.doc.resolve(parentPos)\n\n    return new NodePos($pos, this.editor)\n  }\n\n  get before(): NodePos | null {\n    let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2))\n\n    if ($pos.depth !== this.depth) {\n      $pos = this.resolvedPos.doc.resolve(this.from - 3)\n    }\n\n    return new NodePos($pos, this.editor)\n  }\n\n  get after(): NodePos | null {\n    let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1))\n\n    if ($pos.depth !== this.depth) {\n      $pos = this.resolvedPos.doc.resolve(this.to + 3)\n    }\n\n    return new NodePos($pos, this.editor)\n  }\n\n  get children(): NodePos[] {\n    const children: NodePos[] = []\n\n    this.node.content.forEach((node, offset) => {\n      const isBlock = node.isBlock && !node.isTextblock\n      const isNonTextAtom = node.isAtom && !node.isText\n\n      const targetPos = this.pos + offset + (isNonTextAtom ? 0 : 1)\n\n      // Check if targetPos is within valid document range\n      if (targetPos < 0 || targetPos > this.resolvedPos.doc.nodeSize - 2) {\n        return\n      }\n\n      const $pos = this.resolvedPos.doc.resolve(targetPos)\n\n      if (!isBlock && $pos.depth <= this.depth) {\n        return\n      }\n\n      const childNodePos = new NodePos($pos, this.editor, isBlock, isBlock ? node : null)\n\n      if (isBlock) {\n        childNodePos.actualDepth = this.depth + 1\n      }\n\n      children.push(new NodePos($pos, this.editor, isBlock, isBlock ? node : null))\n    })\n\n    return children\n  }\n\n  get firstChild(): NodePos | null {\n    return this.children[0] || null\n  }\n\n  get lastChild(): NodePos | null {\n    const children = this.children\n\n    return children[children.length - 1] || null\n  }\n\n  closest(selector: string, attributes: { [key: string]: any } = {}): NodePos | null {\n    let node: NodePos | null = null\n    let currentNode = this.parent\n\n    while (currentNode && !node) {\n      if (currentNode.node.type.name === selector) {\n        if (Object.keys(attributes).length > 0) {\n          const nodeAttributes = currentNode.node.attrs\n          const attrKeys = Object.keys(attributes)\n\n          for (let index = 0; index < attrKeys.length; index += 1) {\n            const key = attrKeys[index]\n\n            if (nodeAttributes[key] !== attributes[key]) {\n              break\n            }\n          }\n        } else {\n          node = currentNode\n        }\n      }\n\n      currentNode = currentNode.parent\n    }\n\n    return node\n  }\n\n  querySelector(selector: string, attributes: { [key: string]: any } = {}): NodePos | null {\n    return this.querySelectorAll(selector, attributes, true)[0] || null\n  }\n\n  querySelectorAll(selector: string, attributes: { [key: string]: any } = {}, firstItemOnly = false): NodePos[] {\n    let nodes: NodePos[] = []\n\n    if (!this.children || this.children.length === 0) {\n      return nodes\n    }\n    const attrKeys = Object.keys(attributes)\n\n    /**\n     * Finds all children recursively that match the selector and attributes\n     * If firstItemOnly is true, it will return the first item found\n     */\n    this.children.forEach(childPos => {\n      // If we already found a node and we only want the first item, we dont need to keep going\n      if (firstItemOnly && nodes.length > 0) {\n        return\n      }\n\n      if (childPos.node.type.name === selector) {\n        const doesAllAttributesMatch = attrKeys.every(key => attributes[key] === childPos.node.attrs[key])\n\n        if (doesAllAttributesMatch) {\n          nodes.push(childPos)\n        }\n      }\n\n      // If we already found a node and we only want the first item, we can stop here and skip the recursion\n      if (firstItemOnly && nodes.length > 0) {\n        return\n      }\n\n      nodes = nodes.concat(childPos.querySelectorAll(selector, attributes, firstItemOnly))\n    })\n\n    return nodes\n  }\n\n  setAttribute(attributes: { [key: string]: any }) {\n    const { tr } = this.editor.state\n\n    tr.setNodeMarkup(this.from, undefined, {\n      ...this.node.attrs,\n      ...attributes,\n    })\n\n    this.editor.view.dispatch(tr)\n  }\n}\n","export const style = `.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: \"liga\" 0; /* the above doesn't seem to work in Edge */\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 0 !important;\n  height: 0 !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}`\n","export function createStyleTag(style: string, nonce?: string, suffix?: string): HTMLStyleElement {\n  const tiptapStyleTag = <HTMLStyleElement>(\n    document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : ''}]`)\n  )\n\n  if (tiptapStyleTag !== null) {\n    return tiptapStyleTag\n  }\n\n  const styleNode = document.createElement('style')\n\n  if (nonce) {\n    styleNode.setAttribute('nonce', nonce)\n  }\n\n  styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : ''}`, '')\n  styleNode.innerHTML = style\n  document.getElementsByTagName('head')[0].appendChild(styleNode)\n\n  return styleNode\n}\n","import type { MarkType } from '@tiptap/pm/model'\n\nimport { getMarksBetween } from '../helpers/getMarksBetween.js'\nimport type { InputRuleFinder } from '../InputRule.js'\nimport { InputRule } from '../InputRule.js'\nimport type { ExtendedRegExpMatchArray } from '../types.js'\nimport { callOrReturn } from '../utilities/callOrReturn.js'\n\n/**\n * Build an input rule that adds a mark when the\n * matched text is typed into it.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#input-rules\n */\nexport function markInputRule(config: {\n  find: InputRuleFinder\n  type: MarkType\n  undoable?: boolean\n  getAttributes?: Record<string, any> | ((match: ExtendedRegExpMatchArray) => Record<string, any>) | false | null\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match)\n\n      if (attributes === false || attributes === null) {\n        return null\n      }\n\n      const { tr } = state\n      const captureGroup = match[match.length - 1]\n      const fullMatch = match[0]\n\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/)\n        const textStart = range.from + fullMatch.indexOf(captureGroup)\n        const textEnd = textStart + captureGroup.length\n\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc)\n          .filter(item => {\n            // @ts-ignore\n            const excluded = item.mark.type.excluded as MarkType[]\n\n            return excluded.find(type => type === config.type && type !== item.mark.type)\n          })\n          .filter(item => item.to > textStart)\n\n        if (excludedMarks.length) {\n          return null\n        }\n\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to)\n        }\n\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart)\n        }\n\n        const markEnd = range.from + startSpaces + captureGroup.length\n\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}))\n\n        tr.removeStoredMark(config.type)\n      }\n    },\n    undoable: config.undoable,\n  })\n}\n","import type { NodeType } from '@tiptap/pm/model'\n\nimport type { InputRuleFinder } from '../InputRule.js'\nimport { InputRule } from '../InputRule.js'\nimport type { ExtendedRegExpMatchArray } from '../types.js'\nimport { callOrReturn } from '../utilities/callOrReturn.js'\n\n/**\n * Build an input rule that adds a node when the\n * matched text is typed into it.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#input-rules\n */\nexport function nodeInputRule(config: {\n  /**\n   * The regex to match.\n   */\n  find: InputRuleFinder\n\n  /**\n   * The node type to add.\n   */\n  type: NodeType\n\n  /**\n   * Whether the input rule should be undoable\n   * when the user presses backspace.\n   */\n  undoable?: boolean\n\n  /**\n   * A function that returns the attributes for the node\n   * can also be an object of attributes\n   */\n  getAttributes?: Record<string, any> | ((match: ExtendedRegExpMatchArray) => Record<string, any>) | false | null\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {}\n      const { tr } = state\n      const start = range.from\n      let end = range.to\n\n      const newNode = config.type.create(attributes)\n\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1])\n        let matchStart = start + offset\n\n        if (matchStart > end) {\n          matchStart = end\n        } else {\n          end = matchStart + match[1].length\n        }\n\n        // insert last typed character\n        const lastChar = match[0][match[0].length - 1]\n\n        tr.insertText(lastChar, start + match[0].length - 1)\n\n        // insert node from input rule\n        tr.replaceWith(matchStart, end, newNode)\n      } else if (match[0]) {\n        const insertionStart = config.type.isInline ? start : start - 1\n\n        tr.insert(insertionStart, config.type.create(attributes)).delete(tr.mapping.map(start), tr.mapping.map(end))\n      }\n\n      tr.scrollIntoView()\n    },\n    undoable: config.undoable,\n  })\n}\n","import type { NodeType } from '@tiptap/pm/model'\n\nimport type { InputRuleFinder } from '../InputRule.js'\nimport { InputRule } from '../InputRule.js'\nimport type { ExtendedRegExpMatchArray } from '../types.js'\nimport { callOrReturn } from '../utilities/callOrReturn.js'\n\n/**\n * Build an input rule that changes the type of a textblock when the\n * matched text is typed into it. When using a regular expresion youâ€™ll\n * probably want the regexp to start with `^`, so that the pattern can\n * only occur at the start of a textblock.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#input-rules\n */\nexport function textblockTypeInputRule(config: {\n  find: InputRuleFinder\n  type: NodeType\n  undoable?: boolean\n  getAttributes?: Record<string, any> | ((match: ExtendedRegExpMatchArray) => Record<string, any>) | false | null\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      const $start = state.doc.resolve(range.from)\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {}\n\n      if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {\n        return null\n      }\n\n      state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes)\n    },\n    undoable: config.undoable,\n  })\n}\n","import type { InputRuleFinder } from '../InputRule.js'\nimport { InputRule } from '../InputRule.js'\n\n/**\n * Build an input rule that replaces text when the\n * matched text is typed into it.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#input-rules\n */\nexport function textInputRule(config: { find: InputRuleFinder; replace: string; undoable?: boolean }) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      let insert = config.replace\n      let start = range.from\n      const end = range.to\n\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1])\n\n        insert += match[0].slice(offset + match[1].length)\n        start += offset\n\n        const cutOff = start - end\n\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert\n          start = end\n        }\n      }\n\n      state.tr.insertText(insert, start, end)\n    },\n    undoable: config.undoable,\n  })\n}\n","import type { Node as ProseMirrorNode, NodeType } from '@tiptap/pm/model'\nimport { canJoin, findWrapping } from '@tiptap/pm/transform'\n\nimport type { Editor } from '../Editor.js'\nimport type { InputRuleFinder } from '../InputRule.js'\nimport { InputRule } from '../InputRule.js'\nimport type { ExtendedRegExpMatchArray } from '../types.js'\nimport { callOrReturn } from '../utilities/callOrReturn.js'\n\n/**\n * Build an input rule for automatically wrapping a textblock when a\n * given string is typed. When using a regular expresion youâ€™ll\n * probably want the regexp to start with `^`, so that the pattern can\n * only occur at the start of a textblock.\n *\n * `type` is the type of node to wrap in.\n *\n * By default, if thereâ€™s a node with the same type above the newly\n * wrapped node, the rule will try to join those\n * two nodes. You can pass a join predicate, which takes a regular\n * expression match and the node before the wrapped node, and can\n * return a boolean to indicate whether a join should happen.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#input-rules\n */\nexport function wrappingInputRule(config: {\n  find: InputRuleFinder\n  type: NodeType\n  keepMarks?: boolean\n  keepAttributes?: boolean\n  editor?: Editor\n  undoable?: boolean\n  getAttributes?: Record<string, any> | ((match: ExtendedRegExpMatchArray) => Record<string, any>) | false | null\n  joinPredicate?: (match: ExtendedRegExpMatchArray, node: ProseMirrorNode) => boolean\n}) {\n  return new InputRule({\n    find: config.find,\n    handler: ({ state, range, match, chain }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match) || {}\n      const tr = state.tr.delete(range.from, range.to)\n      const $start = tr.doc.resolve(range.from)\n      const blockRange = $start.blockRange()\n      const wrapping = blockRange && findWrapping(blockRange, config.type, attributes)\n\n      if (!wrapping) {\n        return null\n      }\n\n      tr.wrap(blockRange, wrapping)\n\n      if (config.keepMarks && config.editor) {\n        const { selection, storedMarks } = state\n        const { splittableMarks } = config.editor.extensionManager\n        const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks())\n\n        if (marks) {\n          const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name))\n\n          tr.ensureMarks(filteredMarks)\n        }\n      }\n      if (config.keepAttributes) {\n        /** If the nodeType is `bulletList` or `orderedList` set the `nodeType` as `listItem` */\n        const nodeType =\n          config.type.name === 'bulletList' || config.type.name === 'orderedList' ? 'listItem' : 'taskList'\n\n        chain().updateAttributes(nodeType, attributes).run()\n      }\n\n      const before = tr.doc.resolve(range.from - 1).nodeBefore\n\n      if (\n        before &&\n        before.type === config.type &&\n        canJoin(tr.doc, range.from - 1) &&\n        (!config.joinPredicate || config.joinPredicate(match, before))\n      ) {\n        tr.join(range.from - 1)\n      }\n    },\n    undoable: config.undoable,\n  })\n}\n","export type Attributes = Record<string, any>\n\nexport type DOMOutputSpecElement = 0 | Attributes | DOMOutputSpecArray\n/**\n * Better describes the output of a `renderHTML` function in prosemirror\n * @see https://prosemirror.net/docs/ref/#model.DOMOutputSpec\n */\nexport type DOMOutputSpecArray =\n  | [string]\n  | [string, Attributes]\n  | [string, 0]\n  | [string, Attributes, 0]\n  | [string, Attributes, DOMOutputSpecArray | 0]\n  | [string, DOMOutputSpecArray]\n\n// JSX types for Tiptap's JSX runtime\n// These types only apply when using @jsxImportSource @tiptap/core\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace JSX {\n  export type Element = DOMOutputSpecArray\n  export interface IntrinsicElements {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    [key: string]: any\n  }\n  export interface ElementChildrenAttribute {\n    children: unknown\n  }\n}\n\nexport type JSXRenderer = (\n  tag: 'slot' | string | ((props?: Attributes) => DOMOutputSpecArray | DOMOutputSpecElement),\n  props?: Attributes,\n  ...children: JSXRenderer[]\n) => DOMOutputSpecArray | DOMOutputSpecElement\n\nexport function Fragment(props: { children: JSXRenderer[] }) {\n  return props.children\n}\n\nexport const h: JSXRenderer = (tag, attributes) => {\n  // Treat the slot tag as the Prosemirror hole to render content into\n  if (tag === 'slot') {\n    return 0\n  }\n\n  // If the tag is a function, call it with the props\n  if (tag instanceof Function) {\n    return tag(attributes)\n  }\n\n  const { children, ...rest } = attributes ?? {}\n\n  if (tag === 'svg') {\n    throw new Error('SVG elements are not supported in the JSX syntax, use the array syntax instead')\n  }\n\n  // Otherwise, return the tag, attributes, and children\n  return [tag, rest, children]\n}\n\n// See\n// https://esbuild.github.io/api/#jsx-import-source\n// https://www.typescriptlang.org/tsconfig/#jsxImportSource\n\nexport { h as createElement, h as jsx, h as jsxDEV, h as jsxs }\n","import type { Node as PMNode } from '@tiptap/pm/model'\nimport type { Decoration, DecorationSource, NodeView } from '@tiptap/pm/view'\n\nimport type { Editor } from '../Editor.js'\n\nconst isTouchEvent = (e: MouseEvent | TouchEvent): e is TouchEvent => {\n  return 'touches' in e\n}\n\n/**\n * Directions where resize handles can be placed\n *\n * @example\n * - `'top'` - Top edge handle\n * - `'bottom-right'` - Bottom-right corner handle\n */\nexport type ResizableNodeViewDirection =\n  | 'top'\n  | 'right'\n  | 'bottom'\n  | 'left'\n  | 'top-right'\n  | 'top-left'\n  | 'bottom-right'\n  | 'bottom-left'\n\n/**\n * Dimensions for the resizable node in pixels\n */\nexport type ResizableNodeDimensions = {\n  /** Width in pixels */\n  width: number\n  /** Height in pixels */\n  height: number\n}\n\n/**\n * Configuration options for creating a ResizableNodeView\n *\n * @example\n * ```ts\n * new ResizableNodeView({\n *   element: imgElement,\n *   node,\n *   getPos,\n *   onResize: (width, height) => {\n *     imgElement.style.width = `${width}px`\n *     imgElement.style.height = `${height}px`\n *   },\n *   onCommit: (width, height) => {\n *     editor.commands.updateAttributes('image', { width, height })\n *   },\n *   onUpdate: (node) => true,\n *   options: {\n *     directions: ['bottom-right', 'bottom-left'],\n *     min: { width: 100, height: 100 },\n *     preserveAspectRatio: true\n *   }\n * })\n * ```\n */\nexport type ResizableNodeViewOptions = {\n  /**\n   * The DOM element to make resizable (e.g., an img, video, or iframe element)\n   */\n  element: HTMLElement\n\n  /**\n   * The DOM element that will hold the editable content element\n   */\n  contentElement?: HTMLElement\n\n  /**\n   * The ProseMirror node instance\n   */\n  node: PMNode\n\n  /**\n   * The Tiptap editor instance\n   */\n  editor: Editor\n\n  /**\n   * Function that returns the current position of the node in the document\n   */\n  getPos: () => number | undefined\n\n  /**\n   * Callback fired continuously during resize with current dimensions.\n   * Use this to update the element's visual size in real-time.\n   *\n   * @param width - Current width in pixels\n   * @param height - Current height in pixels\n   *\n   * @example\n   * ```ts\n   * onResize: (width, height) => {\n   *   element.style.width = `${width}px`\n   *   element.style.height = `${height}px`\n   * }\n   * ```\n   */\n  onResize?: (width: number, height: number) => void\n\n  /**\n   * Callback fired once when resize completes with final dimensions.\n   * Use this to persist the new size to the node's attributes.\n   *\n   * @param width - Final width in pixels\n   * @param height - Final height in pixels\n   *\n   * @example\n   * ```ts\n   * onCommit: (width, height) => {\n   *   const pos = getPos()\n   *   if (pos !== undefined) {\n   *     editor.commands.updateAttributes('image', { width, height })\n   *   }\n   * }\n   * ```\n   */\n  onCommit: (width: number, height: number) => void\n\n  /**\n   * Callback for handling node updates.\n   * Return `true` to accept the update, `false` to reject it.\n   *\n   * @example\n   * ```ts\n   * onUpdate: (node, decorations, innerDecorations) => {\n   *   if (node.type !== this.node.type) return false\n   *   return true\n   * }\n   * ```\n   */\n  onUpdate: NodeView['update']\n\n  /**\n   * Optional configuration for resize behavior and styling\n   */\n  options?: {\n    /**\n     * Which resize handles to display.\n     * @default ['bottom-left', 'bottom-right', 'top-left', 'top-right']\n     *\n     * @example\n     * ```ts\n     * // Only show corner handles\n     * directions: ['top-left', 'top-right', 'bottom-left', 'bottom-right']\n     *\n     * // Only show right edge handle\n     * directions: ['right']\n     * ```\n     */\n    directions?: ResizableNodeViewDirection[]\n\n    /**\n     * Minimum dimensions in pixels\n     * @default { width: 8, height: 8 }\n     *\n     * @example\n     * ```ts\n     * min: { width: 100, height: 50 }\n     * ```\n     */\n    min?: Partial<ResizableNodeDimensions>\n\n    /**\n     * Maximum dimensions in pixels\n     * @default undefined (no maximum)\n     *\n     * @example\n     * ```ts\n     * max: { width: 1000, height: 800 }\n     * ```\n     */\n    max?: Partial<ResizableNodeDimensions>\n\n    /**\n     * Always preserve aspect ratio when resizing.\n     * When `false`, aspect ratio is preserved only when Shift key is pressed.\n     * @default false\n     *\n     * @example\n     * ```ts\n     * preserveAspectRatio: true // Always lock aspect ratio\n     * ```\n     */\n    preserveAspectRatio?: boolean\n\n    /**\n     * Custom CSS class names for styling\n     *\n     * @example\n     * ```ts\n     * className: {\n     *   container: 'resize-container',\n     *   wrapper: 'resize-wrapper',\n     *   handle: 'resize-handle',\n     *   resizing: 'is-resizing'\n     * }\n     * ```\n     */\n    className?: {\n      /** Class for the outer container element */\n      container?: string\n      /** Class for the wrapper element that contains the resizable element */\n      wrapper?: string\n      /** Class applied to all resize handles */\n      handle?: string\n      /** Class added to container while actively resizing */\n      resizing?: string\n    }\n\n    /**\n     * Optional callback for creating custom resize handle elements.\n     *\n     * This function allows developers to define their own handle element\n     * (e.g., custom icons, classes, or styles) for a given resize direction.\n     * It is called internally for each handle direction.\n     *\n     * @param direction - The direction of the handle being created (e.g., 'top', 'bottom-right').\n     * @returns The custom handle HTMLElement.\n     *\n     * @example\n     * ```ts\n     * createCustomHandle: (direction) => {\n     *   const handle = document.createElement('div')\n     *   handle.dataset.resizeHandle = direction\n     *   handle.style.position = 'absolute'\n     *   handle.className = 'tiptap-custom-handle'\n     *\n     *   const isTop = direction.includes('top')\n     *   const isBottom = direction.includes('bottom')\n     *   const isLeft = direction.includes('left')\n     *   const isRight = direction.includes('right')\n     *\n     *   if (isTop) handle.style.top = '0'\n     *   if (isBottom) handle.style.bottom = '0'\n     *   if (isLeft) handle.style.left = '0'\n     *   if (isRight) handle.style.right = '0'\n     *\n     *   // Edge handles span the full width or height\n     *   if (direction === 'top' || direction === 'bottom') {\n     *     handle.style.left = '0'\n     *     handle.style.right = '0'\n     *   }\n     *\n     *   if (direction === 'left' || direction === 'right') {\n     *     handle.style.top = '0'\n     *     handle.style.bottom = '0'\n     *   }\n     *\n     *   return handle\n     * }\n     * ```\n     */\n    createCustomHandle?: (direction: ResizableNodeViewDirection) => HTMLElement\n  }\n}\n\n/**\n * A NodeView implementation that adds resize handles to any DOM element.\n *\n * This class creates a resizable node view for Tiptap/ProseMirror editors.\n * It wraps your element with resize handles and manages the resize interaction,\n * including aspect ratio preservation, min/max constraints, and keyboard modifiers.\n *\n * @example\n * ```ts\n * // Basic usage in a Tiptap extension\n * addNodeView() {\n *   return ({ node, getPos }) => {\n *     const img = document.createElement('img')\n *     img.src = node.attrs.src\n *\n *     return new ResizableNodeView({\n *       element: img,\n *       node,\n *       getPos,\n *       onResize: (width, height) => {\n *         img.style.width = `${width}px`\n *         img.style.height = `${height}px`\n *       },\n *       onCommit: (width, height) => {\n *         this.editor.commands.updateAttributes('image', { width, height })\n *       },\n *       onUpdate: () => true,\n *       options: {\n *         min: { width: 100, height: 100 },\n *         preserveAspectRatio: true\n *       }\n *     })\n *   }\n * }\n * ```\n */\nexport class ResizableNodeView {\n  /** The ProseMirror node instance */\n  node: PMNode\n\n  /** The Tiptap editor instance */\n  editor: Editor\n\n  /** The DOM element being made resizable */\n  element: HTMLElement\n\n  /** The editable DOM element inside the DOM */\n  contentElement?: HTMLElement\n\n  /** The outer container element (returned as NodeView.dom) */\n  container: HTMLElement\n\n  /** The wrapper element that contains the element and handles */\n  wrapper: HTMLElement\n\n  /** Function to get the current node position */\n  getPos: () => number | undefined\n\n  /** Callback fired during resize */\n  onResize?: (width: number, height: number) => void\n\n  /** Callback fired when resize completes */\n  onCommit: (width: number, height: number) => void\n\n  /** Callback for node updates */\n  onUpdate?: NodeView['update']\n\n  /** Active resize handle directions */\n  directions: ResizableNodeViewDirection[] = ['bottom-left', 'bottom-right', 'top-left', 'top-right']\n\n  /** Minimum allowed dimensions */\n  minSize: ResizableNodeDimensions = {\n    height: 8,\n    width: 8,\n  }\n\n  /** Maximum allowed dimensions (optional) */\n  maxSize?: Partial<ResizableNodeDimensions>\n\n  /** Whether to always preserve aspect ratio */\n  preserveAspectRatio: boolean = false\n\n  /** CSS class names for elements */\n  classNames = {\n    container: '',\n    wrapper: '',\n    handle: '',\n    resizing: '',\n  }\n\n  /** Optional callback for creating custom resize handles */\n  createCustomHandle?: (direction: ResizableNodeViewDirection) => HTMLElement\n\n  /** Initial width of the element (for aspect ratio calculation) */\n  private initialWidth: number = 0\n\n  /** Initial height of the element (for aspect ratio calculation) */\n  private initialHeight: number = 0\n\n  /** Calculated aspect ratio (width / height) */\n  private aspectRatio: number = 1\n\n  /** Whether a resize operation is currently active */\n  private isResizing: boolean = false\n\n  /** The handle currently being dragged */\n  private activeHandle: ResizableNodeViewDirection | null = null\n\n  /** Starting mouse X position when resize began */\n  private startX: number = 0\n\n  /** Starting mouse Y position when resize began */\n  private startY: number = 0\n\n  /** Element width when resize began */\n  private startWidth: number = 0\n\n  /** Element height when resize began */\n  private startHeight: number = 0\n\n  /** Whether Shift key is currently pressed (for temporary aspect ratio lock) */\n  private isShiftKeyPressed: boolean = false\n\n  /** Last known editable state of the editor */\n  private lastEditableState: boolean | undefined = undefined\n\n  /** Map of handle elements by direction */\n  private handleMap = new Map<ResizableNodeViewDirection, HTMLElement>()\n\n  /**\n   * Creates a new ResizableNodeView instance.\n   *\n   * The constructor sets up the resize handles, applies initial sizing from\n   * node attributes, and configures all resize behavior options.\n   *\n   * @param options - Configuration options for the resizable node view\n   */\n  constructor(options: ResizableNodeViewOptions) {\n    this.node = options.node\n    this.editor = options.editor\n    this.element = options.element\n    this.contentElement = options.contentElement\n\n    this.getPos = options.getPos\n\n    this.onResize = options.onResize\n    this.onCommit = options.onCommit\n    this.onUpdate = options.onUpdate\n\n    if (options.options?.min) {\n      this.minSize = {\n        ...this.minSize,\n        ...options.options.min,\n      }\n    }\n\n    if (options.options?.max) {\n      this.maxSize = options.options.max\n    }\n\n    if (options?.options?.directions) {\n      this.directions = options.options.directions\n    }\n\n    if (options.options?.preserveAspectRatio) {\n      this.preserveAspectRatio = options.options.preserveAspectRatio\n    }\n\n    if (options.options?.className) {\n      this.classNames = {\n        container: options.options.className.container || '',\n        wrapper: options.options.className.wrapper || '',\n        handle: options.options.className.handle || '',\n        resizing: options.options.className.resizing || '',\n      }\n    }\n\n    if (options.options?.createCustomHandle) {\n      this.createCustomHandle = options.options.createCustomHandle\n    }\n\n    this.wrapper = this.createWrapper()\n    this.container = this.createContainer()\n\n    this.applyInitialSize()\n    this.attachHandles()\n\n    this.editor.on('update', this.handleEditorUpdate.bind(this))\n  }\n\n  /**\n   * Returns the top-level DOM node that should be placed in the editor.\n   *\n   * This is required by the ProseMirror NodeView interface. The container\n   * includes the wrapper, handles, and the actual content element.\n   *\n   * @returns The container element to be inserted into the editor\n   */\n  get dom() {\n    return this.container\n  }\n\n  get contentDOM() {\n    return this.contentElement\n  }\n\n  private handleEditorUpdate() {\n    const isEditable = this.editor.isEditable\n\n    // Only if state actually changed\n    if (isEditable === this.lastEditableState) {\n      return\n    }\n\n    this.lastEditableState = isEditable\n\n    if (!isEditable) {\n      this.removeHandles()\n    } else if (isEditable && this.handleMap.size === 0) {\n      this.attachHandles()\n    }\n  }\n\n  /**\n   * Called when the node's content or attributes change.\n   *\n   * Updates the internal node reference. If a custom `onUpdate` callback\n   * was provided, it will be called to handle additional update logic.\n   *\n   * @param node - The new/updated node\n   * @param decorations - Node decorations\n   * @param innerDecorations - Inner decorations\n   * @returns `false` if the node type has changed (requires full rebuild), otherwise the result of `onUpdate` or `true`\n   */\n  update(node: PMNode, decorations: readonly Decoration[], innerDecorations: DecorationSource): boolean {\n    if (node.type !== this.node.type) {\n      return false\n    }\n\n    this.node = node\n\n    if (this.onUpdate) {\n      return this.onUpdate(node, decorations, innerDecorations)\n    }\n\n    return true\n  }\n\n  /**\n   * Cleanup method called when the node view is being removed.\n   *\n   * Removes all event listeners to prevent memory leaks. This is required\n   * by the ProseMirror NodeView interface. If a resize is active when\n   * destroy is called, it will be properly cancelled.\n   */\n  destroy() {\n    if (this.isResizing) {\n      this.container.dataset.resizeState = 'false'\n\n      if (this.classNames.resizing) {\n        this.container.classList.remove(this.classNames.resizing)\n      }\n\n      document.removeEventListener('mousemove', this.handleMouseMove)\n      document.removeEventListener('mouseup', this.handleMouseUp)\n      document.removeEventListener('keydown', this.handleKeyDown)\n      document.removeEventListener('keyup', this.handleKeyUp)\n      this.isResizing = false\n      this.activeHandle = null\n    }\n\n    this.editor.off('update', this.handleEditorUpdate.bind(this))\n\n    this.container.remove()\n  }\n\n  /**\n   * Creates the outer container element.\n   *\n   * The container is the top-level element returned by the NodeView and\n   * wraps the entire resizable node. It's set up with flexbox to handle\n   * alignment and includes data attributes for styling and identification.\n   *\n   * @returns The container element\n   */\n  createContainer() {\n    const element = document.createElement('div')\n    element.dataset.resizeContainer = ''\n    element.dataset.node = this.node.type.name\n    element.style.display = 'flex'\n\n    if (this.classNames.container) {\n      element.className = this.classNames.container\n    }\n\n    element.appendChild(this.wrapper)\n\n    return element\n  }\n\n  /**\n   * Creates the wrapper element that contains the content and handles.\n   *\n   * The wrapper uses relative positioning so that resize handles can be\n   * positioned absolutely within it. This is the direct parent of the\n   * content element being made resizable.\n   *\n   * @returns The wrapper element\n   */\n  createWrapper() {\n    const element = document.createElement('div')\n    element.style.position = 'relative'\n    element.style.display = 'block'\n    element.dataset.resizeWrapper = ''\n\n    if (this.classNames.wrapper) {\n      element.className = this.classNames.wrapper\n    }\n\n    element.appendChild(this.element)\n\n    return element\n  }\n\n  /**\n   * Creates a resize handle element for a specific direction.\n   *\n   * Each handle is absolutely positioned and includes a data attribute\n   * identifying its direction for styling purposes.\n   *\n   * @param direction - The resize direction for this handle\n   * @returns The handle element\n   */\n  private createHandle(direction: ResizableNodeViewDirection): HTMLElement {\n    const handle = document.createElement('div')\n    handle.dataset.resizeHandle = direction\n    handle.style.position = 'absolute'\n\n    if (this.classNames.handle) {\n      handle.className = this.classNames.handle\n    }\n\n    return handle\n  }\n\n  /**\n   * Positions a handle element according to its direction.\n   *\n   * Corner handles (e.g., 'top-left') are positioned at the intersection\n   * of two edges. Edge handles (e.g., 'top') span the full width or height.\n   *\n   * @param handle - The handle element to position\n   * @param direction - The direction determining the position\n   */\n  private positionHandle(handle: HTMLElement, direction: ResizableNodeViewDirection): void {\n    const isTop = direction.includes('top')\n    const isBottom = direction.includes('bottom')\n    const isLeft = direction.includes('left')\n    const isRight = direction.includes('right')\n\n    if (isTop) {\n      handle.style.top = '0'\n    }\n\n    if (isBottom) {\n      handle.style.bottom = '0'\n    }\n\n    if (isLeft) {\n      handle.style.left = '0'\n    }\n\n    if (isRight) {\n      handle.style.right = '0'\n    }\n\n    // Edge handles span the full width or height\n    if (direction === 'top' || direction === 'bottom') {\n      handle.style.left = '0'\n      handle.style.right = '0'\n    }\n\n    if (direction === 'left' || direction === 'right') {\n      handle.style.top = '0'\n      handle.style.bottom = '0'\n    }\n  }\n\n  /**\n   * Creates and attaches all resize handles to the wrapper.\n   *\n   * Iterates through the configured directions, creates a handle for each,\n   * positions it, attaches the mousedown listener, and appends it to the DOM.\n   */\n  private attachHandles(): void {\n    this.directions.forEach(direction => {\n      let handle: HTMLElement\n\n      if (this.createCustomHandle) {\n        handle = this.createCustomHandle(direction)\n      } else {\n        handle = this.createHandle(direction)\n      }\n\n      if (!(handle instanceof HTMLElement)) {\n        console.warn(\n          `[ResizableNodeView] createCustomHandle(\"${direction}\") did not return an HTMLElement. Falling back to default handle.`,\n        )\n        handle = this.createHandle(direction)\n      }\n\n      if (!this.createCustomHandle) {\n        this.positionHandle(handle, direction)\n      }\n\n      handle.addEventListener('mousedown', event => this.handleResizeStart(event, direction))\n      handle.addEventListener('touchstart', event => this.handleResizeStart(event as unknown as MouseEvent, direction))\n\n      this.handleMap.set(direction, handle)\n\n      this.wrapper.appendChild(handle)\n    })\n  }\n\n  /**\n   * Removes all resize handles from the wrapper.\n   *\n   * Cleans up the handle map and removes each handle element from the DOM.\n   */\n  private removeHandles(): void {\n    this.handleMap.forEach(el => el.remove())\n    this.handleMap.clear()\n  }\n\n  /**\n   * Applies initial sizing from node attributes to the element.\n   *\n   * If width/height attributes exist on the node, they're applied to the element.\n   * Otherwise, the element's natural/current dimensions are measured. The aspect\n   * ratio is calculated for later use in aspect-ratio-preserving resizes.\n   */\n  private applyInitialSize(): void {\n    const width = this.node.attrs.width as number | undefined\n    const height = this.node.attrs.height as number | undefined\n\n    if (width) {\n      this.element.style.width = `${width}px`\n      this.initialWidth = width\n    } else {\n      this.initialWidth = this.element.offsetWidth\n    }\n\n    if (height) {\n      this.element.style.height = `${height}px`\n      this.initialHeight = height\n    } else {\n      this.initialHeight = this.element.offsetHeight\n    }\n\n    // Calculate aspect ratio for use during resizing\n    if (this.initialWidth > 0 && this.initialHeight > 0) {\n      this.aspectRatio = this.initialWidth / this.initialHeight\n    }\n  }\n\n  /**\n   * Initiates a resize operation when a handle is clicked.\n   *\n   * Captures the starting mouse position and element dimensions, sets up\n   * the resize state, adds the resizing class and state attribute, and\n   * attaches document-level listeners for mouse movement and keyboard input.\n   *\n   * @param event - The mouse down event\n   * @param direction - The direction of the handle being dragged\n   */\n  private handleResizeStart(event: MouseEvent | TouchEvent, direction: ResizableNodeViewDirection): void {\n    event.preventDefault()\n    event.stopPropagation()\n\n    // Capture initial state\n    this.isResizing = true\n    this.activeHandle = direction\n\n    if (isTouchEvent(event)) {\n      this.startX = event.touches[0].clientX\n      this.startY = event.touches[0].clientY\n    } else {\n      this.startX = event.clientX\n      this.startY = event.clientY\n    }\n\n    this.startWidth = this.element.offsetWidth\n    this.startHeight = this.element.offsetHeight\n\n    // Recalculate aspect ratio at resize start for accuracy\n    if (this.startWidth > 0 && this.startHeight > 0) {\n      this.aspectRatio = this.startWidth / this.startHeight\n    }\n\n    const pos = this.getPos()\n    if (pos !== undefined) {\n      // TODO: Select the node in the editor\n    }\n\n    // Update UI state\n    this.container.dataset.resizeState = 'true'\n\n    if (this.classNames.resizing) {\n      this.container.classList.add(this.classNames.resizing)\n    }\n\n    // Attach document-level listeners for resize\n    document.addEventListener('mousemove', this.handleMouseMove)\n    document.addEventListener('touchmove', this.handleTouchMove)\n    document.addEventListener('mouseup', this.handleMouseUp)\n    document.addEventListener('keydown', this.handleKeyDown)\n    document.addEventListener('keyup', this.handleKeyUp)\n  }\n\n  /**\n   * Handles mouse movement during an active resize.\n   *\n   * Calculates the delta from the starting position, computes new dimensions\n   * based on the active handle direction, applies constraints and aspect ratio,\n   * then updates the element's style and calls the onResize callback.\n   *\n   * @param event - The mouse move event\n   */\n  private handleMouseMove = (event: MouseEvent): void => {\n    if (!this.isResizing || !this.activeHandle) {\n      return\n    }\n\n    const deltaX = event.clientX - this.startX\n    const deltaY = event.clientY - this.startY\n\n    this.handleResize(deltaX, deltaY)\n  }\n\n  private handleTouchMove = (event: TouchEvent): void => {\n    if (!this.isResizing || !this.activeHandle) {\n      return\n    }\n\n    const touch = event.touches[0]\n    if (!touch) {\n      return\n    }\n\n    const deltaX = touch.clientX - this.startX\n    const deltaY = touch.clientY - this.startY\n\n    this.handleResize(deltaX, deltaY)\n  }\n\n  private handleResize(deltaX: number, deltaY: number) {\n    if (!this.activeHandle) {\n      return\n    }\n\n    const shouldPreserveAspectRatio = this.preserveAspectRatio || this.isShiftKeyPressed\n    const { width, height } = this.calculateNewDimensions(this.activeHandle, deltaX, deltaY)\n    const constrained = this.applyConstraints(width, height, shouldPreserveAspectRatio)\n\n    this.element.style.width = `${constrained.width}px`\n    this.element.style.height = `${constrained.height}px`\n\n    if (this.onResize) {\n      this.onResize(constrained.width, constrained.height)\n    }\n  }\n\n  /**\n   * Completes the resize operation when the mouse button is released.\n   *\n   * Captures final dimensions, calls the onCommit callback to persist changes,\n   * removes the resizing state and class, and cleans up document-level listeners.\n   */\n  private handleMouseUp = (): void => {\n    if (!this.isResizing) {\n      return\n    }\n\n    const finalWidth = this.element.offsetWidth\n    const finalHeight = this.element.offsetHeight\n\n    this.onCommit(finalWidth, finalHeight)\n\n    this.isResizing = false\n    this.activeHandle = null\n\n    // Remove UI state\n    this.container.dataset.resizeState = 'false'\n\n    if (this.classNames.resizing) {\n      this.container.classList.remove(this.classNames.resizing)\n    }\n\n    // Clean up document-level listeners\n    document.removeEventListener('mousemove', this.handleMouseMove)\n    document.removeEventListener('mouseup', this.handleMouseUp)\n    document.removeEventListener('keydown', this.handleKeyDown)\n    document.removeEventListener('keyup', this.handleKeyUp)\n  }\n\n  /**\n   * Tracks Shift key state to enable temporary aspect ratio locking.\n   *\n   * When Shift is pressed during resize, aspect ratio is preserved even if\n   * preserveAspectRatio is false.\n   *\n   * @param event - The keyboard event\n   */\n  private handleKeyDown = (event: KeyboardEvent): void => {\n    if (event.key === 'Shift') {\n      this.isShiftKeyPressed = true\n    }\n  }\n\n  /**\n   * Tracks Shift key release to disable temporary aspect ratio locking.\n   *\n   * @param event - The keyboard event\n   */\n  private handleKeyUp = (event: KeyboardEvent): void => {\n    if (event.key === 'Shift') {\n      this.isShiftKeyPressed = false\n    }\n  }\n\n  /**\n   * Calculates new dimensions based on mouse delta and resize direction.\n   *\n   * Takes the starting dimensions and applies the mouse movement delta\n   * according to the handle direction. For corner handles, both dimensions\n   * are affected. For edge handles, only one dimension changes. If aspect\n   * ratio should be preserved, delegates to applyAspectRatio.\n   *\n   * @param direction - The active resize handle direction\n   * @param deltaX - Horizontal mouse movement since resize start\n   * @param deltaY - Vertical mouse movement since resize start\n   * @returns The calculated width and height\n   */\n  private calculateNewDimensions(\n    direction: ResizableNodeViewDirection,\n    deltaX: number,\n    deltaY: number,\n  ): ResizableNodeDimensions {\n    let newWidth = this.startWidth\n    let newHeight = this.startHeight\n\n    const isRight = direction.includes('right')\n    const isLeft = direction.includes('left')\n    const isBottom = direction.includes('bottom')\n    const isTop = direction.includes('top')\n\n    // Apply horizontal delta\n    if (isRight) {\n      newWidth = this.startWidth + deltaX\n    } else if (isLeft) {\n      newWidth = this.startWidth - deltaX\n    }\n\n    // Apply vertical delta\n    if (isBottom) {\n      newHeight = this.startHeight + deltaY\n    } else if (isTop) {\n      newHeight = this.startHeight - deltaY\n    }\n\n    // For pure horizontal/vertical handles, only one dimension changes\n    if (direction === 'right' || direction === 'left') {\n      newWidth = this.startWidth + (isRight ? deltaX : -deltaX)\n    }\n\n    if (direction === 'top' || direction === 'bottom') {\n      newHeight = this.startHeight + (isBottom ? deltaY : -deltaY)\n    }\n\n    const shouldPreserveAspectRatio = this.preserveAspectRatio || this.isShiftKeyPressed\n\n    if (shouldPreserveAspectRatio) {\n      return this.applyAspectRatio(newWidth, newHeight, direction)\n    }\n\n    return { width: newWidth, height: newHeight }\n  }\n\n  /**\n   * Applies min/max constraints to dimensions.\n   *\n   * When aspect ratio is NOT preserved, constraints are applied independently\n   * to width and height. When aspect ratio IS preserved, constraints are\n   * applied while maintaining the aspect ratioâ€”if one dimension hits a limit,\n   * the other is recalculated proportionally.\n   *\n   * This ensures that aspect ratio is never broken when constrained.\n   *\n   * @param width - The unconstrained width\n   * @param height - The unconstrained height\n   * @param preserveAspectRatio - Whether to maintain aspect ratio while constraining\n   * @returns The constrained dimensions\n   */\n  private applyConstraints(width: number, height: number, preserveAspectRatio: boolean): ResizableNodeDimensions {\n    if (!preserveAspectRatio) {\n      // Independent constraints for each dimension\n      let constrainedWidth = Math.max(this.minSize.width, width)\n      let constrainedHeight = Math.max(this.minSize.height, height)\n\n      if (this.maxSize?.width) {\n        constrainedWidth = Math.min(this.maxSize.width, constrainedWidth)\n      }\n\n      if (this.maxSize?.height) {\n        constrainedHeight = Math.min(this.maxSize.height, constrainedHeight)\n      }\n\n      return { width: constrainedWidth, height: constrainedHeight }\n    }\n\n    // Aspect-ratio-aware constraints: adjust both dimensions proportionally\n    let constrainedWidth = width\n    let constrainedHeight = height\n\n    // Check minimum constraints\n    if (constrainedWidth < this.minSize.width) {\n      constrainedWidth = this.minSize.width\n      constrainedHeight = constrainedWidth / this.aspectRatio\n    }\n\n    if (constrainedHeight < this.minSize.height) {\n      constrainedHeight = this.minSize.height\n      constrainedWidth = constrainedHeight * this.aspectRatio\n    }\n\n    // Check maximum constraints\n    if (this.maxSize?.width && constrainedWidth > this.maxSize.width) {\n      constrainedWidth = this.maxSize.width\n      constrainedHeight = constrainedWidth / this.aspectRatio\n    }\n\n    if (this.maxSize?.height && constrainedHeight > this.maxSize.height) {\n      constrainedHeight = this.maxSize.height\n      constrainedWidth = constrainedHeight * this.aspectRatio\n    }\n\n    return { width: constrainedWidth, height: constrainedHeight }\n  }\n\n  /**\n   * Adjusts dimensions to maintain the original aspect ratio.\n   *\n   * For horizontal handles (left/right), uses width as the primary dimension\n   * and calculates height from it. For vertical handles (top/bottom), uses\n   * height as primary and calculates width. For corner handles, uses width\n   * as the primary dimension.\n   *\n   * @param width - The new width\n   * @param height - The new height\n   * @param direction - The active resize direction\n   * @returns Dimensions adjusted to preserve aspect ratio\n   */\n  private applyAspectRatio(\n    width: number,\n    height: number,\n    direction: ResizableNodeViewDirection,\n  ): ResizableNodeDimensions {\n    const isHorizontal = direction === 'left' || direction === 'right'\n    const isVertical = direction === 'top' || direction === 'bottom'\n\n    if (isHorizontal) {\n      // For horizontal resize, width is primary\n      return {\n        width,\n        height: width / this.aspectRatio,\n      }\n    }\n\n    if (isVertical) {\n      // For vertical resize, height is primary\n      return {\n        width: height * this.aspectRatio,\n        height,\n      }\n    }\n\n    // For corner resize, width is primary\n    return {\n      width,\n      height: width / this.aspectRatio,\n    }\n  }\n}\n\n/**\n * Alias for ResizableNodeView to maintain consistent naming.\n * @deprecated Use ResizableNodeView instead - will be removed in future versions.\n */\nexport const ResizableNodeview = ResizableNodeView\n","import type { NodeType } from '@tiptap/pm/model'\nimport { type EditorState, NodeSelection } from '@tiptap/pm/state'\n\nexport function canInsertNode(state: EditorState, nodeType: NodeType): boolean {\n  const { selection } = state\n  const { $from } = selection\n\n  // Special handling for NodeSelection\n  if (selection instanceof NodeSelection) {\n    const index = $from.index()\n    const parent = $from.parent\n\n    // Can we replace the selected node with the horizontal rule?\n    return parent.canReplaceWith(index, index + 1, nodeType)\n  }\n\n  // Default: check if we can insert at the current position\n  let depth = $from.depth\n\n  while (depth >= 0) {\n    const index = $from.index(depth)\n    const parent = $from.node(depth)\n    const match = parent.contentMatchAt(index)\n    if (match.matchType(nodeType)) {\n      return true\n    }\n    depth -= 1\n  }\n  return false\n}\n","// source: https://stackoverflow.com/a/6969486\nexport function escapeForRegEx(string: string): string {\n  return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n}\n","export function isString(value: any): value is string {\n  return typeof value === 'string'\n}\n","/**\n * @fileoverview Markdown utilities for creating standardized markdown specs.\n *\n * This module provides utilities for creating complete markdown specifications\n * for different types of nodes using unified syntax patterns.\n */\n\nexport * from './attributeUtils.js'\nexport * from './createAtomBlockMarkdownSpec.js'\nexport * from './createBlockMarkdownSpec.js'\nexport * from './createInlineMarkdownSpec.js'\nexport * from './parseIndentedBlocks.js'\nexport * from './renderNestedMarkdownContent.js'\n","/**\n * @fileoverview Utility functions for parsing and serializing markdown attributes.\n *\n * These utilities handle the common patterns for parsing attribute strings\n * in various markdown syntaxes like Pandoc attributes.\n */\n\n/**\n * Parses a Pandoc-style attribute string into an object.\n *\n * Supports the following patterns:\n * - Classes: `.className` â†’ `{ class: 'className' }`\n * - IDs: `#myId` â†’ `{ id: 'myId' }`\n * - Key-value pairs: `key=\"value\"` â†’ `{ key: 'value' }`\n * - Boolean attributes: `disabled` â†’ `{ disabled: true }`\n *\n * @param attrString - The attribute string to parse\n * @returns Parsed attributes object\n *\n * @example\n * ```ts\n * parseAttributes('.btn #submit disabled type=\"button\"')\n * // â†’ { class: 'btn', id: 'submit', disabled: true, type: 'button' }\n * ```\n */\nexport function parseAttributes(attrString: string): Record<string, any> {\n  if (!attrString?.trim()) {\n    return {}\n  }\n\n  const attributes: Record<string, any> = {}\n\n  // First, extract and remove quoted strings to avoid parsing content inside them\n  const quotedStrings: string[] = []\n  const tempString = attrString.replace(/[\"']([^\"']*)[\"']/g, match => {\n    quotedStrings.push(match)\n    return `__QUOTED_${quotedStrings.length - 1}__`\n  })\n\n  // Parse classes (.className) - only outside of quoted strings\n  const classMatches = tempString.match(/(?:^|\\s)\\.([a-zA-Z][\\w-]*)/g)\n  if (classMatches) {\n    const classes = classMatches.map(match => match.trim().slice(1)) // Remove the dot\n    attributes.class = classes.join(' ')\n  }\n\n  // Parse IDs (#myId) - only outside of quoted strings\n  const idMatch = tempString.match(/(?:^|\\s)#([a-zA-Z][\\w-]*)/)\n  if (idMatch) {\n    attributes.id = idMatch[1]\n  }\n\n  // Parse key-value pairs (key=\"value\" or key='value') - restore quoted strings\n  const kvRegex = /([a-zA-Z][\\w-]*)\\s*=\\s*(__QUOTED_\\d+__)/g\n  const kvMatches = Array.from(tempString.matchAll(kvRegex))\n  kvMatches.forEach(([, key, quotedRef]) => {\n    const quotedIndex = parseInt(quotedRef.match(/__QUOTED_(\\d+)__/)?.[1] || '0', 10)\n    const quotedValue = quotedStrings[quotedIndex]\n    if (quotedValue) {\n      // Remove the outer quotes\n      attributes[key] = quotedValue.slice(1, -1)\n    }\n  })\n\n  // Parse boolean attributes (standalone words that aren't classes/IDs)\n  const cleanString = tempString\n    .replace(/(?:^|\\s)\\.([a-zA-Z][\\w-]*)/g, '') // Remove classes\n    .replace(/(?:^|\\s)#([a-zA-Z][\\w-]*)/g, '') // Remove IDs\n    .replace(/([a-zA-Z][\\w-]*)\\s*=\\s*__QUOTED_\\d+__/g, '') // Remove key-value pairs\n    .trim()\n\n  if (cleanString) {\n    const booleanAttrs = cleanString.split(/\\s+/).filter(Boolean)\n    booleanAttrs.forEach(attr => {\n      if (attr.match(/^[a-zA-Z][\\w-]*$/)) {\n        attributes[attr] = true\n      }\n    })\n  }\n\n  return attributes\n}\n\n/**\n * Serializes an attributes object back to a Pandoc-style attribute string.\n *\n * @param attributes - The attributes object to serialize\n * @returns Serialized attribute string\n *\n * @example\n * ```ts\n * serializeAttributes({ class: 'btn primary', id: 'submit', disabled: true, type: 'button' })\n * // â†’ '.btn.primary #submit disabled type=\"button\"'\n * ```\n */\nexport function serializeAttributes(attributes: Record<string, any>): string {\n  if (!attributes || Object.keys(attributes).length === 0) {\n    return ''\n  }\n\n  const parts: string[] = []\n\n  // Handle classes\n  if (attributes.class) {\n    const classes = String(attributes.class).split(/\\s+/).filter(Boolean)\n    classes.forEach(cls => parts.push(`.${cls}`))\n  }\n\n  // Handle ID\n  if (attributes.id) {\n    parts.push(`#${attributes.id}`)\n  }\n\n  // Handle other attributes\n  Object.entries(attributes).forEach(([key, value]) => {\n    if (key === 'class' || key === 'id') {\n      return // Already handled\n    }\n\n    if (value === true) {\n      // Boolean attribute\n      parts.push(key)\n    } else if (value !== false && value != null) {\n      // Key-value attribute\n      parts.push(`${key}=\"${String(value)}\"`)\n    }\n  })\n\n  return parts.join(' ')\n}\n","import type {\n  JSONContent,\n  MarkdownParseHelpers,\n  MarkdownParseResult,\n  MarkdownToken,\n  MarkdownTokenizer,\n} from '../../types.js'\nimport {\n  parseAttributes as defaultParseAttributes,\n  serializeAttributes as defaultSerializeAttributes,\n} from './attributeUtils.js'\n\nexport interface AtomBlockMarkdownSpecOptions {\n  /** The Tiptap node name this spec is for */\n  nodeName: string\n  /** The markdown syntax name (defaults to nodeName if not provided) */\n  name?: string\n  /** Function to parse attributes from token attribute string */\n  parseAttributes?: (attrString: string) => Record<string, any>\n  /** Function to serialize attributes back to string for rendering */\n  serializeAttributes?: (attrs: Record<string, any>) => string\n  /** Default attributes to apply when parsing */\n  defaultAttributes?: Record<string, any>\n  /** Required attributes that must be present for successful parsing */\n  requiredAttributes?: string[]\n  /** Attributes that are allowed to be rendered back to markdown (whitelist) */\n  allowedAttributes?: string[]\n}\n\n/**\n * Creates a complete markdown spec for atomic block nodes using Pandoc syntax.\n *\n * The generated spec handles:\n * - Parsing self-closing blocks with `:::blockName {attributes}`\n * - Extracting and parsing attributes\n * - Validating required attributes\n * - Rendering blocks back to markdown\n *\n * @param options - Configuration for the atomic block markdown spec\n * @returns Complete markdown specification object\n *\n * @example\n * ```ts\n * const youtubeSpec = createAtomBlockMarkdownSpec({\n *   nodeName: 'youtube',\n *   requiredAttributes: ['src'],\n *   defaultAttributes: { start: 0 },\n *   allowedAttributes: ['src', 'start', 'width', 'height'] // Only these get rendered to markdown\n * })\n *\n * // Usage in extension:\n * export const Youtube = Node.create({\n *   // ... other config\n *   markdown: youtubeSpec\n * })\n * ```\n */\nexport function createAtomBlockMarkdownSpec(options: AtomBlockMarkdownSpecOptions): {\n  parseMarkdown: (token: MarkdownToken, h: MarkdownParseHelpers) => MarkdownParseResult\n  markdownTokenizer: MarkdownTokenizer\n  renderMarkdown: (node: JSONContent) => string\n} {\n  const {\n    nodeName,\n    name: markdownName,\n    parseAttributes = defaultParseAttributes,\n    serializeAttributes = defaultSerializeAttributes,\n    defaultAttributes = {},\n    requiredAttributes = [],\n    allowedAttributes,\n  } = options\n\n  // Use markdownName for syntax, fallback to nodeName\n  const blockName = markdownName || nodeName\n\n  // Helper function to filter attributes based on allowlist\n  const filterAttributes = (attrs: Record<string, any>) => {\n    if (!allowedAttributes) {\n      return attrs\n    }\n\n    const filtered: Record<string, any> = {}\n    allowedAttributes.forEach(key => {\n      if (key in attrs) {\n        filtered[key] = attrs[key]\n      }\n    })\n    return filtered\n  }\n\n  return {\n    parseMarkdown: (token: MarkdownToken, h: MarkdownParseHelpers) => {\n      const attrs = { ...defaultAttributes, ...token.attributes }\n      return h.createNode(nodeName, attrs, [])\n    },\n\n    markdownTokenizer: {\n      name: nodeName,\n      level: 'block' as const,\n      start(src: string) {\n        const regex = new RegExp(`^:::${blockName}(?:\\\\s|$)`, 'm')\n        const index = src.match(regex)?.index\n        return index !== undefined ? index : -1\n      },\n      tokenize(src, _tokens, _lexer) {\n        // Use non-global regex to match from the start of the string\n        // Include optional newline to ensure we consume the entire line\n        const regex = new RegExp(`^:::${blockName}(?:\\\\s+\\\\{([^}]*)\\\\})?\\\\s*:::(?:\\\\n|$)`)\n        const match = src.match(regex)\n\n        if (!match) {\n          return undefined\n        }\n\n        // Parse attributes if present\n        const attrString = match[1] || ''\n        const attributes = parseAttributes(attrString)\n\n        // Validate required attributes\n        const missingRequired = requiredAttributes.find(required => !(required in attributes))\n        if (missingRequired) {\n          return undefined\n        }\n\n        return {\n          type: nodeName,\n          raw: match[0],\n          attributes,\n        }\n      },\n    },\n\n    renderMarkdown: node => {\n      const filteredAttrs = filterAttributes(node.attrs || {})\n      const attrs = serializeAttributes(filteredAttrs)\n      const attrString = attrs ? ` {${attrs}}` : ''\n\n      return `:::${blockName}${attrString} :::`\n    },\n  }\n}\n","import type {\n  JSONContent,\n  MarkdownParseHelpers,\n  MarkdownParseResult,\n  MarkdownRendererHelpers,\n  MarkdownToken,\n  MarkdownTokenizer,\n} from '../../types.js'\nimport {\n  parseAttributes as defaultParseAttributes,\n  serializeAttributes as defaultSerializeAttributes,\n} from './attributeUtils.js'\n\nexport interface BlockMarkdownSpecOptions {\n  /** The Tiptap node name this spec is for */\n  nodeName: string\n  /** The markdown syntax name (defaults to nodeName if not provided) */\n  name?: string\n  /** Function to extract content from the node for serialization */\n  getContent?: (token: MarkdownToken) => string\n  /** Function to parse attributes from the attribute string */\n  parseAttributes?: (attrString: string) => Record<string, any>\n  /** Function to serialize attributes to string */\n  serializeAttributes?: (attrs: Record<string, any>) => string\n  /** Default attributes to apply when parsing */\n  defaultAttributes?: Record<string, any>\n  /** Content type: 'block' allows paragraphs/lists/etc, 'inline' only allows bold/italic/links/etc */\n  content?: 'block' | 'inline'\n  /** Allowlist of attributes to include in markdown (if not provided, all attributes are included) */\n  allowedAttributes?: string[]\n}\n\n/**\n * Creates a complete markdown spec for block-level nodes using Pandoc syntax.\n *\n * The generated spec handles:\n * - Parsing blocks with `:::blockName {attributes}` syntax\n * - Extracting and parsing attributes\n * - Rendering blocks back to markdown with proper formatting\n * - Nested content support\n *\n * @param options - Configuration for the block markdown spec\n * @returns Complete markdown specification object\n *\n * @example\n * ```ts\n * const calloutSpec = createBlockMarkdownSpec({\n *   nodeName: 'callout',\n *   defaultAttributes: { type: 'info' },\n *   allowedAttributes: ['type', 'title'] // Only these get rendered to markdown\n * })\n *\n * // Usage in extension:\n * export const Callout = Node.create({\n *   // ... other config\n *   markdown: calloutSpec\n * })\n * ```\n */\nexport function createBlockMarkdownSpec(options: BlockMarkdownSpecOptions): {\n  parseMarkdown: (token: MarkdownToken, h: MarkdownParseHelpers) => MarkdownParseResult\n  markdownTokenizer: MarkdownTokenizer\n  renderMarkdown: (node: JSONContent, h: MarkdownRendererHelpers) => string\n} {\n  const {\n    nodeName,\n    name: markdownName,\n    getContent,\n    parseAttributes = defaultParseAttributes,\n    serializeAttributes = defaultSerializeAttributes,\n    defaultAttributes = {},\n    content = 'block',\n    allowedAttributes,\n  } = options\n\n  // Use markdownName for syntax, fallback to nodeName\n  const blockName = markdownName || nodeName\n\n  // Helper function to filter attributes based on allowlist\n  const filterAttributes = (attrs: Record<string, any>) => {\n    if (!allowedAttributes) {\n      return attrs\n    }\n\n    const filtered: Record<string, any> = {}\n    allowedAttributes.forEach(key => {\n      if (key in attrs) {\n        filtered[key] = attrs[key]\n      }\n    })\n    return filtered\n  }\n\n  return {\n    parseMarkdown: (token, h) => {\n      let nodeContent: JSONContent[]\n\n      if (getContent) {\n        const contentResult = getContent(token)\n        // If getContent returns a string, wrap it in a text node\n        nodeContent = typeof contentResult === 'string' ? [{ type: 'text', text: contentResult }] : contentResult\n      } else if (content === 'block') {\n        nodeContent = h.parseChildren(token.tokens || [])\n      } else {\n        nodeContent = h.parseInline(token.tokens || [])\n      }\n\n      const attrs = { ...defaultAttributes, ...token.attributes }\n\n      return h.createNode(nodeName, attrs, nodeContent)\n    },\n\n    markdownTokenizer: {\n      name: nodeName,\n      level: 'block' as const,\n      start(src) {\n        const regex = new RegExp(`^:::${blockName}`, 'm')\n        const index = src.match(regex)?.index\n        return index !== undefined ? index : -1\n      },\n      tokenize(src, _tokens, lexer) {\n        // Match the opening tag with optional attributes\n        const openingRegex = new RegExp(`^:::${blockName}(?:\\\\s+\\\\{([^}]*)\\\\})?\\\\s*\\\\n`)\n        const openingMatch = src.match(openingRegex)\n\n        if (!openingMatch) {\n          return undefined\n        }\n\n        const [openingTag, attrString = ''] = openingMatch\n        const attributes = parseAttributes(attrString)\n\n        // Find the matching closing tag by tracking nesting level\n        let level = 1\n        const position = openingTag.length\n        let matchedContent = ''\n\n        // Pattern to match any block opening (:::word) or closing (:::)\n        const blockPattern = /^:::([\\w-]*)(\\s.*)?/gm\n        const remaining = src.slice(position)\n\n        blockPattern.lastIndex = 0\n\n        // run until no more matches are found\n        for (;;) {\n          const match = blockPattern.exec(remaining)\n          if (match === null) {\n            break\n          }\n          const matchPos = match.index\n          const blockType = match[1] // Empty string for closing tag, block name for opening\n\n          if (match[2]?.endsWith(':::')) {\n            // this is an atom ::: node, we skip it\n            continue\n          }\n\n          if (blockType) {\n            // Opening tag found - increase level\n            level += 1\n          } else {\n            // Closing tag found - decrease level\n            level -= 1\n\n            if (level === 0) {\n              // Found our matching closing tag\n              // Don't trim yet - keep newlines for tokenizer regex matching\n              const rawContent = remaining.slice(0, matchPos)\n              matchedContent = rawContent.trim()\n              const fullMatch = src.slice(0, position + matchPos + match[0].length)\n\n              // Tokenize the content\n              let contentTokens: MarkdownToken[] = []\n              if (matchedContent) {\n                if (content === 'block') {\n                  // Use rawContent for tokenization to preserve line boundaries for regex matching\n                  contentTokens = lexer.blockTokens(rawContent)\n\n                  // Parse inline tokens for any token that has text content but no tokens\n                  contentTokens.forEach(token => {\n                    if (token.text && (!token.tokens || token.tokens.length === 0)) {\n                      token.tokens = lexer.inlineTokens(token.text)\n                    }\n                  })\n\n                  // Clean up empty trailing paragraphs\n                  while (contentTokens.length > 0) {\n                    const lastToken = contentTokens[contentTokens.length - 1]\n                    if (lastToken.type === 'paragraph' && (!lastToken.text || lastToken.text.trim() === '')) {\n                      contentTokens.pop()\n                    } else {\n                      break\n                    }\n                  }\n                } else {\n                  contentTokens = lexer.inlineTokens(matchedContent)\n                }\n              }\n\n              return {\n                type: nodeName,\n                raw: fullMatch,\n                attributes,\n                content: matchedContent,\n                tokens: contentTokens,\n              }\n            }\n          }\n        }\n\n        // No matching closing tag found\n        return undefined\n      },\n    },\n\n    renderMarkdown: (node, h) => {\n      const filteredAttrs = filterAttributes(node.attrs || {})\n      const attrs = serializeAttributes(filteredAttrs)\n      const attrString = attrs ? ` {${attrs}}` : ''\n      const renderedContent = h.renderChildren(node.content || [], '\\n\\n')\n\n      return `:::${blockName}${attrString}\\n\\n${renderedContent}\\n\\n:::`\n    },\n  }\n}\n","import type {\n  JSONContent,\n  MarkdownParseHelpers,\n  MarkdownParseResult,\n  MarkdownToken,\n  MarkdownTokenizer,\n} from '../../types.js'\n\n/**\n * Parse shortcode attributes like 'id=\"madonna\" handle=\"john\" name=\"John Doe\"'\n * Requires all values to be quoted with either single or double quotes\n */\nfunction parseShortcodeAttributes(attrString: string): Record<string, any> {\n  if (!attrString.trim()) {\n    return {}\n  }\n\n  const attributes: Record<string, any> = {}\n  // Match key=value pairs, only accepting quoted values\n  const regex = /(\\w+)=(?:\"([^\"]*)\"|'([^']*)')/g\n  let match = regex.exec(attrString)\n\n  while (match !== null) {\n    const [, key, doubleQuoted, singleQuoted] = match\n    attributes[key] = doubleQuoted || singleQuoted\n    match = regex.exec(attrString)\n  }\n\n  return attributes\n}\n\n/**\n * Serialize attributes back to shortcode format\n * Always quotes all values with double quotes\n */\nfunction serializeShortcodeAttributes(attrs: Record<string, any>): string {\n  return Object.entries(attrs)\n    .filter(([, value]) => value !== undefined && value !== null)\n    .map(([key, value]) => `${key}=\"${value}\"`)\n    .join(' ')\n}\n\n/**\n * Configuration for an allowed attribute in markdown serialization.\n * Can be a simple string (attribute name) or an object with additional options.\n */\nexport type AllowedAttribute =\n  | string\n  | {\n      /** The attribute name */\n      name: string\n      /**\n       * If provided, the attribute will be skipped during serialization when its value\n       * equals this default value. This keeps markdown output clean by omitting\n       * attributes that have their default values.\n       */\n      skipIfDefault?: any\n    }\n\nexport interface InlineMarkdownSpecOptions {\n  /** The Tiptap node name this spec is for */\n  nodeName: string\n  /** The shortcode name (defaults to nodeName if not provided) */\n  name?: string\n  /** Function to extract content from the node for serialization */\n  getContent?: (node: any) => string\n  /** Function to parse attributes from the attribute string */\n  parseAttributes?: (attrString: string) => Record<string, any>\n  /** Function to serialize attributes to string */\n  serializeAttributes?: (attrs: Record<string, any>) => string\n  /** Default attributes to apply when parsing */\n  defaultAttributes?: Record<string, any>\n  /** Whether this is a self-closing shortcode (no content, like [emoji name=party]) */\n  selfClosing?: boolean\n  /**\n   * Allowlist of attributes to include in markdown serialization.\n   * If not provided, all attributes are included.\n   *\n   * Each item can be either:\n   * - A string: the attribute name (always included if present)\n   * - An object: `{ name: string, skipIfDefault?: any }` for conditional inclusion\n   *\n   * @example\n   * // Simple string attributes (backward compatible)\n   * allowedAttributes: ['id', 'label']\n   *\n   * // Mixed with conditional attributes\n   * allowedAttributes: [\n   *   'id',\n   *   'label',\n   *   { name: 'mentionSuggestionChar', skipIfDefault: '@' }\n   * ]\n   */\n  allowedAttributes?: AllowedAttribute[]\n}\n\n/**\n * Creates a complete markdown spec for inline nodes using attribute syntax.\n *\n * The generated spec handles:\n * - Parsing shortcode syntax with `[nodeName attributes]content[/nodeName]` format\n * - Self-closing shortcodes like `[emoji name=party_popper]`\n * - Extracting and parsing attributes from the opening tag\n * - Rendering inline elements back to shortcode markdown\n * - Supporting both content-based and self-closing inline elements\n *\n * @param options - Configuration for the inline markdown spec\n * @returns Complete markdown specification object\n *\n * @example\n * ```ts\n * // Self-closing mention: [mention id=\"madonna\" label=\"Madonna\"]\n * const mentionSpec = createInlineMarkdownSpec({\n *   nodeName: 'mention',\n *   selfClosing: true,\n *   defaultAttributes: { type: 'user' },\n *   allowedAttributes: ['id', 'label'] // Only these get rendered to markdown\n * })\n *\n * // Self-closing emoji: [emoji name=\"party_popper\"]\n * const emojiSpec = createInlineMarkdownSpec({\n *   nodeName: 'emoji',\n *   selfClosing: true,\n *   allowedAttributes: ['name']\n * })\n *\n * // With content: [highlight color=\"yellow\"]text[/highlight]\n * const highlightSpec = createInlineMarkdownSpec({\n *   nodeName: 'highlight',\n *   selfClosing: false,\n *   allowedAttributes: ['color', 'style']\n * })\n *\n * // Usage in extension:\n * export const Mention = Node.create({\n *   name: 'mention', // Must match nodeName\n *   // ... other config\n *   markdown: mentionSpec\n * })\n * ```\n */\nexport function createInlineMarkdownSpec(options: InlineMarkdownSpecOptions): {\n  parseMarkdown: (token: MarkdownToken, h: MarkdownParseHelpers) => MarkdownParseResult\n  markdownTokenizer: MarkdownTokenizer\n  renderMarkdown: (node: JSONContent) => string\n} {\n  const {\n    nodeName,\n    name: shortcodeName,\n    getContent,\n    parseAttributes = parseShortcodeAttributes,\n    serializeAttributes = serializeShortcodeAttributes,\n    defaultAttributes = {},\n    selfClosing = false,\n    allowedAttributes,\n  } = options\n\n  // Use shortcodeName for markdown syntax, fallback to nodeName\n  const shortcode = shortcodeName || nodeName\n\n  // Helper function to filter attributes based on allowlist\n  const filterAttributes = (attrs: Record<string, any>) => {\n    if (!allowedAttributes) {\n      return attrs\n    }\n\n    const filtered: Record<string, any> = {}\n    allowedAttributes.forEach(attr => {\n      // Handle both string and object formats for backward compatibility\n      const attrName = typeof attr === 'string' ? attr : attr.name\n      const skipIfDefault = typeof attr === 'string' ? undefined : attr.skipIfDefault\n\n      if (attrName in attrs) {\n        const value = attrs[attrName]\n\n        // Skip if value equals the default (when skipIfDefault is specified)\n        if (skipIfDefault !== undefined && value === skipIfDefault) {\n          return\n        }\n\n        filtered[attrName] = value\n      }\n    })\n    return filtered\n  }\n\n  // Escape special regex characters in shortcode name\n  const escapedShortcode = shortcode.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n\n  return {\n    parseMarkdown: (token: MarkdownToken, h: MarkdownParseHelpers) => {\n      const attrs = { ...defaultAttributes, ...token.attributes }\n\n      if (selfClosing) {\n        // Self-closing nodes like mentions are atomic - no content\n        return h.createNode(nodeName, attrs)\n      }\n\n      // Nodes with content\n      const content = getContent ? getContent(token) : token.content || ''\n      if (content) {\n        // For inline content, create text nodes using the proper helper\n        return h.createNode(nodeName, attrs, [h.createTextNode(content)])\n      }\n      return h.createNode(nodeName, attrs, [])\n    },\n\n    markdownTokenizer: {\n      name: nodeName,\n      level: 'inline' as const,\n      start(src: string) {\n        // Create a non-global version for finding the start position\n        const startPattern = selfClosing\n          ? new RegExp(`\\\\[${escapedShortcode}\\\\s*[^\\\\]]*\\\\]`)\n          : new RegExp(`\\\\[${escapedShortcode}\\\\s*[^\\\\]]*\\\\][\\\\s\\\\S]*?\\\\[\\\\/${escapedShortcode}\\\\]`)\n\n        const match = src.match(startPattern)\n        const index = match?.index\n        return index !== undefined ? index : -1\n      },\n      tokenize(src, _tokens, _lexer) {\n        // Use non-global regex to match from the start of the string\n        const tokenPattern = selfClosing\n          ? new RegExp(`^\\\\[${escapedShortcode}\\\\s*([^\\\\]]*)\\\\]`)\n          : new RegExp(`^\\\\[${escapedShortcode}\\\\s*([^\\\\]]*)\\\\]([\\\\s\\\\S]*?)\\\\[\\\\/${escapedShortcode}\\\\]`)\n\n        const match = src.match(tokenPattern)\n\n        if (!match) {\n          return undefined\n        }\n\n        let content = ''\n        let attrString = ''\n\n        if (selfClosing) {\n          // Self-closing: [shortcode attr=\"value\"]\n          const [, attrs] = match\n          attrString = attrs\n        } else {\n          // With content: [shortcode attr=\"value\"]content[/shortcode]\n          const [, attrs, contentMatch] = match\n          attrString = attrs\n          content = contentMatch || ''\n        }\n\n        // Parse attributes from the attribute string\n        const attributes = parseAttributes(attrString.trim())\n\n        return {\n          type: nodeName,\n          raw: match[0],\n          content: content.trim(),\n          attributes,\n        }\n      },\n    },\n\n    renderMarkdown: (node: JSONContent) => {\n      let content = ''\n      if (getContent) {\n        content = getContent(node)\n      } else if (node.content && node.content.length > 0) {\n        // Extract text from content array for inline nodes\n        content = node.content\n          .filter((child: any) => child.type === 'text')\n          .map((child: any) => child.text)\n          .join('')\n      }\n\n      const filteredAttrs = filterAttributes(node.attrs || {})\n      const attrs = serializeAttributes(filteredAttrs)\n      const attrString = attrs ? ` ${attrs}` : ''\n\n      if (selfClosing) {\n        return `[${shortcode}${attrString}]`\n      }\n\n      return `[${shortcode}${attrString}]${content}[/${shortcode}]`\n    },\n  }\n}\n","/**\n * @fileoverview Utility for parsing indented markdown blocks with hierarchical nesting.\n *\n * This utility handles the complex logic of parsing markdown blocks that can contain\n * nested content based on indentation levels, maintaining proper hierarchical structure\n * for lists, task lists, and other indented block types.\n */\n\nexport interface ParsedBlock {\n  type: string\n  raw: string\n  mainContent: string\n  indentLevel: number\n  nestedContent?: string\n  nestedTokens?: any[]\n  [key: string]: any\n}\n\nexport interface BlockParserConfig {\n  /** Regex pattern to match block items */\n  itemPattern: RegExp\n  /** Function to extract data from regex match */\n  extractItemData: (match: RegExpMatchArray) => {\n    mainContent: string\n    indentLevel: number\n    [key: string]: any\n  }\n  /** Function to create the final token */\n  createToken: (data: any, nestedTokens?: any[]) => ParsedBlock\n  /** Base indentation to remove from nested content (default: 2 spaces) */\n  baseIndentSize?: number\n  /**\n   * Custom parser for nested content. If provided, this will be called instead\n   * of the default lexer.blockTokens() for parsing nested content.\n   * This allows recursive parsing of the same block type.\n   */\n  customNestedParser?: (dedentedContent: string) => any[] | undefined\n}\n\n/**\n * Parses markdown text into hierarchical indented blocks with proper nesting.\n *\n * This utility handles:\n * - Line-by-line parsing with pattern matching\n * - Hierarchical nesting based on indentation levels\n * - Nested content collection and parsing\n * - Empty line handling\n * - Content dedenting for nested blocks\n *\n * The key difference from flat parsing is that this maintains the hierarchical\n * structure where nested items become `nestedTokens` of their parent items,\n * rather than being flattened into a single array.\n *\n * @param src - The markdown source text to parse\n * @param config - Configuration object defining how to parse and create tokens\n * @param lexer - Markdown lexer for parsing nested content\n * @returns Parsed result with hierarchical items, or undefined if no matches\n *\n * @example\n * ```ts\n * const result = parseIndentedBlocks(src, {\n *   itemPattern: /^(\\s*)([-+*])\\s+\\[([ xX])\\]\\s+(.*)$/,\n *   extractItemData: (match) => ({\n *     indentLevel: match[1].length,\n *     mainContent: match[4],\n *     checked: match[3].toLowerCase() === 'x'\n *   }),\n *   createToken: (data, nestedTokens) => ({\n *     type: 'taskItem',\n *     checked: data.checked,\n *     text: data.mainContent,\n *     nestedTokens\n *   })\n * }, lexer)\n * ```\n */\nexport function parseIndentedBlocks(\n  src: string,\n  config: BlockParserConfig,\n  lexer: {\n    inlineTokens: (src: string) => any[]\n    blockTokens: (src: string) => any[]\n  },\n):\n  | {\n      items: ParsedBlock[]\n      raw: string\n    }\n  | undefined {\n  const lines = src.split('\\n')\n  const items: ParsedBlock[] = []\n  let totalRaw = ''\n  let i = 0\n  const baseIndentSize = config.baseIndentSize || 2\n\n  while (i < lines.length) {\n    const currentLine = lines[i]\n    const itemMatch = currentLine.match(config.itemPattern)\n\n    if (!itemMatch) {\n      // Not a matching item - stop if we have items, otherwise this isn't our block type\n      if (items.length > 0) {\n        break\n      } else if (currentLine.trim() === '') {\n        i += 1\n        totalRaw = `${totalRaw}${currentLine}\\n`\n        continue\n      } else {\n        return undefined\n      }\n    }\n\n    const itemData = config.extractItemData(itemMatch)\n    const { indentLevel, mainContent } = itemData\n    totalRaw = `${totalRaw}${currentLine}\\n`\n\n    // Collect content for this item (including nested items)\n    const itemContent = [mainContent] // Start with the main text\n    i += 1\n\n    // Look ahead for nested content (indented more than current item)\n    while (i < lines.length) {\n      const nextLine = lines[i]\n\n      if (nextLine.trim() === '') {\n        // Empty line - might be end of nested content\n        const nextNonEmptyIndex = lines.slice(i + 1).findIndex(l => l.trim() !== '')\n        if (nextNonEmptyIndex === -1) {\n          // No more content\n          break\n        }\n\n        const nextNonEmpty = lines[i + 1 + nextNonEmptyIndex]\n        const nextIndent = nextNonEmpty.match(/^(\\s*)/)?.[1]?.length || 0\n\n        if (nextIndent > indentLevel) {\n          // Nested content continues after empty line\n          itemContent.push(nextLine)\n          totalRaw = `${totalRaw}${nextLine}\\n`\n          i += 1\n          continue\n        } else {\n          // End of nested content\n          break\n        }\n      }\n\n      const nextIndent = nextLine.match(/^(\\s*)/)?.[1]?.length || 0\n\n      if (nextIndent > indentLevel) {\n        // This is nested content for the current item\n        itemContent.push(nextLine)\n        totalRaw = `${totalRaw}${nextLine}\\n`\n        i += 1\n      } else {\n        // Same or less indentation - this belongs to parent level\n        break\n      }\n    }\n\n    // Parse nested content if present\n    let nestedTokens: any[] | undefined\n    const nestedContent = itemContent.slice(1)\n\n    if (nestedContent.length > 0) {\n      // Remove the base indentation from nested content\n      const dedentedNested = nestedContent\n        .map(nestedLine => nestedLine.slice(indentLevel + baseIndentSize)) // Remove base indent + 2 spaces\n        .join('\\n')\n\n      if (dedentedNested.trim()) {\n        // Use custom nested parser if provided, otherwise fall back to default\n        if (config.customNestedParser) {\n          nestedTokens = config.customNestedParser(dedentedNested)\n        } else {\n          nestedTokens = lexer.blockTokens(dedentedNested)\n        }\n      }\n    }\n\n    // Create the token using the provided factory function\n    const token = config.createToken(itemData, nestedTokens)\n    items.push(token)\n  }\n\n  if (items.length === 0) {\n    return undefined\n  }\n\n  return {\n    items,\n    raw: totalRaw,\n  }\n}\n","import type { JSONContent } from '@tiptap/core'\n\n/**\n * @fileoverview Utility functions for rendering nested content in markdown.\n *\n * This module provides reusable utilities for extensions that need to render\n * content with a prefix on the main line and properly indented nested content.\n */\n\n/**\n * Utility function for rendering content with a main line prefix and nested indented content.\n *\n * This function handles the common pattern of rendering content with:\n * 1. A main line with a prefix (like \"- \" for lists, \"> \" for blockquotes, etc.)\n * 2. Nested content that gets indented properly\n *\n * @param node - The ProseMirror node representing the content\n * @param h - The markdown renderer helper\n * @param prefixOrGenerator - Either a string prefix or a function that generates the prefix from context\n * @param ctx - Optional context object (used when prefixOrGenerator is a function)\n * @returns The rendered markdown string\n *\n * @example\n * ```ts\n * // For a bullet list item with static prefix\n * return renderNestedMarkdownContent(node, h, '- ')\n *\n * // For a task item with static prefix\n * const prefix = `- [${node.attrs?.checked ? 'x' : ' '}] `\n * return renderNestedMarkdownContent(node, h, prefix)\n *\n * // For a blockquote with static prefix\n * return renderNestedMarkdownContent(node, h, '> ')\n *\n * // For content with dynamic prefix based on context\n * return renderNestedMarkdownContent(node, h, ctx => {\n *   if (ctx.parentType === 'orderedList') {\n *     return `${ctx.index + 1}. `\n *   }\n *   return '- '\n * }, ctx)\n *\n * // Custom extension example\n * const CustomContainer = Node.create({\n *   name: 'customContainer',\n *   // ... other config\n *   markdown: {\n *     render: (node, h) => {\n *       const type = node.attrs?.type || 'info'\n *       return renderNestedMarkdownContent(node, h, `[${type}] `)\n *     }\n *   }\n * })\n * ```\n */\nexport function renderNestedMarkdownContent(\n  node: JSONContent,\n  h: {\n    renderChildren: (nodes: JSONContent[]) => string\n    indent: (text: string) => string\n  },\n  prefixOrGenerator: string | ((ctx: any) => string),\n  ctx?: any,\n): string {\n  if (!node || !Array.isArray(node.content)) {\n    return ''\n  }\n\n  // Determine the prefix based on the input\n  const prefix = typeof prefixOrGenerator === 'function' ? prefixOrGenerator(ctx) : prefixOrGenerator\n\n  const [content, ...children] = node.content\n\n  // Render the main content (typically a paragraph)\n  const mainContent = h.renderChildren([content])\n  const output = [`${prefix}${mainContent}`]\n\n  // Handle nested children with proper indentation\n  if (children && children.length > 0) {\n    children.forEach(child => {\n      const childContent = h.renderChildren([child])\n      if (childContent) {\n        // Split the child content by lines and indent each line\n        const indentedChild = childContent\n          .split('\\n')\n          .map(line => (line ? h.indent(line) : ''))\n          .join('\\n')\n        output.push(indentedChild)\n      }\n    })\n  }\n\n  return output.join('\\n')\n}\n","import type { Mark } from '@tiptap/pm/model'\nimport type { ViewMutationRecord } from '@tiptap/pm/view'\n\nimport type { Editor } from './Editor.js'\nimport type { MarkViewProps, MarkViewRendererOptions } from './types.js'\nimport { isAndroid, isiOS } from './utilities/index.js'\n\nexport function updateMarkViewAttributes(checkMark: Mark, editor: Editor, attrs: Record<string, any> = {}): void {\n  const { state } = editor\n  const { doc, tr } = state\n  const thisMark = checkMark\n\n  doc.descendants((node, pos) => {\n    const from = tr.mapping.map(pos)\n    const to = tr.mapping.map(pos) + node.nodeSize\n    let foundMark: Mark | null = null\n\n    // find the mark on the current node\n    node.marks.forEach(mark => {\n      if (mark !== thisMark) {\n        return false\n      }\n\n      foundMark = mark\n    })\n\n    if (!foundMark) {\n      return\n    }\n\n    // check if we need to update given the attributes\n    let needsUpdate = false\n    Object.keys(attrs).forEach(k => {\n      if (attrs[k] !== foundMark!.attrs[k]) {\n        needsUpdate = true\n      }\n    })\n\n    if (needsUpdate) {\n      const updatedMark = checkMark.type.create({\n        ...checkMark.attrs,\n        ...attrs,\n      })\n\n      tr.removeMark(from, to, checkMark.type)\n      tr.addMark(from, to, updatedMark)\n    }\n  })\n\n  if (tr.docChanged) {\n    editor.view.dispatch(tr)\n  }\n}\n\nexport class MarkView<Component, Options extends MarkViewRendererOptions = MarkViewRendererOptions> {\n  component: Component\n  editor: Editor\n  options: Options\n  mark: MarkViewProps['mark']\n  HTMLAttributes: MarkViewProps['HTMLAttributes']\n\n  constructor(component: Component, props: MarkViewProps, options?: Partial<Options>) {\n    this.component = component\n    this.editor = props.editor\n    this.options = { ...options } as Options\n    this.mark = props.mark\n    this.HTMLAttributes = props.HTMLAttributes\n  }\n\n  get dom(): HTMLElement {\n    return this.editor.view.dom\n  }\n\n  get contentDOM(): HTMLElement | null {\n    return null\n  }\n\n  /**\n   * Update the attributes of the mark in the document.\n   * @param attrs The attributes to update.\n   */\n  updateAttributes(attrs: Record<string, any>, checkMark?: Mark): void {\n    updateMarkViewAttributes(checkMark || this.mark, this.editor, attrs)\n  }\n\n  ignoreMutation(mutation: ViewMutationRecord): boolean {\n    if (!this.dom || !this.contentDOM) {\n      return true\n    }\n\n    if (typeof this.options.ignoreMutation === 'function') {\n      return this.options.ignoreMutation({ mutation })\n    }\n\n    if (mutation.type === 'selection') {\n      return false\n    }\n\n    if (\n      this.dom.contains(mutation.target) &&\n      mutation.type === 'childList' &&\n      (isiOS() || isAndroid()) &&\n      this.editor.isFocused\n    ) {\n      const changedNodes = [...Array.from(mutation.addedNodes), ...Array.from(mutation.removedNodes)] as HTMLElement[]\n\n      if (changedNodes.every(node => node.isContentEditable)) {\n        return false\n      }\n    }\n\n    if (this.contentDOM === mutation.target && mutation.type === 'attributes') {\n      return true\n    }\n\n    if (this.contentDOM.contains(mutation.target)) {\n      return false\n    }\n\n    return true\n  }\n}\n","import type { DOMOutputSpec, Node as ProseMirrorNode, NodeSpec, NodeType } from '@tiptap/pm/model'\n\nimport type { Editor } from './Editor.js'\nimport type { ExtendableConfig } from './Extendable.js'\nimport { Extendable } from './Extendable.js'\nimport type { Attributes, NodeViewRenderer, ParentConfig } from './types.js'\n\nexport interface NodeConfig<Options = any, Storage = any>\n  extends ExtendableConfig<Options, Storage, NodeConfig<Options, Storage>, NodeType> {\n  /**\n   * Node View\n   */\n  addNodeView?:\n    | ((this: {\n        name: string\n        options: Options\n        storage: Storage\n        editor: Editor\n        type: NodeType\n        parent: ParentConfig<NodeConfig<Options, Storage>>['addNodeView']\n      }) => NodeViewRenderer | null)\n    | null\n\n  /**\n   * Defines if this node should be a top level node (doc)\n   * @default false\n   * @example true\n   */\n  topNode?: boolean\n\n  /**\n   * The content expression for this node, as described in the [schema\n   * guide](/docs/guide/#schema.content_expressions). When not given,\n   * the node does not allow any content.\n   *\n   * You can read more about it on the Prosemirror documentation here\n   * @see https://prosemirror.net/docs/guide/#schema.content_expressions\n   * @default undefined\n   * @example content: 'block+'\n   * @example content: 'headline paragraph block*'\n   */\n  content?:\n    | NodeSpec['content']\n    | ((this: {\n        name: string\n        options: Options\n        storage: Storage\n        parent: ParentConfig<NodeConfig<Options, Storage>>['content']\n        editor?: Editor\n      }) => NodeSpec['content'])\n\n  /**\n   * The marks that are allowed inside of this node. May be a\n   * space-separated string referring to mark names or groups, `\"_\"`\n   * to explicitly allow all marks, or `\"\"` to disallow marks. When\n   * not given, nodes with inline content default to allowing all\n   * marks, other nodes default to not allowing marks.\n   *\n   * @example marks: 'strong em'\n   */\n  marks?:\n    | NodeSpec['marks']\n    | ((this: {\n        name: string\n        options: Options\n        storage: Storage\n        parent: ParentConfig<NodeConfig<Options, Storage>>['marks']\n        editor?: Editor\n      }) => NodeSpec['marks'])\n\n  /**\n   * The group or space-separated groups to which this node belongs,\n   * which can be referred to in the content expressions for the\n   * schema.\n   *\n   * By default Tiptap uses the groups 'block' and 'inline' for nodes. You\n   * can also use custom groups if you want to group specific nodes together\n   * and handle them in your schema.\n   * @example group: 'block'\n   * @example group: 'inline'\n   * @example group: 'customBlock' // this uses a custom group\n   */\n  group?:\n    | NodeSpec['group']\n    | ((this: {\n        name: string\n        options: Options\n        storage: Storage\n        parent: ParentConfig<NodeConfig<Options, Storage>>['group']\n        editor?: Editor\n      }) => NodeSpec['group'])\n\n  /**\n   * Should be set to true for inline nodes. (Implied for text nodes.)\n   */\n  inline?:\n    | NodeSpec['inline']\n    | ((this: {\n        name: string\n        options: Options\n        storage: Storage\n        parent: ParentConfig<NodeConfig<Options, Storage>>['inline']\n        editor?: Editor\n      }) => NodeSpec['inline'])\n\n  /**\n   * Can be set to true to indicate that, though this isn't a [leaf\n   * node](https://prosemirror.net/docs/ref/#model.NodeType.isLeaf), it doesn't have directly editable\n   * content and should be treated as a single unit in the view.\n   *\n   * @example atom: true\n   */\n  atom?:\n    | NodeSpec['atom']\n    | ((this: {\n        name: string\n        options: Options\n        storage: Storage\n        parent: ParentConfig<NodeConfig<Options, Storage>>['atom']\n        editor?: Editor\n      }) => NodeSpec['atom'])\n\n  /**\n   * Controls whether nodes of this type can be selected as a [node\n   * selection](https://prosemirror.net/docs/ref/#state.NodeSelection). Defaults to true for non-text\n   * nodes.\n   *\n   * @default true\n   * @example selectable: false\n   */\n  selectable?:\n    | NodeSpec['selectable']\n    | ((this: {\n        name: string\n        options: Options\n        storage: Storage\n        parent: ParentConfig<NodeConfig<Options, Storage>>['selectable']\n        editor?: Editor\n      }) => NodeSpec['selectable'])\n\n  /**\n   * Determines whether nodes of this type can be dragged without\n   * being selected. Defaults to false.\n   *\n   * @default: false\n   * @example: draggable: true\n   */\n  draggable?:\n    | NodeSpec['draggable']\n    | ((this: {\n        name: string\n        options: Options\n        storage: Storage\n        parent: ParentConfig<NodeConfig<Options, Storage>>['draggable']\n        editor?: Editor\n      }) => NodeSpec['draggable'])\n\n  /**\n   * Can be used to indicate that this node contains code, which\n   * causes some commands to behave differently.\n   */\n  code?:\n    | NodeSpec['code']\n    | ((this: {\n        name: string\n        options: Options\n        storage: Storage\n        parent: ParentConfig<NodeConfig<Options, Storage>>['code']\n        editor?: Editor\n      }) => NodeSpec['code'])\n\n  /**\n   * Controls way whitespace in this a node is parsed. The default is\n   * `\"normal\"`, which causes the [DOM parser](https://prosemirror.net/docs/ref/#model.DOMParser) to\n   * collapse whitespace in normal mode, and normalize it (replacing\n   * newlines and such with spaces) otherwise. `\"pre\"` causes the\n   * parser to preserve spaces inside the node. When this option isn't\n   * given, but [`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) is true, `whitespace`\n   * will default to `\"pre\"`. Note that this option doesn't influence\n   * the way the node is renderedâ€”that should be handled by `toDOM`\n   * and/or styling.\n   */\n  whitespace?:\n    | NodeSpec['whitespace']\n    | ((this: {\n        name: string\n        options: Options\n        storage: Storage\n        parent: ParentConfig<NodeConfig<Options, Storage>>['whitespace']\n        editor?: Editor\n      }) => NodeSpec['whitespace'])\n\n  /**\n   * Allows a **single** node to be set as linebreak equivalent (e.g. hardBreak).\n   * When converting between block types that have whitespace set to \"pre\"\n   * and don't support the linebreak node (e.g. codeBlock) and other block types\n   * that do support the linebreak node (e.g. paragraphs) - this node will be used\n   * as the linebreak instead of stripping the newline.\n   *\n   * See [linebreakReplacement](https://prosemirror.net/docs/ref/#model.NodeSpec.linebreakReplacement).\n   */\n  linebreakReplacement?:\n    | NodeSpec['linebreakReplacement']\n    | ((this: {\n        name: string\n        options: Options\n        storage: Storage\n        parent: ParentConfig<NodeConfig<Options, Storage>>['linebreakReplacement']\n        editor?: Editor\n      }) => NodeSpec['linebreakReplacement'])\n\n  /**\n   * When enabled, enables both\n   * [`definingAsContext`](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext) and\n   * [`definingForContent`](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).\n   *\n   * @default false\n   * @example isolating: true\n   */\n  defining?:\n    | NodeSpec['defining']\n    | ((this: {\n        name: string\n        options: Options\n        storage: Storage\n        parent: ParentConfig<NodeConfig<Options, Storage>>['defining']\n        editor?: Editor\n      }) => NodeSpec['defining'])\n\n  /**\n   * When enabled (default is false), the sides of nodes of this type\n   * count as boundaries that regular editing operations, like\n   * backspacing or lifting, won't cross. An example of a node that\n   * should probably have this enabled is a table cell.\n   */\n  isolating?:\n    | NodeSpec['isolating']\n    | ((this: {\n        name: string\n        options: Options\n        storage: Storage\n        parent: ParentConfig<NodeConfig<Options, Storage>>['isolating']\n        editor?: Editor\n      }) => NodeSpec['isolating'])\n\n  /**\n   * Associates DOM parser information with this node, which can be\n   * used by [`DOMParser.fromSchema`](https://prosemirror.net/docs/ref/#model.DOMParser^fromSchema) to\n   * automatically derive a parser. The `node` field in the rules is\n   * implied (the name of this node will be filled in automatically).\n   * If you supply your own parser, you do not need to also specify\n   * parsing rules in your schema.\n   *\n   * @example parseHTML: [{ tag: 'div', attrs: { 'data-id': 'my-block' } }]\n   */\n  parseHTML?: (this: {\n    name: string\n    options: Options\n    storage: Storage\n    parent: ParentConfig<NodeConfig<Options, Storage>>['parseHTML']\n    editor?: Editor\n  }) => NodeSpec['parseDOM']\n\n  /**\n   * A description of a DOM structure. Can be either a string, which is\n   * interpreted as a text node, a DOM node, which is interpreted as\n   * itself, a `{dom, contentDOM}` object, or an array.\n   *\n   * An array describes a DOM element. The first value in the array\n   * should be a stringâ€”the name of the DOM element, optionally prefixed\n   * by a namespace URL and a space. If the second element is plain\n   * object, it is interpreted as a set of attributes for the element.\n   * Any elements after that (including the 2nd if it's not an attribute\n   * object) are interpreted as children of the DOM elements, and must\n   * either be valid `DOMOutputSpec` values, or the number zero.\n   *\n   * The number zero (pronounced â€œholeâ€) is used to indicate the place\n   * where a node's child nodes should be inserted. If it occurs in an\n   * output spec, it should be the only child element in its parent\n   * node.\n   *\n   * @example toDOM: ['div[data-id=\"my-block\"]', { class: 'my-block' }, 0]\n   */\n  renderHTML?:\n    | ((\n        this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['renderHTML']\n          editor?: Editor\n        },\n        props: {\n          node: ProseMirrorNode\n          HTMLAttributes: Record<string, any>\n        },\n      ) => DOMOutputSpec)\n    | null\n\n  /**\n   * renders the node as text\n   * @example renderText: () => 'foo\n   */\n  renderText?:\n    | ((\n        this: {\n          name: string\n          options: Options\n          storage: Storage\n          parent: ParentConfig<NodeConfig<Options, Storage>>['renderText']\n          editor?: Editor\n        },\n        props: {\n          node: ProseMirrorNode\n          pos: number\n          parent: ProseMirrorNode\n          index: number\n        },\n      ) => string)\n    | null\n\n  /**\n   * Add attributes to the node\n   * @example addAttributes: () => ({ class: 'foo' })\n   */\n  addAttributes?: (this: {\n    name: string\n    options: Options\n    storage: Storage\n    parent: ParentConfig<NodeConfig<Options, Storage>>['addAttributes']\n    editor?: Editor\n    // eslint-disable-next-line @typescript-eslint/no-empty-object-type\n  }) => Attributes | {}\n}\n\n/**\n * The Node class is used to create custom node extensions.\n * @see https://tiptap.dev/api/extensions#create-a-new-extension\n */\nexport class Node<Options = any, Storage = any> extends Extendable<Options, Storage, NodeConfig<Options, Storage>> {\n  type = 'node'\n\n  /**\n   * Create a new Node instance\n   * @param config - Node configuration object or a function that returns a configuration object\n   */\n  static create<O = any, S = any>(config: Partial<NodeConfig<O, S>> | (() => Partial<NodeConfig<O, S>>) = {}) {\n    // If the config is a function, execute it to get the configuration object\n    const resolvedConfig = typeof config === 'function' ? config() : config\n    return new Node<O, S>(resolvedConfig)\n  }\n\n  configure(options?: Partial<Options>) {\n    return super.configure(options) as Node<Options, Storage>\n  }\n\n  extend<\n    ExtendedOptions = Options,\n    ExtendedStorage = Storage,\n    ExtendedConfig extends NodeConfig<ExtendedOptions, ExtendedStorage> = NodeConfig<ExtendedOptions, ExtendedStorage>,\n  >(\n    extendedConfig?:\n      | (() => Partial<ExtendedConfig>)\n      | (Partial<ExtendedConfig> &\n          ThisType<{\n            name: string\n            options: ExtendedOptions\n            storage: ExtendedStorage\n            editor: Editor\n            type: NodeType\n          }>),\n  ): Node<ExtendedOptions, ExtendedStorage> {\n    // If the extended config is a function, execute it to get the configuration object\n    const resolvedConfig = typeof extendedConfig === 'function' ? extendedConfig() : extendedConfig\n    return super.extend(resolvedConfig) as Node<ExtendedOptions, ExtendedStorage>\n  }\n}\n","import { NodeSelection } from '@tiptap/pm/state'\nimport type { NodeView as ProseMirrorNodeView, ViewMutationRecord } from '@tiptap/pm/view'\n\nimport type { Editor as CoreEditor } from './Editor.js'\nimport type { DecorationWithType, NodeViewRendererOptions, NodeViewRendererProps } from './types.js'\nimport { isAndroid } from './utilities/isAndroid.js'\nimport { isiOS } from './utilities/isiOS.js'\n\n/**\n * Node views are used to customize the rendered DOM structure of a node.\n * @see https://tiptap.dev/guide/node-views\n */\nexport class NodeView<\n  Component,\n  NodeEditor extends CoreEditor = CoreEditor,\n  Options extends NodeViewRendererOptions = NodeViewRendererOptions,\n> implements ProseMirrorNodeView\n{\n  component: Component\n\n  editor: NodeEditor\n\n  options: Options\n\n  extension: NodeViewRendererProps['extension']\n\n  node: NodeViewRendererProps['node']\n\n  decorations: NodeViewRendererProps['decorations']\n\n  innerDecorations: NodeViewRendererProps['innerDecorations']\n\n  view: NodeViewRendererProps['view']\n\n  getPos: NodeViewRendererProps['getPos']\n\n  HTMLAttributes: NodeViewRendererProps['HTMLAttributes']\n\n  isDragging = false\n\n  constructor(component: Component, props: NodeViewRendererProps, options?: Partial<Options>) {\n    this.component = component\n    this.editor = props.editor as NodeEditor\n    this.options = {\n      stopEvent: null,\n      ignoreMutation: null,\n      ...options,\n    } as Options\n    this.extension = props.extension\n    this.node = props.node\n    this.decorations = props.decorations as DecorationWithType[]\n    this.innerDecorations = props.innerDecorations\n    this.view = props.view\n    this.HTMLAttributes = props.HTMLAttributes\n    this.getPos = props.getPos\n    this.mount()\n  }\n\n  mount() {\n    // eslint-disable-next-line\n    return\n  }\n\n  get dom(): HTMLElement {\n    return this.editor.view.dom as HTMLElement\n  }\n\n  get contentDOM(): HTMLElement | null {\n    return null\n  }\n\n  onDragStart(event: DragEvent) {\n    const { view } = this.editor\n    const target = event.target as HTMLElement\n\n    // get the drag handle element\n    // `closest` is not available for text nodes so we may have to use its parent\n    const dragHandle =\n      target.nodeType === 3 ? target.parentElement?.closest('[data-drag-handle]') : target.closest('[data-drag-handle]')\n\n    if (!this.dom || this.contentDOM?.contains(target) || !dragHandle) {\n      return\n    }\n\n    let x = 0\n    let y = 0\n\n    // calculate offset for drag element if we use a different drag handle element\n    if (this.dom !== dragHandle) {\n      const domBox = this.dom.getBoundingClientRect()\n      const handleBox = dragHandle.getBoundingClientRect()\n\n      // In React, we have to go through nativeEvent to reach offsetX/offsetY.\n      const offsetX = event.offsetX ?? (event as any).nativeEvent?.offsetX\n      const offsetY = event.offsetY ?? (event as any).nativeEvent?.offsetY\n\n      x = handleBox.x - domBox.x + offsetX\n      y = handleBox.y - domBox.y + offsetY\n    }\n\n    const clonedNode = this.dom.cloneNode(true) as HTMLElement\n\n    // Preserve the visual size of the original when using the clone as\n    // the drag image.\n    try {\n      const domBox = this.dom.getBoundingClientRect()\n      clonedNode.style.width = `${Math.round(domBox.width)}px`\n      clonedNode.style.height = `${Math.round(domBox.height)}px`\n      clonedNode.style.boxSizing = 'border-box'\n      // Ensure the clone doesn't capture pointer events while offscreen\n      clonedNode.style.pointerEvents = 'none'\n    } catch {\n      // ignore measurement errors (e.g. if element not in DOM)\n    }\n\n    // Some browsers (notably Safari) require the element passed to\n    // setDragImage to be present in the DOM. Using a detached node can\n    // cause the drag to immediately end.\n    let dragImageWrapper: HTMLElement | null = null\n\n    try {\n      dragImageWrapper = document.createElement('div')\n      dragImageWrapper.style.position = 'absolute'\n      dragImageWrapper.style.top = '-9999px'\n      dragImageWrapper.style.left = '-9999px'\n      dragImageWrapper.style.pointerEvents = 'none'\n      dragImageWrapper.appendChild(clonedNode)\n      document.body.appendChild(dragImageWrapper)\n\n      event.dataTransfer?.setDragImage(clonedNode, x, y)\n    } finally {\n      // Remove the wrapper on the next tick so the browser can use the\n      // element as the drag image. A 0ms timeout is enough in practice.\n      if (dragImageWrapper) {\n        setTimeout(() => {\n          try {\n            dragImageWrapper?.remove()\n          } catch {\n            // ignore removal errors\n          }\n        }, 0)\n      }\n    }\n\n    const pos = this.getPos()\n\n    if (typeof pos !== 'number') {\n      return\n    }\n    // we need to tell ProseMirror that we want to move the whole node\n    // so we create a NodeSelection\n    const selection = NodeSelection.create(view.state.doc, pos)\n    const transaction = view.state.tr.setSelection(selection)\n\n    view.dispatch(transaction)\n  }\n\n  stopEvent(event: Event) {\n    if (!this.dom) {\n      return false\n    }\n\n    if (typeof this.options.stopEvent === 'function') {\n      return this.options.stopEvent({ event })\n    }\n\n    const target = event.target as HTMLElement\n    const isInElement = this.dom.contains(target) && !this.contentDOM?.contains(target)\n\n    // any event from child nodes should be handled by ProseMirror\n    if (!isInElement) {\n      return false\n    }\n\n    const isDragEvent = event.type.startsWith('drag')\n    const isDropEvent = event.type === 'drop'\n    const isInput = ['INPUT', 'BUTTON', 'SELECT', 'TEXTAREA'].includes(target.tagName) || target.isContentEditable\n\n    // any input event within node views should be ignored by ProseMirror\n    if (isInput && !isDropEvent && !isDragEvent) {\n      return true\n    }\n\n    const { isEditable } = this.editor\n    const { isDragging } = this\n    const isDraggable = !!this.node.type.spec.draggable\n    const isSelectable = NodeSelection.isSelectable(this.node)\n    const isCopyEvent = event.type === 'copy'\n    const isPasteEvent = event.type === 'paste'\n    const isCutEvent = event.type === 'cut'\n    const isClickEvent = event.type === 'mousedown'\n\n    // ProseMirror tries to drag selectable nodes\n    // even if `draggable` is set to `false`\n    // this fix prevents that\n    if (!isDraggable && isSelectable && isDragEvent && event.target === this.dom) {\n      event.preventDefault()\n    }\n\n    if (isDraggable && isDragEvent && !isDragging && event.target === this.dom) {\n      event.preventDefault()\n      return false\n    }\n\n    // we have to store that dragging started\n    if (isDraggable && isEditable && !isDragging && isClickEvent) {\n      const dragHandle = target.closest('[data-drag-handle]')\n      const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle))\n\n      if (isValidDragHandle) {\n        this.isDragging = true\n\n        document.addEventListener(\n          'dragend',\n          () => {\n            this.isDragging = false\n          },\n          { once: true },\n        )\n\n        document.addEventListener(\n          'drop',\n          () => {\n            this.isDragging = false\n          },\n          { once: true },\n        )\n\n        document.addEventListener(\n          'mouseup',\n          () => {\n            this.isDragging = false\n          },\n          { once: true },\n        )\n      }\n    }\n\n    // these events are handled by prosemirror\n    if (isDragging || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || (isClickEvent && isSelectable)) {\n      return false\n    }\n\n    return true\n  }\n\n  /**\n   * Called when a DOM [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or a selection change happens within the view.\n   * @return `false` if the editor should re-read the selection or re-parse the range around the mutation\n   * @return `true` if it can safely be ignored.\n   */\n  ignoreMutation(mutation: ViewMutationRecord) {\n    if (!this.dom || !this.contentDOM) {\n      return true\n    }\n\n    if (typeof this.options.ignoreMutation === 'function') {\n      return this.options.ignoreMutation({ mutation })\n    }\n\n    // a leaf/atom node is like a black box for ProseMirror\n    // and should be fully handled by the node view\n    if (this.node.isLeaf || this.node.isAtom) {\n      return true\n    }\n\n    // ProseMirror should handle any selections\n    if (mutation.type === 'selection') {\n      return false\n    }\n\n    // try to prevent a bug on iOS and Android that will break node views on enter\n    // this is because ProseMirror canâ€™t preventDispatch on enter\n    // this will lead to a re-render of the node view on enter\n    // see: https://github.com/ueberdosis/tiptap/issues/1214\n    // see: https://github.com/ueberdosis/tiptap/issues/2534\n    if (\n      this.dom.contains(mutation.target) &&\n      mutation.type === 'childList' &&\n      (isiOS() || isAndroid()) &&\n      this.editor.isFocused\n    ) {\n      const changedNodes = [...Array.from(mutation.addedNodes), ...Array.from(mutation.removedNodes)] as HTMLElement[]\n\n      // weâ€™ll check if every changed node is contentEditable\n      // to make sure itâ€™s probably mutated by ProseMirror\n      if (changedNodes.every(node => node.isContentEditable)) {\n        return false\n      }\n    }\n\n    // we will allow mutation contentDOM with attributes\n    // so we can for example adding classes within our node view\n    if (this.contentDOM === mutation.target && mutation.type === 'attributes') {\n      return true\n    }\n\n    // ProseMirror should handle any changes within contentDOM\n    if (this.contentDOM.contains(mutation.target)) {\n      return false\n    }\n\n    return true\n  }\n\n  /**\n   * Update the attributes of the prosemirror node.\n   */\n  updateAttributes(attributes: Record<string, any>): void {\n    this.editor.commands.command(({ tr }) => {\n      const pos = this.getPos()\n\n      if (typeof pos !== 'number') {\n        return false\n      }\n\n      tr.setNodeMarkup(pos, undefined, {\n        ...this.node.attrs,\n        ...attributes,\n      })\n\n      return true\n    })\n  }\n\n  /**\n   * Delete the node.\n   */\n  deleteNode(): void {\n    const from = this.getPos()\n\n    if (typeof from !== 'number') {\n      return\n    }\n    const to = from + this.node.nodeSize\n\n    this.editor.commands.deleteRange({ from, to })\n  }\n}\n","import type { MarkType } from '@tiptap/pm/model'\n\nimport { getMarksBetween } from '../helpers/getMarksBetween.js'\nimport type { PasteRuleFinder } from '../PasteRule.js'\nimport { PasteRule } from '../PasteRule.js'\nimport type { ExtendedRegExpMatchArray } from '../types.js'\nimport { callOrReturn } from '../utilities/callOrReturn.js'\n\n/**\n * Build an paste rule that adds a mark when the\n * matched text is pasted into it.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#paste-rules\n */\nexport function markPasteRule(config: {\n  find: PasteRuleFinder\n  type: MarkType\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray, event: ClipboardEvent) => Record<string, any>)\n    | false\n    | null\n}) {\n  return new PasteRule({\n    find: config.find,\n    handler: ({ state, range, match, pasteEvent }) => {\n      const attributes = callOrReturn(config.getAttributes, undefined, match, pasteEvent)\n\n      if (attributes === false || attributes === null) {\n        return null\n      }\n\n      const { tr } = state\n      const captureGroup = match[match.length - 1]\n      const fullMatch = match[0]\n      let markEnd = range.to\n\n      if (captureGroup) {\n        const startSpaces = fullMatch.search(/\\S/)\n        const textStart = range.from + fullMatch.indexOf(captureGroup)\n        const textEnd = textStart + captureGroup.length\n\n        const excludedMarks = getMarksBetween(range.from, range.to, state.doc)\n          .filter(item => {\n            // @ts-ignore\n            const excluded = item.mark.type.excluded as MarkType[]\n\n            return excluded.find(type => type === config.type && type !== item.mark.type)\n          })\n          .filter(item => item.to > textStart)\n\n        if (excludedMarks.length) {\n          return null\n        }\n\n        if (textEnd < range.to) {\n          tr.delete(textEnd, range.to)\n        }\n\n        if (textStart > range.from) {\n          tr.delete(range.from + startSpaces, textStart)\n        }\n\n        markEnd = range.from + startSpaces + captureGroup.length\n\n        tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}))\n\n        tr.removeStoredMark(config.type)\n      }\n    },\n  })\n}\n","import type { NodeType } from '@tiptap/pm/model'\n\nimport type { PasteRuleFinder } from '../PasteRule.js'\nimport { PasteRule } from '../PasteRule.js'\nimport type { ExtendedRegExpMatchArray, JSONContent } from '../types.js'\nimport { callOrReturn } from '../utilities/index.js'\n\n/**\n * Build an paste rule that adds a node when the\n * matched text is pasted into it.\n * @see https://tiptap.dev/docs/editor/api/paste-rules\n */\nexport function nodePasteRule(config: {\n  find: PasteRuleFinder\n  type: NodeType\n  getAttributes?:\n    | Record<string, any>\n    | ((match: ExtendedRegExpMatchArray, event: ClipboardEvent) => Record<string, any>)\n    | false\n    | null\n  getContent?: JSONContent[] | ((attrs: Record<string, any>) => JSONContent[]) | false | null\n}) {\n  return new PasteRule({\n    find: config.find,\n    handler({ match, chain, range, pasteEvent }) {\n      const attributes = callOrReturn(config.getAttributes, undefined, match, pasteEvent)\n      const content = callOrReturn(config.getContent, undefined, attributes)\n\n      if (attributes === false || attributes === null) {\n        return null\n      }\n\n      const node = { type: config.type.name, attrs: attributes } as JSONContent\n\n      if (content) {\n        node.content = content\n      }\n\n      if (match.input) {\n        chain().deleteRange(range).insertContentAt(range.from, node)\n      }\n    },\n  })\n}\n","import type { PasteRuleFinder } from '../PasteRule.js'\nimport { PasteRule } from '../PasteRule.js'\n\n/**\n * Build an paste rule that replaces text when the\n * matched text is pasted into it.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#paste-rules\n */\nexport function textPasteRule(config: { find: PasteRuleFinder; replace: string }) {\n  return new PasteRule({\n    find: config.find,\n    handler: ({ state, range, match }) => {\n      let insert = config.replace\n      let start = range.from\n      const end = range.to\n\n      if (match[1]) {\n        const offset = match[0].lastIndexOf(match[1])\n\n        insert += match[0].slice(offset + match[1].length)\n        start += offset\n\n        const cutOff = start - end\n\n        if (cutOff > 0) {\n          insert = match[0].slice(offset - cutOff, offset) + insert\n          start = end\n        }\n      }\n\n      state.tr.insertText(insert, start, end)\n    },\n  })\n}\n","import type { Transaction } from '@tiptap/pm/state'\n\nexport interface TrackerResult {\n  position: number\n  deleted: boolean\n}\n\nexport class Tracker {\n  transaction: Transaction\n\n  currentStep: number\n\n  constructor(transaction: Transaction) {\n    this.transaction = transaction\n    this.currentStep = this.transaction.steps.length\n  }\n\n  map(position: number): TrackerResult {\n    let deleted = false\n\n    const mappedPosition = this.transaction.steps.slice(this.currentStep).reduce((newPosition, step) => {\n      const mapResult = step.getMap().mapResult(newPosition)\n\n      if (mapResult.deleted) {\n        deleted = true\n      }\n\n      return mapResult.pos\n    }, position)\n\n    return {\n      position: mappedPosition,\n      deleted,\n    }\n  }\n}\n","import { Mark, mergeAttributes } from '@tiptap/core'\nimport { Plugin, PluginKey } from '@tiptap/pm/state'\nimport type { Editor } from '@tiptap/core'\nimport type { CommentWithUser } from './comments'\n\nexport interface CommentMarkOptions {\n  onCommentClick?: (commentId: string) => void\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    comment: {\n      setComment: (commentId: string) => ReturnType\n      unsetComment: (commentId: string) => ReturnType\n    }\n  }\n}\n\nexport const CommentMark = Mark.create<CommentMarkOptions>({\n  name: 'comment',\n\n  addOptions() {\n    return {\n      onCommentClick: undefined,\n    }\n  },\n\n  addAttributes() {\n    return {\n      commentId: {\n        default: null,\n        parseHTML: (element) => element.getAttribute('data-comment-id'),\n        renderHTML: (attributes) => ({\n          'data-comment-id': attributes.commentId,\n        }),\n      },\n    }\n  },\n\n  parseHTML() {\n    return [{ tag: 'mark[data-comment-id]' }]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\n      'mark',\n      mergeAttributes(HTMLAttributes, {\n        class:\n          'bg-yellow-200/50 dark:bg-yellow-500/30 dark:text-foreground cursor-pointer hover:bg-yellow-300/60 dark:hover:bg-yellow-500/40 transition-colors rounded-sm',\n      }),\n      0,\n    ]\n  },\n\n  addCommands() {\n    return {\n      setComment:\n        (commentId: string) =>\n        ({ commands }) => {\n          return commands.setMark(this.name, { commentId })\n        },\n      unsetComment:\n        (commentId: string) =>\n        ({ tr, state }) => {\n          const { doc } = state\n          let found = false\n\n          doc.descendants((node, pos) => {\n            node.marks.forEach((mark) => {\n              if (mark.type.name === this.name && mark.attrs.commentId === commentId) {\n                tr.removeMark(pos, pos + node.nodeSize, mark.type)\n                found = true\n              }\n            })\n          })\n\n          return found\n        },\n    }\n  },\n\n  addProseMirrorPlugins() {\n    const { onCommentClick } = this.options\n\n    return [\n      new Plugin({\n        key: new PluginKey('commentClick'),\n        props: {\n          handleClick(view, pos) {\n            if (!onCommentClick) return false\n\n            const { state } = view\n            const $pos = state.doc.resolve(pos)\n            const marks = $pos.marks()\n\n            const commentMark = marks.find((mark) => mark.type.name === 'comment')\n            if (commentMark && commentMark.attrs.commentId) {\n              // Blur the editor to prevent keyboard popup on mobile\n              ;(view.dom as HTMLElement).blur()\n              onCommentClick(commentMark.attrs.commentId)\n              return true\n            }\n\n            return false\n          },\n        },\n      }),\n    ]\n  },\n})\n\n/**\n * Apply comment mark to the current selection\n */\nexport function addCommentMark(\n  editor: Editor,\n  commentId: string,\n  from: number,\n  to: number\n): void {\n  // Guard against editor not being ready\n  if (!editor.view || editor.isDestroyed) {\n    console.warn('Cannot add comment mark: editor not ready')\n    return\n  }\n  \n  editor\n    .chain()\n    .setTextSelection({ from, to })\n    .setComment(commentId)\n    .run()\n}\n\n/**\n * Remove comment mark from the document\n */\nexport function removeCommentMark(editor: Editor, commentId: string): void {\n  if (!editor.view || editor.isDestroyed) return\n  editor.chain().unsetComment(commentId).run()\n}\n\n/**\n * Re-apply comment marks based on quoted text matching.\n * Called when loading a post with existing comments.\n */\nexport function applyCommentMarks(\n  editor: Editor,\n  comments: CommentWithUser[]\n): void {\n  if (!editor.view || editor.isDestroyed) return\n  \n  const { doc } = editor.state\n  const textContent = doc.textContent\n\n  comments.forEach((comment) => {\n    if (!comment.quotedText || comment.parentId || comment.resolved) return // Skip replies\n\n    const index = textContent.indexOf(comment.quotedText)\n    if (index === -1) return // Text not found\n\n    // Find the actual position in the document\n    let currentPos = 0\n    let startPos: number | null = null\n    let endPos: number | null = null\n\n    doc.descendants((node, pos) => {\n      if (startPos !== null && endPos !== null) return false\n\n      if (node.isText && node.text) {\n        const nodeStart = currentPos\n        const nodeEnd = currentPos + node.text.length\n\n        if (startPos === null && nodeEnd > index) {\n          // Start is in this node\n          const offsetInNode = index - nodeStart\n          startPos = pos + offsetInNode\n        }\n\n        if (startPos !== null && endPos === null) {\n          const targetEnd = index + comment.quotedText.length\n          if (nodeEnd >= targetEnd) {\n            // End is in this node\n            const offsetInNode = targetEnd - nodeStart\n            endPos = pos + offsetInNode\n          }\n        }\n\n        currentPos = nodeEnd\n      }\n\n      return true\n    })\n\n    if (startPos !== null && endPos !== null) {\n      editor\n        .chain()\n        .setTextSelection({ from: startPos, to: endPos })\n        .setComment(comment.id)\n        .setTextSelection(endPos) // Deselect\n        .run()\n    }\n  })\n}\n\n/**\n * Scroll to a comment mark in the editor\n */\nexport function scrollToComment(editor: Editor, commentId: string): void {\n  if (!editor.view || editor.isDestroyed) return\n  \n  const { doc } = editor.state\n\n  doc.descendants((node, pos) => {\n    const commentMark = node.marks.find(\n      (mark) => mark.type.name === 'comment' && mark.attrs.commentId === commentId\n    )\n\n    if (commentMark) {\n      editor.chain().setTextSelection(pos).run()\n\n      // Scroll to the selection\n      const view = editor.view\n      const coords = view.coordsAtPos(pos)\n      const editorRect = view.dom.getBoundingClientRect()\n\n      if (coords.top < editorRect.top || coords.bottom > editorRect.bottom) {\n        view.dom.scrollIntoView({ behavior: 'smooth', block: 'center' })\n      }\n\n      return false // Stop iteration\n    }\n\n    return true\n  })\n}\n"],"mappings":"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","names":["sliceZone","name","__defProp","__export","name","prismicDocument","asLink: {\n\t/**\n\t * Converts any type of link field or Prismic page to a URL.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const url = asLink(document.data.link)\n\t * // => \"/blog/my-post\"\n\t * ```\n\t *\n\t * @typeParam LinkResolverFunctionReturnType - Link resolver function return\n\t *   type.\n\t * @typeParam Field - Link field or Prismic page to resolve to a URL.\n\t *\n\t * @param linkFieldOrDocument - Any kind of link field or a page to resolve.\n\t * @param config - Configuration that determines the output of `asLink()`.\n\t *\n\t * @returns Resolved URL, or `null` if the link field or page is empty.\n\t *\n\t * @see Learn about route resolvers and link resolvers: {@link https://prismic.io/docs/routes}\n\t */\n\t<\n\t\tLinkResolverFunctionReturnType = string | null | undefined,\n\t\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t\t| LinkField\n\t\t\t| PrismicDocument\n\t\t\t| null\n\t\t\t| undefined,\n\t>(\n\t\tlinkFieldOrDocument: Field,\n\t\tconfig?: AsLinkConfig<LinkResolverFunctionReturnType>,\n\t): AsLinkReturnType<LinkResolverFunctionReturnType, Field>\n\n\t/**\n\t * Converts any type of link field or Prismic page to a URL.\n\t *\n\t * @deprecated Use object-style configuration instead.\n\t *\n\t * @typeParam LinkResolverFunctionReturnType - Link resolver function return\n\t *   type.\n\t * @typeParam Field - Link field or Prismic page to resolve to a URL.\n\t *\n\t * @param linkFieldOrDocument - Any kind of link field or a page to resolve.\n\t * @param linkResolver - An optional link resolver function. Without it,\n\t *   you're expected to use the `routes` option from the API.\n\t *\n\t * @returns Resolved URL, or `null` if the link field or page is empty.\n\t *\n\t * @see Learn about route resolvers and link resolvers: {@link https://prismic.io/docs/routes}\n\t */\n\t<\n\t\tLinkResolverFunctionReturnType = string | null | undefined,\n\t\tField extends LinkField | PrismicDocument | null | undefined =\n\t\t\t| LinkField\n\t\t\t| PrismicDocument\n\t\t\t| null\n\t\t\t| undefined,\n\t>(\n\t\tlinkFieldOrDocument: Field,\n\t\t...config: AsLinkDeprecatedTupleConfig<LinkResolverFunctionReturnType>\n\t): AsLinkReturnType<LinkResolverFunctionReturnType, Field>\n}","config: AsLinkConfig<LinkResolverFunctionReturnType>","filter","predicate","name","value: string | undefined","previewCookieName","queue: AnyFunction[]","run","job: Promise<ResponseLike>","THROTTLED_RUNNERS: Partial<Record<string, LimitFunction>>","DEDUPLICATED_JOBS: Partial<\n\tRecord<string, Map<AbortSignalLike | undefined, Promise<ResponseLike>>>\n>","lastMessage: string | undefined","fetch","request","documents: TDocument[]","latestResult: Query<TDocument> | undefined","ref","documentID: string | undefined | null","previewToken: string | undefined | null","headers: NonNullable<RequestInitLike[\"headers\"]>","#getResolvedRef","#autoPreviewsRequest","#getRef","#internalGet","#throwContentAPIError","#request","createClient: CreateClient","document","title","repeatable","group","contentRelationship","image","linkToMedia","rtImageNode","is.prismicDocument","res: OptionalLinkProperties","isMigration.contentRelationship","isMigration.image","isMigration.linkToMedia","isMigration.rtImageNode","res: Record<PropertyKey, unknown>","image","dimensions: FilledImageFieldImage[\"dimensions\"]","edit: FilledImageFieldImage[\"edit\"]","resolvedThumbnails: Record<string, FilledImageFieldImage>","name","rtImageNode","isFilled.link","linkToMedia","_a","resolvedFile: PostAssetParams[\"file\"] | File","url: URL | undefined","documentsToCreate: PrismicMigrationDocument<TDocuments>[]","masterLanguageDocumentID: string | undefined","request_fn","existingTagMap: Record<string, AssetTag>","document","#request","#handleAssetAPIError","#handleMigrationAPIError","createWriteClient: CreateWriteClient","errors: string[]","_a","config: MigrationAssetConfig","maybeInitialField: FilledImageFieldImage | undefined","filename","credits","alt","name","document","title","is.filledContentRelationship","is.filledLinkToMedia","is.rtImageNode","rtImageNode: MigrationRTImageNode","rtImageNode","is.filledImage","image: MigrationImage","image","res: Record<PropertyKey, unknown>","createMigration: CreateMigration","isFilledLink","asText: {\n\t/**\n\t * Converts a rich text field to a plain text string.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const text = asText(document.data.content)\n\t * // => \"Hello world\"\n\t * ```\n\t *\n\t * @param richTextField - A rich text field from Prismic.\n\t * @param config - Configuration that determines the output of `asText()`.\n\t *\n\t * @returns Plain text equivalent of the rich text field, or `null` if the\n\t *   field is empty.\n\t *\n\t * @see Learn how to work with rich text fields: {@link https://prismic.io/docs/fields/rich-text}\n\t */\n\t<Field extends RichTextField | null | undefined>(\n\t\trichTextField: Field,\n\t\tconfig?: AsTextConfig,\n\t): AsTextReturnType<Field>\n\n\t/**\n\t * Converts a rich text field to a plain text string.\n\t *\n\t * @deprecated Use object-style configuration instead.\n\t *\n\t * @param richTextField - A rich text field from Prismic.\n\t * @param separator - Separator used to join each element. Defaults to a\n\t *   space.\n\t *\n\t * @returns Plain text equivalent of the rich text field, or `null` if the\n\t *   field is empty.\n\t *\n\t * @see Learn how to work with rich text fields: {@link https://prismic.io/docs/fields/rich-text}\n\t */\n\t<Field extends RichTextField | null | undefined>(\n\t\trichTextField: Field,\n\t\t...config: AsTextDeprecatedTupleConfig\n\t): AsTextReturnType<Field>\n}","config: AsTextConfig","baseAsText","children: TreeNode[]","mutNodes: RTBlockNode[]","items: (RTListItemNode | RTOListItemNode)[]","mutSpans: RTInlineNode[]","childSpans: RTInlineNode[]","serializedTreeNodes: T[]","tagSerializer: RichTextMapSerializer<SerializerReturnType>[keyof RichTextMapSerializer<SerializerReturnType>]","asHTML: {\n\t/**\n\t * Converts a rich text field to an HTML string.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const html = asHTML(document.data.content)\n\t * // => \"<p>Hello world</p>\"\n\t * ```\n\t *\n\t * @param richTextField - A rich text field from Prismic.\n\t * @param config - Configuration that determines the output of `asHTML()`.\n\t *\n\t * @returns HTML equivalent of the rich text field, or `null` if the field is\n\t *   empty.\n\t *\n\t * @see Learn how to style rich text and customize rendering: {@link https://prismic.io/docs/fields/rich-text}\n\t */\n\t<Field extends RichTextField | null | undefined>(\n\t\trichTextField: Field,\n\t\tconfig?: AsHTMLConfig,\n\t): AsHTMLReturnType<Field>\n\n\t/**\n\t * Converts a rich text field to an HTML string.\n\t *\n\t * @deprecated Use object-style configuration instead.\n\t *\n\t * @param richTextField - A rich text field from Prismic.\n\t * @param linkResolver - An optional link resolver function to resolve links.\n\t *   Without it, you're expected to use the `routes` option from the API.\n\t * @param serializer - An optional rich text serializer. Unhandled cases will\n\t *   fall back to the default serializer.\n\t *\n\t * @returns HTML equivalent of the rich text field, or `null` if the field is\n\t *   empty.\n\t *\n\t * @see Learn how to style rich text and customize rendering: {@link https://prismic.io/docs/fields/rich-text}\n\t */\n\t<Field extends RichTextField | null | undefined>(\n\t\trichTextField: Field,\n\t\t...config: AsHTMLDeprecatedTupleConfig\n\t): AsHTMLReturnType<Field>\n}","config: AsHTMLConfig","serializer: RichTextFunctionSerializer<string>","isImageThumbnailFilled","isFilled.imageThumbnail","responsiveViewObjects: ImageFieldImage<\"filled\">[]","isImageThumbnailFilled","init_types","init_types","OpenAI","Anthropic","response","content","buildChatPrompt","buildExpandPlanPrompt","buildGeneratePrompt","buildPlanPrompt","buildRewritePrompt","init_builders","title","buildGeneratePrompt","buildExpandPlanPrompt","init_generate","init_builders","buildPlanPrompt","buildChatPrompt","extractUrls","init_chat","init_builders","buildChatPrompt","buildExpandPlanPrompt","buildGeneratePrompt","buildPlanPrompt","buildRewritePrompt","name","jsonResponse","jsonResponse","jsonResponse","jsonResponse","wordCount","expandPlanStream","generateStream","generate","chatStream","buildRewritePrompt","createStream","jsonResponse","jsonResponse","jsonResponse","jsonResponse","jsonResponse","jsonResponse","jsonResponse","Parser","init_generate","init_chat","init_builders","title","TurndownService","title","sanitizeHtml","generateUniqueSlug","title","name","table","date","import_commands","import_state","import_model","import_transform","import_schema_list","name","command","run","__export","_a","originalCreateParagraphNear","originalDeleteSelection","originalExitCode","mark","TextSelection","ProseMirrorNode","parser","Selection","Fragment","isTextSelection","originalJoinUp","originalJoinDown","originalJoinBackward","originalJoinForward","joinPoint","originalCommand","isActive","originalLift","originalLiftEmptyBlock","originalLiftListItem","originalNewlineInCode","originalSelectNodeBackward","originalSelectNodeForward","originalSelectParentNode","originalSelectTextblockEnd","originalSelectTextblockStart","document","predicate","name","style","_a","Schema","_a","name","name","_a","range","name","group","_a","_a","NodeSelection","TextSelection","originalSinkListItem","first","Fragment","newNextTypeAttributes","nextType","canSplit","isActive","originalWrapIn","originalWrapInList","_a","Fragment","run","_a","Plugin","Fragment","from","to","__export","range","_b","_c","PluginKey","Selection","tr","__export","_a","parseAttributes","serializeAttributes","h","nextIndent","import_state"]}
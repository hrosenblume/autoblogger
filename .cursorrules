# Autoblogger - Programming Rules

> For project context and architecture, see `.cursor/context.md`

## Code Organization

### Server vs Client Split
- `src/index.ts` exports server-safe code only (no React imports)
- `src/ui/index.ts` exports React components
- Never import React in server files
- Types in `types/config.ts` must be server-safe (no ComponentType, etc.)

### File Naming
- React components: PascalCase (`ChatPanel.tsx`)
- Utilities/hooks: camelCase (`useChat.ts`, `markdown.ts`)
- Types: Keep in `types/` folder, export from `types/index.ts`

## TypeScript

### Strict Mode
- Project uses strict TypeScript
- Avoid `any` - use `unknown` with type guards when needed
- Prefer explicit return types on exported functions

### Type Patterns
```typescript
// For Prisma client passed via config (unknown to avoid peer dep issues)
const prisma = config.prisma as any

// For optional chaining with DB models
settings?.prismicEnabled ?? false

// For discriminated unions
type EditCommand = 
  | { type: 'replace_all'; markdown: string }
  | { type: 'replace_section'; find: string; replace: string }
```

## React Conventions

### Client Components
- Always add `'use client'` directive at top
- Use hooks from `react` directly, not re-exports

### State Management
- Local state for component-specific data
- Context for cross-component shared state (Dashboard, Chat)
- Avoid prop drilling more than 2 levels

### Event Handlers
```typescript
// Use useCallback for handlers passed to children
const handleSave = useCallback(async () => {
  // ...
}, [dependencies])

// Use refs to avoid re-creating callbacks
const saveRef = useRef(handleSave)
useEffect(() => { saveRef.current = handleSave }, [handleSave])
```

## Styling

### Tailwind with Dark Mode
- Use `ab-dark:` prefix for dark mode variants (custom plugin)
- Example: `bg-white ab-dark:bg-gray-900`

### Component Classes
```typescript
import { cn } from '../lib/cn'

// Use cn() for conditional classes
className={cn(
  'base-classes',
  active && 'active-classes',
  disabled && 'disabled-classes'
)}
```

### Mobile-First
- Default styles for mobile
- Use `md:` for desktop overrides
- Touch targets: minimum 44x44px (`min-w-[44px] min-h-[44px]`)

## API Patterns

### Route Handlers
```typescript
export async function handlePostsAPI(
  req: NextRequest,
  cms: AutobloggerServer,
  session: Session | null,
  path: string
): Promise<Response> {
  // Check auth first
  const authError = requireAuth(session)
  if (authError) return authError

  // Route by method + path
  if (method === 'GET' && path === '/posts') {
    // ...
  }
}
```

### Response Format
```typescript
// Success
return jsonResponse({ data: result })

// Error
return jsonResponse({ error: 'Message' }, 400)
```

## AI/Streaming

### SSE Format
```typescript
// Send data
controller.enqueue(encoder.encode(`data: ${JSON.stringify({ text })}\n\n`))

// End stream
controller.enqueue(encoder.encode('data: [DONE]\n\n'))
```

### Safe Stream Helpers
```typescript
// Always use safe helpers to handle closed controllers
function safeEnqueue(controller, data): boolean {
  try {
    controller.enqueue(data)
    return true
  } catch {
    return false // Controller closed
  }
}
```

## Destinations

### Adapter Pattern
```typescript
const destination: Destination = {
  name: 'my-destination',
  
  async onPublish(post) {
    // Create or update in external system
    return { success: true, externalId: 'doc-123' }
  },
  
  async onUnpublish(post) {
    // Archive or unpublish
    return { success: true }
  },
  
  async onDelete(post) {
    // Remove from external system
    return { success: true }
  },
}
```

### Fire-and-Forget
- Destination calls should not block the main response
- Use `.catch()` to log errors without throwing:
```typescript
dispatcher.publish(post).catch(err => {
  console.error('[autoblogger] Failed to dispatch:', err)
})
```

## Error Handling

### Console Logging
```typescript
// Use prefixes for log context
console.log('[Web Search] Fetching...')
console.error('[prismic:repo-name] Failed to sync:', error)
console.warn('[autoblogger] Feature not supported')
```

### Graceful Degradation
- AI features should work without all providers configured
- Web search failure should not block the response
- Destination failures should not block publishing

## Testing Locally

1. Make changes
2. `npm run build`
3. `yalc push`
4. In host app: verify behavior

## Common Gotchas

- **Hydration mismatches**: Use `immediatelyRender: false` for Tiptap
- **Prisma types**: Cast to `any` since we use host app's client
- **Dark mode**: Use `ab-dark:` not `dark:` (custom prefix)
- **SSE streams**: Always handle controller.close() errors
- **useEffect deps**: Include all referenced values to avoid stale closures

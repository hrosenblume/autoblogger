---
description: "‚ö†Ô∏è ALWAYS READ THIS FILE FIRST ‚Äî Contains critical git commands (g/p/pf) and coding conventions"
globs: ["**/*"]
alwaysApply: true
---

# Coding Rules

> üö® **READ THIS ENTIRE FILE AT THE START OF EVERY CONVERSATION.** This contains single-letter git commands (`g`, `p`, `pf`) that must be executed immediately when typed.

> ‚ö†Ô∏è **THIS FILE IS COMMITTED TO GIT.** Do not add sensitive data: no emails, URLs, passwords, API keys, or secrets. Use environment variable references instead.

## Code Organization

### Server vs Client Split
- `src/index.ts` exports server-safe code only (no React imports)
- `src/ui/index.ts` exports React components
- Never import React in server files
- Types in `types/config.ts` must be server-safe (no ComponentType, etc.)

### File Naming
- React components: PascalCase (`ChatPanel.tsx`)
- Utilities/hooks: camelCase (`useChat.ts`, `markdown.ts`)
- Types: Keep in `types/` folder, export from `types/index.ts`

## TypeScript

### Strict Mode
- Project uses strict TypeScript
- Avoid `any` ‚Äî use `unknown` with type guards when needed
- Prefer explicit return types on exported functions

### Type Patterns
```typescript
// For Prisma client passed via config (unknown to avoid peer dep issues)
const prisma = config.prisma as any

// For optional chaining with DB models
settings?.prismicEnabled ?? false

// For discriminated unions
type EditCommand = 
  | { type: 'replace_all'; markdown: string }
  | { type: 'replace_section'; find: string; replace: string }
```

## React Conventions

### Client Components
- Always add `'use client'` directive at top
- Use hooks from `react` directly, not re-exports

### State Management
- Local state for component-specific data
- Context for cross-component shared state (Dashboard, Chat)
- Avoid prop drilling more than 2 levels

### Event Handlers
```typescript
// Use useCallback for handlers passed to children
const handleSave = useCallback(async () => {
  // ...
}, [dependencies])

// Use refs to avoid re-creating callbacks
const saveRef = useRef(handleSave)
useEffect(() => { saveRef.current = handleSave }, [handleSave])
```

## Styling

### Tailwind with Dark Mode
- Use `ab-dark:` prefix for dark mode variants (custom plugin)
- Example: `bg-white ab-dark:bg-gray-900`

### Component Classes
```typescript
import { cn } from '../lib/cn'

// Use cn() for conditional classes
className={cn(
  'base-classes',
  active && 'active-classes',
  disabled && 'disabled-classes'
)}
```

### Mobile-First
- Default styles for mobile
- Use `md:` for desktop overrides
- Touch targets: minimum 44x44px (`min-w-[44px] min-h-[44px]`)

## API Patterns

### Route Handlers
```typescript
export async function handlePostsAPI(
  req: NextRequest,
  cms: AutobloggerServer,
  session: Session | null,
  path: string
): Promise<Response> {
  // Check auth first
  const authError = requireAuth(session)
  if (authError) return authError

  // Route by method + path
  if (method === 'GET' && path === '/posts') {
    // ...
  }
}
```

### Response Format
```typescript
// Success
return jsonResponse({ data: result })

// Error
return jsonResponse({ error: 'Message' }, 400)
```

## AI/Streaming

### SSE Format
```typescript
// Send data
controller.enqueue(encoder.encode(`data: ${JSON.stringify({ text })}\n\n`))

// End stream
controller.enqueue(encoder.encode('data: [DONE]\n\n'))
```

### Safe Stream Helpers
```typescript
// Always use safe helpers to handle closed controllers
function safeEnqueue(controller, data): boolean {
  try {
    controller.enqueue(data)
    return true
  } catch {
    return false // Controller closed
  }
}
```

## Destinations

### Adapter Pattern
```typescript
const destination: Destination = {
  name: 'my-destination',
  
  async onPublish(post) {
    return { success: true, externalId: 'doc-123' }
  },
  
  async onUnpublish(post) {
    return { success: true }
  },
  
  async onDelete(post) {
    return { success: true }
  },
}
```

### Fire-and-Forget
- Destination calls should not block the main response
- Use `.catch()` to log errors without throwing

## Error Handling

### Console Logging
```typescript
// Use prefixes for log context
console.log('[Web Search] Fetching...')
console.error('[prismic:repo-name] Failed to sync:', error)
console.warn('[autoblogger] Feature not supported')
```

### Graceful Degradation
- AI features should work without all providers configured
- Web search failure should not block the response
- Destination failures should not block publishing

## Do
- Keep components small and focused
- Use semantic HTML
- Handle loading and error states
- Check existing abstractions before creating new ones
- Use `immediatelyRender: false` for Tiptap (prevents hydration mismatch)
- Always handle SSE controller.close() errors

## Don't
- Don't import React in server files
- Don't use `dark:` prefix (use `ab-dark:` instead)
- Don't block on destination failures
- Don't hardcode API keys or secrets
- Don't use inline styles
- Don't duplicate code ‚Äî abstract to lib/

## Git Workflow

> ‚ö†Ô∏è **CRITICAL: Single-letter commands are git workflow triggers.** When the user types just `g`, `p`, or `pf` ‚Äî that IS a command. Execute immediately. Don't interpret as casual chat.

| Command | Action |
|---------|--------|
| `g` | Commit all changes ‚Üí push to `main` |
| `p` | Pull current branch |
| `pf` | Force reset to `origin/main` |
| `rebuild` | Rebuild and push to yalc |

### When user types "g" (commit + push)
1. `git status -sb` ‚Äî review untracked files, never auto-add `.env*`, `*.save`, `*.bak`
2. `git add -u` (tracked files only) or selectively add new files
3. `git diff --staged --stat` ‚Äî review what's being committed
4. Read modified files for context
5. Review chat history for context
6. **Update `.cursor/rules/` if significant changes were made:**
   - `rules.mdc` ‚Äî New conventions, patterns, do's/don'ts
   - `context.mdc` ‚Äî New systems, architecture, file structure
7. Commit with comprehensive message
8. `git push origin main`

### When user types "p" (pull)
1. `git stash` ‚Äî save local changes
2. `git pull --rebase origin main`
3. `git stash pop` ‚Äî restore local changes

### When user types "pf" (force reset)
1. `git stash` ‚Äî save local changes
2. `git fetch origin main`
3. `git reset --hard origin/main`

Changes preserved in stash (`git stash list` to see, `git stash pop` to restore)

### When user types "rebuild"
Rebuild package and push to yalc for local testing:
1. `npm run build`
2. `yalc push`

## Terminal Commands
Before running dev servers or long-running processes:
1. Check terminals folder if already running
2. Let user manage existing terminals
3. Don't start conflicting sandboxed commands

## Common Gotchas

- **Hydration mismatches**: Use `immediatelyRender: false` for Tiptap
- **Prisma types**: Cast to `any` since we use host app's client
- **Dark mode**: Use `ab-dark:` not `dark:` (custom prefix)
- **SSE streams**: Always handle controller.close() errors
- **useEffect deps**: Include all referenced values to avoid stale closures

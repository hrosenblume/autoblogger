# Coding Rules

> üö® **READ THIS ENTIRE FILE AT THE START OF EVERY CONVERSATION.** This contains single-letter git commands (`g`, `d`, `m`, `p`, `pf`) that must be executed immediately when typed.

> ‚ö†Ô∏è **THIS FILE IS COMMITTED TO GIT.** Do not add sensitive data: no emails, URLs, passwords, API keys, or secrets.

## Code Style

### TypeScript
- Use strict mode
- Prefer explicit types over `any` (cast to `any` only when necessary for Prisma or Tiptap internals)
- Export types from `src/types.ts` for public API
- Internal types stay in their respective files
- Use `unknown` for Prisma client in config (avoid direct dependency)

### React Components
- Functional components only
- All UI components are client-side (`'use client'` added by tsup banner)
- Use `useCallback` and `useMemo` for performance-critical operations
- Props interfaces defined inline or in same file
- Use `cn()` utility from `src/lib/cn.ts` for conditional classes
- Prefer `useState` + `useEffect` over `useReducer` for simple state

### Styling
- Use Tailwind CSS exclusively
- Dark mode: Use `dark:` prefix (relies on host app's theme)
- Use semantic color tokens: `bg-popover`, `text-muted-foreground`, `border-border`, etc.
- Mobile-first: Use responsive prefixes (`md:`, `lg:`) for desktop overrides
- Touch targets: `min-h-[44px] md:min-h-0` for mobile-friendly buttons

### Dropdown Menus (Consistent Pattern)
- Container: `bg-popover border border-border rounded-md shadow-lg p-1`
- Items: `w-full px-3 py-2.5 md:px-2 md:py-1.5 min-h-[44px] md:min-h-0 text-left text-sm rounded-sm hover:bg-accent cursor-default`
- Destructive: Add `text-destructive` class
- Separator: `<div className="h-px bg-border my-1" />`

### Toolbar Buttons
- Use `ToolbarButton` component from `toolbar/ToolbarButton.tsx`
- Consistent sizing: `px-2.5 py-1.5`
- Active state: `bg-gray-100 dark:bg-gray-800`
- Skeleton: Use `SkeletonButton` for loading states

## Package Architecture

### Layer Separation
| Layer | Location | Purpose |
|----|----|---|
| Data | `src/data/` | Prisma queries, CRUD operations |
| API | `src/api/` | HTTP handlers, request/response |
| UI | `src/ui/` | React components, hooks, pages |
| AI | `src/ai/` | LLM providers, prompts, streaming |
| Lib | `src/lib/` | Utilities, shared helpers |

### Export Structure
- `autoblogger` ‚Äî Server-side: data layer, API handlers, utilities
- `autoblogger/ui` ‚Äî Client-side: React components, hooks
- `autoblogger/styles/article` ‚Äî Article layout utilities
- `autoblogger/markdown` ‚Äî Markdown parsing
- `autoblogger/seo` ‚Äî SEO utilities

### File Conventions
- Data layer files match entity names: `posts.ts`, `revisions.ts`, `comments.ts`
- API handlers: one file per resource with all CRUD operations
- UI pages: `WriterDashboard.tsx`, `EditorPage.tsx`, `SettingsPage.tsx`
- Hooks: `use*.ts` pattern in `src/ui/hooks/`
- Toolbar: Split into `FormatButtons`, `BlockButtons`, `MediaButtons`, `HistoryButtons`

## API Handlers

Pattern for all API handlers:
```typescript
export async function handleResourceAPI(
  req: NextRequest,
  cms: AutobloggerServer,
  session: Session | null,
  path: string,
  onMutate?: (type: string, data: unknown) => Promise<void>
): Promise<Response>
```

### Conventions
- Use `jsonResponse(data, status)` helper
- Check `cms.config.auth.isAdmin(session)` for protected routes
- Call `onMutate` after successful mutations for cache invalidation
- Return proper status codes: 200, 201, 400, 401, 403, 404, 405
- Parse path with `path.split('/').filter(Boolean)` to extract segments

## Data Layer

Pattern for data classes:
```typescript
export function createResourceData(prisma: any) {
  return {
    findAll: async (options?) => { ... },
    findById: async (id) => { ... },
    create: async (data) => { ... },
    update: async (id, data) => { ... },
    delete: async (id) => { ... },
    count: async (where?) => { ... },
  }
}
```

### Conventions
- Always include `orderBy` for list queries
- Support pagination: `skip`, `take` options
- Include related data via Prisma `include`
- Use `_count` for counting relations
- Soft delete for posts (`status: 'deleted'`)

## UI Components

### Context
- `DashboardProvider` wraps all UI and provides:
  - `navigate(path)` ‚Äî Internal SPA navigation
  - `goBack()` ‚Äî Magic back (history or root)
  - `apiBasePath` ‚Äî Base URL for API calls
  - `sharedData` ‚Äî Preloaded counts and settings
  - `session` ‚Äî Current user info
  - `onEditorStateChange` ‚Äî Callback for parent app integration
  - `onRegisterEditHandler` ‚Äî For AI agent edit commands

### Pages
- `WriterDashboard` ‚Äî Post list, AI generation textarea, tabs
- `EditorPage` ‚Äî Tiptap editor, toolbar, metadata, comments
- `SettingsPage` ‚Äî Admin settings sub-pages (users, ai, tags, etc.)

### Settings Sub-Pages Pattern
Each settings section follows this pattern:
1. Header with `text-lg font-semibold` title
2. Card container: `rounded-lg border bg-card shadow-sm` (for AI settings)
3. Table for lists: desktop `hidden md:block`, mobile `md:hidden` with cards
4. Dropdown menus for actions

### Loading States
- Use skeleton animations: `bg-muted rounded animate-pulse`
- Match skeleton shapes to actual content
- Show loading state while `sharedDataLoading` is true

## Editor System

### Tiptap Configuration
- Extensions: StarterKit, Placeholder, Link, Image, CommentMark
- Use `immediatelyRender: false` to prevent SSR hydration mismatch
- Convert markdown ‚Üî HTML with `renderMarkdown()` and `htmlToMarkdown()`
- Handle selection changes for comment highlighting

### Comment Mark Extension
- Custom Tiptap Mark at `src/lib/comment-mark.ts`
- Stores `commentId` as attribute
- Yellow highlight styling
- Click handler opens comment panel

### Revision System
- Fetch revisions on dropdown open
- Preview shows revision content without saving
- Restore saves the preview as current content
- Store original post state during preview for cancel

## Don't
- Don't use inline styles
- Don't hardcode URLs or paths (use context)
- Don't import from host app directly
- Don't create new dropdown patterns (use established classes)
- Don't use document selectors for modals (use React portals)
- Don't forget `'use client'` for hooks

## Do
- Keep components focused and reusable
- Handle loading states with skeletons
- Support both light and dark themes
- Test on mobile (44px touch targets)
- Run `npm run build` before committing
- Use `cn()` for conditional class names
- Clean up event listeners in useEffect
- Use portals for dropdowns that need to escape overflow

## Git Workflow

> ‚ö†Ô∏è **CRITICAL: Single-letter commands are git workflow triggers.** When the user types just `g`, `d`, `m`, `p`, or `pf` ‚Äî that IS a command. Execute immediately. Don't interpret as casual chat.

| Command | Action |
|---|-----|
| `g` | Production commit ‚Üí push to `main` |
| `d` | Dev commit ‚Üí push to `dev` |
| `m` | Merge `dev` ‚Üí `main` |
| `p` | Pull current branch |
| `pf` | Force reset to `origin/main` |

> ‚ö†Ô∏è **NEVER push to `main` automatically.** Only push to main when the user EXPLICITLY types "g". After making changes or fixes, commit to `dev` only and WAIT for the user to type "g" before touching main.

### When user types "d" (dev commit)
1. `git status -sb` first ‚Äî review untracked files (`??`), never auto-add `.env*`, `*.save`, `*.bak`
2. `git add -u` (tracked files only) or selectively add, then `git diff --staged --stat`
3. Read modified files for context
4. Review chat history
5. Commit with descriptive message summarizing changes
6. Push to `dev` branch

### When user types "g" (production commit)
**ONLY run this when the user EXPLICITLY types "g".** Never auto-push to main after making fixes.

If on `dev` or another branch:
1. `git stash` (if uncommitted changes)
2. `git checkout main`
3. `git merge dev` (or current branch)
4. Continue with steps below, then `git checkout dev` to return

Steps:
1. **Run `npm run build`** ‚Äî catches TypeScript errors before they fail
2. `git status -sb` ‚Äî review untracked files (`??`), never auto-add `.env*`, `*.save`, `*.bak`
3. `git add -u` (tracked files only) or selectively add, then `git diff --staged --stat`
4. Read modified files for context
5. Review chat history
6. **Update `.cursor/rules/` if significant changes were made:**
   - `rules.mdc` ‚Äî New conventions, patterns, do's/don'ts
   - `context.mdc` ‚Äî New systems, architecture, file structure
7. Commit with comprehensive message
8. `git push origin main`
9. If started on another branch: `git checkout dev && git stash pop`

### When user types "m" (merge dev ‚Üí prod)
1. `git fetch origin && git log --oneline main..dev` to see what's being promoted
2. Review the diff: `git diff main..dev --stat`
3. Review chat history for context on what was built/changed
4. **Update `.cursor/rules/` if significant changes were made**
5. If docs updated: commit on `dev` first, push to `dev`
6. Merge dev into main: `git checkout main && git merge dev`
7. Push to `main`
8. Return to dev branch: `git checkout dev`

### When user types "p" (pull current branch)
1. `git stash` ‚Äî save local changes
2. `git pull origin $(git branch --show-current)`
3. `git stash pop` ‚Äî restore local changes

### When user types "pf" (force reset to main)
1. `git stash` ‚Äî save local changes
2. `git fetch origin main`
3. `git reset --hard origin/main`

Changes are preserved in stash (`git stash list` to see, `git stash pop` to restore)

## Build & Test

Before committing:
1. `npm run build` ‚Äî TypeScript compilation + bundling
2. Check for type errors in output
3. Test in host app if making UI changes

After changes to autoblogger, rebuild in host app:
```bash
# In blog repo
npm run dev # Will pick up linked package changes
```

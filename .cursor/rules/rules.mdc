<critical>
SINGLE-LETTER GIT COMMANDS — EXECUTE IMMEDIATELY

When user types ONLY `g`, `d`, `m`, `p`, or `pf` — THIS IS A COMMAND. EXECUTE NOW.
DO NOT interpret as chat. DO NOT ask questions. DO NOT say "Great!" or "Sure!".
RUN THE WORKFLOW IMMEDIATELY.
</critical>

<git_commands priority="highest">
<command name="g" action="production commit and push">
ONLY run when user EXPLICITLY types `g`. Pushes to main.

1. `npm run build` — TypeScript must pass
2. `git status -sb` — check untracked files
   NEVER auto-add: .env*, *.save, *.bak, credentials, secrets
3. `git add -u` — tracked files only
4. `git diff --staged --stat`
5. READ modified files for context
6. READ chat history for intent
7. Update .cursor/rules/ if significant changes
8. Commit with HEREDOC format (see below)
9. `git push origin main`

If on dev branch:
1. `git stash` (if uncommitted)
2. `git checkout main && git merge dev`
3. Run steps above
4. `git checkout dev && git stash pop`
</command>

<command name="d" action="dev commit and push">
Commits to dev branch ONLY. NEVER touch main.

1. `git status -sb` — check untracked files
   NEVER auto-add: .env*, *.save, *.bak, credentials, secrets
2. `git add -u` — tracked files only
3. `git diff --staged --stat`
4. READ modified files for context
5. READ chat history for intent
6. Commit with HEREDOC format
7. `git push origin dev`
</command>

<command name="m" action="merge dev into main">
1. `git fetch origin`
2. `git log --oneline main..dev` — see commits
3. `git diff main..dev --stat`
4. READ chat history for context
5. Update .cursor/rules/ if needed (commit to dev first)
6. `git checkout main && git merge dev`
7. `git push origin main`
8. `git checkout dev`
</command>

<command name="p" action="pull current branch">
1. `git stash`
2. `git pull origin $(git branch --show-current)`
3. `git stash pop`
</command>

<command name="pf" action="force reset to origin/main">
1. `git stash` — changes saved in stash
2. `git fetch origin main`
3. `git reset --hard origin/main`
</command>

<commit_format>
Always use HEREDOC for commit messages:

```bash
git commit -m "$(cat &lt;&lt;'EOF'
type: short summary

- Detail one
- Detail two

EOF
)"
```
</commit_format>

<package_lock_conflicts>
Don't manually edit lockfile conflicts. Instead:
```bash
git checkout --theirs package-lock.json
npm install
```
</package_lock_conflicts>
</git_commands>

<warning>
NEVER push to main automatically.
Only `g` pushes to main.
After making fixes, use `d` and WAIT for user to type `g`.
</warning>

---

<security>
THIS FILE IS COMMITTED TO GIT.
Do not add: emails, URLs, passwords, API keys, secrets.
</security>

<code_style>
<typescript>
- Use strict mode
- Prefer explicit types over `any`
- Export types from `src/types.ts` for public API
- Internal types stay in their respective files
- Use `unknown` for Prisma client in config
</typescript>

<react>
- Functional components only
- All UI components are client-side (`'use client'` added by tsup)
- Use `useCallback` and `useMemo` for performance
- Use `cn()` utility for conditional classes
- Prefer `useState` + `useEffect` over `useReducer`
</react>

<styling>
- Tailwind CSS exclusively
- Dark mode: `dark:` prefix
- Semantic tokens: `bg-popover`, `text-muted-foreground`, `border-border`
- Skeletons: `bg-muted` (never hardcode `bg-gray-200 dark:bg-gray-800`)
- Mobile-first with `md:`, `lg:` for desktop
- Touch targets: `min-h-[44px] md:min-h-0`
</styling>

<dropdowns>
Container: `bg-popover border border-border rounded-md shadow-lg p-1`
Items: `w-full px-3 py-2.5 md:px-2 md:py-1.5 min-h-[44px] md:min-h-0 text-left text-sm rounded-sm hover:bg-accent cursor-default`
Destructive: `text-destructive`
Separator: `h-px bg-border my-1`
</dropdowns>

<toolbar_buttons>
- Use `ToolbarButton` from `toolbar/ToolbarButton.tsx`
- Sizing: `px-2.5 py-1.5`
- Active: `bg-accent text-accent-foreground`
- Skeleton: `SkeletonButton` from `Skeleton.tsx`
</toolbar_buttons>

<skeletons>
- Import from `../components/Skeleton`
- Variants: `Skeleton`, `SkeletonText`, `SkeletonButton`, `SkeletonCard`, `SkeletonTableRow`
- All use `bg-muted` for light/dark support
- NEVER use inline `bg-muted rounded animate-pulse`
</skeletons>
</code_style>

<architecture>
<layers>
| Layer | Location | Purpose |
|-------|----------|---------|
| CLI | src/cli/ | Setup wizard, content import |
| Data | src/data/ | Prisma queries, CRUD |
| API | src/api/ | HTTP handlers |
| UI | src/ui/ | React components, hooks, pages |
| AI | src/ai/ | LLM providers, prompts, streaming |
| Auto-Draft | src/auto-draft/ | RSS, keywords, draft generation |
| Lib | src/lib/ | Utilities, helpers |
</layers>

<exports>
- `autoblogger` — Server: data layer, API, auto-draft
- `autoblogger/ui` — Client: React dashboard, ChatProvider
- `autoblogger/styles/article` — Article layout
- `autoblogger/markdown` — renderMarkdown, htmlToMarkdown
- `autoblogger/seo` — getSeoValues
</exports>

<file_conventions>
- Data layer: `posts.ts`, `revisions.ts`, `comments.ts`
- API: one file per resource
- Pages: `WriterDashboard.tsx`, `EditorPage.tsx`, `SettingsPage.tsx`
- Hooks: `use*.ts` in `src/ui/hooks/`
- Toolbar: `FormatButtons`, `BlockButtons`, `MediaButtons`, `HistoryButtons`
</file_conventions>
</architecture>

<api_handlers>
```typescript
export async function handleResourceAPI(
  req: NextRequest,
  cms: AutobloggerServer,
  session: Session | null,
  path: string,
  onMutate?: (type: string, data: unknown) => Promise&lt;void&gt;
): Promise&lt;Response&gt;
```

- Use `jsonResponse(data, status)` helper
- Check `cms.config.auth.isAdmin(session)` for protected routes
- Call `onMutate` after mutations for cache invalidation
- Status codes: 200, 201, 400, 401, 403, 404, 405
</api_handlers>

<cli_development>
- `picocolors` for colored output
- `prompts` for interactive questions
- `log(type, message)` helper: check, write, skip, warn, error, info, run, backup
- Support `--dry-run` and `--yes` flags
- Create backups before modifying files
- `detectProject()` — Find Next.js, Prisma, Tailwind
- `checkConflicts()` — Detect Prisma model conflicts
</cli_development>

<data_layer>
```typescript
export function createResourceData(prisma: any) {
  return {
    findAll: async (options?) => { ... },
    findById: async (id) => { ... },
    create: async (data) => { ... },
    update: async (id, data) => { ... },
    delete: async (id) => { ... },
    count: async (where?) => { ... },
  }
}
```

- Always include `orderBy` for lists
- Support pagination: `skip`, `take`
- Include related data via Prisma `include`
- Soft delete for posts (`status: 'deleted'`)
</data_layer>

<ui_components>
<dashboard_provider>
- `navigate(path)` — SPA navigation
- `goBack()` — Magic back
- `apiBasePath` — Base URL for API
- `sharedData` — Preloaded counts, settings, posts
- `session` — Current user
- `onEditorStateChange` — Parent app callback
</dashboard_provider>

<chat_provider>
- `messages` — Chat history
- `essayContext` — Current essay state
- `mode` — ask, agent, plan, search
- `sendMessage(content)` — Send and stream
- `registerEditHandler` — Agent mode edits
- `registerExpandPlanHandler` — Plan expansion
</chat_provider>

<chat_modes>
- `ask` — Q&A about content
- `agent` — Direct editing, outputs `:::edit` JSON blocks
- `plan` — Outlines in `&lt;plan&gt;` tags
- `search` — Research mode
</chat_modes>

<loading_states>
Use `&lt;Skeleton&gt;` component, match shapes to content.
Show loading while `sharedDataLoading` is true.
</loading_states>
</ui_components>

<editor_system>
<tiptap>
- Extensions: StarterKit, Placeholder, Link, Image, CommentMark
- `immediatelyRender: false` for SSR
- Convert with `renderMarkdown()` and `htmlToMarkdown()`
</tiptap>

<comment_mark>
- Custom Mark at `src/lib/comment-mark.ts`
- Stores `commentId` attribute
- Yellow highlight, click opens panel
</comment_mark>

<revisions>
- Fetch on dropdown open
- Preview without saving
- Store original for cancel
</revisions>
</editor_system>

<url_extraction>
- `extractAndFetchUrls(text)` — Detect and fetch URLs
- Puppeteer for JS-rendered, fetch fallback
- `buildUrlContext(fetched)` — XML context for prompts
- Max 3 URLs, truncate to ~4000 chars
- Auto-detect serverless vs local for Puppeteer
</url_extraction>

<do_not>
- Use inline styles
- Hardcode URLs or paths
- Import from host app directly
- Create new dropdown patterns
- Use document selectors for modals
- Forget `'use client'` for hooks
</do_not>

<do>
- Keep components focused and reusable
- Handle loading states with skeletons
- Support light and dark themes
- Test on mobile (44px touch targets)
- Run `npm run build` before committing
- Use `cn()` for conditional classes
- Clean up event listeners in useEffect
- Use portals for overflow-escaping dropdowns
</do>

<host_app_checklist>
1. CSS Import: `@import 'autoblogger/styles/standalone.css';` (includes all Tailwind utilities)
2. No Tailwind config needed — standalone CSS works with any setup
3. ChatMessage Model in Prisma schema
4. Re-run `npm link autoblogger` after `npm install`
5. Run `npm run build` after source changes
6. Writer route: `app/(writer)/writer/[[...path]]/page.tsx` (isolated from parent layouts)
</host_app_checklist>

<build_and_test>
Before committing:
1. `npm run build` — TypeScript + bundling
2. Check for type errors
3. Test in linked host apps for UI changes

Linked projects:
- /Users/hunter/Local Documents/Code/sample-blog
- /Users/hunter/Local Documents/Code/blog

If npm install breaks link: `npm link autoblogger`
</build_and_test>

# Coding Rules

> üö®üö®üö® **CRITICAL: SINGLE-LETTER GIT COMMANDS** üö®üö®üö®
> 
> When the user types ONLY `g`, `d`, `m`, `p`, or `pf` ‚Äî **EXECUTE THE GIT WORKFLOW IMMEDIATELY.**
> 
> | Command | Action |
> |---------|--------|
> | `g` | Build ‚Üí commit ‚Üí push to `main` |
> | `d` | Commit ‚Üí push to `dev` |
> | `m` | Merge `dev` ‚Üí `main` |
> | `p` | Pull current branch |
> | `pf` | Force reset to `origin/main` |
> 
> **DO NOT** interpret these as casual chat. **DO NOT** respond with "Great!" or similar.
> **DO** run the git commands as specified in the Git Workflow section below.

> ‚ö†Ô∏è **THIS FILE IS COMMITTED TO GIT.** Do not add sensitive data: no emails, URLs, passwords, API keys, or secrets.

## Code Style

### TypeScript
- Use strict mode
- Prefer explicit types over `any` (cast to `any` only when necessary for Prisma or Tiptap internals)
- Export types from `src/types.ts` for public API
- Internal types stay in their respective files
- Use `unknown` for Prisma client in config (avoid direct dependency)

### React Components
- Functional components only
- All UI components are client-side (`'use client'` added by tsup banner)
- Use `useCallback` and `useMemo` for performance-critical operations
- Props interfaces defined inline or in same file
- Use `cn()` utility from `src/lib/cn.ts` for conditional classes
- Prefer `useState` + `useEffect` over `useReducer` for simple state

### Styling
- Use Tailwind CSS exclusively
- Dark mode: Use `dark:` prefix (relies on host app's theme)
- Use semantic color tokens: `bg-popover`, `text-muted-foreground`, `border-border`, etc.
- Mobile-first: Use responsive prefixes (`md:`, `lg:`) for desktop overrides
- Touch targets: `min-h-[44px] md:min-h-0` for mobile-friendly buttons

### Dropdown Menus (Consistent Pattern)
- Container: `bg-popover border border-border rounded-md shadow-lg p-1`
- Items: `w-full px-3 py-2.5 md:px-2 md:py-1.5 min-h-[44px] md:min-h-0 text-left text-sm rounded-sm hover:bg-accent cursor-default`
- Destructive: Add `text-destructive` class
- Separator: `<div className="h-px bg-border my-1" />`

### Toolbar Buttons
- Use `ToolbarButton` component from `toolbar/ToolbarButton.tsx`
- Consistent sizing: `px-2.5 py-1.5`
- Active state: `bg-gray-100 dark:bg-gray-800`
- Skeleton: Use `SkeletonButton` for loading states

## Package Architecture

### Layer Separation
| Layer | Location | Purpose |
|----|----|---|
| CLI | `src/cli/` | Setup wizard, content import |
| Data | `src/data/` | Prisma queries, CRUD operations |
| API | `src/api/` | HTTP handlers, request/response |
| UI | `src/ui/` | React components, hooks, pages |
| AI | `src/ai/` | LLM providers, prompts, streaming |
| Auto-Draft | `src/auto-draft/` | RSS fetching, keyword filtering, draft generation |
| Lib | `src/lib/` | Utilities, shared helpers |

### Export Structure
- `autoblogger` ‚Äî Server-side: data layer, API handlers, utilities, auto-draft
- `autoblogger/ui` ‚Äî Client-side: React dashboard, ChatProvider, hooks
- `autoblogger/styles/article` ‚Äî Article layout utilities
- `autoblogger/markdown` ‚Äî Markdown parsing (renderMarkdown, htmlToMarkdown, markdownToHtml)
- `autoblogger/seo` ‚Äî SEO utilities (getSeoValues)

### File Conventions
- Data layer files match entity names: `posts.ts`, `revisions.ts`, `comments.ts`
- API handlers: one file per resource with all CRUD operations
- UI pages: `WriterDashboard.tsx`, `EditorPage.tsx`, `SettingsPage.tsx`
- Hooks: `use*.ts` pattern in `src/ui/hooks/`
- Toolbar: Split into `FormatButtons`, `BlockButtons`, `MediaButtons`, `HistoryButtons`

## API Handlers

Pattern for all API handlers:
```typescript
export async function handleResourceAPI(
  req: NextRequest,
  cms: AutobloggerServer,
  session: Session | null,
  path: string,
  onMutate?: (type: string, data: unknown) => Promise<void>
): Promise<Response>
```

### Conventions
- Use `jsonResponse(data, status)` helper
- Check `cms.config.auth.isAdmin(session)` for protected routes
- Call `onMutate` after successful mutations for cache invalidation
- Return proper status codes: 200, 201, 400, 401, 403, 404, 405
- Parse path with `path.split('/').filter(Boolean)` to extract segments

## CLI Development

### Conventions
- Use `picocolors` for colored output (lightweight, no dependencies)
- Use `prompts` for interactive questions
- Log with `log(type, message)` helper: `check`, `write`, `skip`, `warn`, `error`, `info`, `run`, `backup`
- Support `--dry-run` flag to preview changes
- Support `--yes` flag for non-interactive mode
- Create backups before modifying existing files

### File Operations
- Use Node.js `fs` and `path` modules directly
- Check file existence before writing
- Use `execSync` for running shell commands with `stdio: 'inherit'`
- Clean up temporary files in `finally` blocks

### Detection Utilities
- `detectProject()` ‚Äî Find Next.js version, Prisma schema, Tailwind config
- `checkConflicts()` ‚Äî Detect model name conflicts in Prisma schema
- `countMarkdownFiles()` ‚Äî Count importable content

## Data Layer

Pattern for data classes:
```typescript
export function createResourceData(prisma: any) {
  return {
    findAll: async (options?) => { ... },
    findById: async (id) => { ... },
    create: async (data) => { ... },
    update: async (id, data) => { ... },
    delete: async (id) => { ... },
    count: async (where?) => { ... },
  }
}
```

### Conventions
- Always include `orderBy` for list queries
- Support pagination: `skip`, `take` options
- Include related data via Prisma `include`
- Use `_count` for counting relations
- Soft delete for posts (`status: 'deleted'`)

## UI Components

### Context
- `DashboardProvider` wraps all UI and provides:
  - `navigate(path)` ‚Äî Internal SPA navigation
  - `goBack()` ‚Äî Magic back (history or root)
  - `apiBasePath` ‚Äî Base URL for API calls
  - `sharedData` ‚Äî Preloaded counts, settings, posts, aiSettings
  - `session` ‚Äî Current user info
  - `onEditorStateChange` ‚Äî Callback for parent app integration
  - `onRegisterEditHandler` ‚Äî For AI agent edit commands

- `ChatProvider` wraps DashboardProvider and provides:
  - `messages` ‚Äî Chat history
  - `essayContext` ‚Äî Current essay state (synced from editor)
  - `mode` ‚Äî Current chat mode (ask, agent, plan, search)
  - `sendMessage(content)` ‚Äî Send message and stream response
  - `registerEditHandler` ‚Äî Register callback for agent mode edits
  - `registerExpandPlanHandler` ‚Äî Register callback for plan expansion

### Pages
- `WriterDashboard` ‚Äî Post list, AI generation textarea, tabs
- `EditorPage` ‚Äî Tiptap editor, toolbar, metadata, comments
- `SettingsPage` ‚Äî Admin settings sub-pages (users, ai, tags, etc.)

### Settings Sub-Pages Pattern
Each settings section follows this pattern:
1. Header with `text-lg font-semibold` title
2. Card container: `rounded-lg border bg-card shadow-sm` (for AI settings)
3. Table for lists: desktop `hidden md:block`, mobile `md:hidden` with cards
4. Dropdown menus for actions

### Loading States
- Use skeleton animations: `bg-muted rounded animate-pulse`
- Match skeleton shapes to actual content
- Show loading state while `sharedDataLoading` is true

## Editor System

### Tiptap Configuration
- Extensions: StarterKit, Placeholder, Link, Image, CommentMark
- Use `immediatelyRender: false` to prevent SSR hydration mismatch
- Convert markdown ‚Üî HTML with `renderMarkdown()` and `htmlToMarkdown()`
- Handle selection changes for comment highlighting

### Comment Mark Extension
- Custom Tiptap Mark at `src/lib/comment-mark.ts`
- Stores `commentId` as attribute
- Yellow highlight styling
- Click handler opens comment panel

### Revision System
- Fetch revisions on dropdown open
- Preview shows revision content without saving
- Restore saves the preview as current content
- Store original post state during preview for cancel

## Chat System

### ChatProvider (`src/ui/hooks/useChat.tsx`)
Wraps dashboard and provides chat context for all components.

Props:
- `apiBasePath` ‚Äî Base API path (default: `/api/cms`)
- `chatApiPath` ‚Äî Custom chat endpoint (default: `${apiBasePath}/ai/chat`)
- `historyApiPath` ‚Äî History persistence endpoint (default: `/api/chat/history`)

### Chat Modes
- `ask` ‚Äî Default mode, answers questions about content
- `agent` ‚Äî Direct editing mode, AI outputs `:::edit` JSON blocks
- `plan` ‚Äî Outline mode, generates plans in `<plan>` tags
- `search` ‚Äî Research mode for fact-finding

### Chat Context Values
```typescript
{
  messages, essayContext, isStreaming, isOpen, mode,
  webSearchEnabled, thinkingEnabled, selectedModel,
  sendMessage, stopStreaming, addMessage, clearMessages,
  setMode, setWebSearchEnabled, setThinkingEnabled,
  registerEditHandler, undoEdit, expandPlan
}
```

### Agent Mode Edit Parsing
Edit blocks are parsed from assistant responses:
```
:::edit
{"type": "replace_section", "find": "...", "replace": "..."}
:::
```

The `registerEditHandler` callback is called for each edit. EditorPage registers a handler that updates post state.

### Plan Mode
- Output is cleaned by extracting from `<plan>` tags
- "Draft Essay" button triggers `expandPlan()` which calls the registered `ExpandPlanHandler`
- If on editor page, expands in place; otherwise navigates to `/editor?fromPlan=1`

## URL Content Extraction

For AI prompts that reference URLs:
- Use `extractAndFetchUrls(text)` to detect and fetch URLs from user input
- URLs are detected with/without protocol (https://, www., bare domains)
- Content is fetched with Puppeteer (JS-rendered) or simple fetch (fallback)
- Use `buildUrlContext(fetched)` to create XML-formatted context for prompts
- Limit to 3 URLs max per request
- Content is truncated to ~4000 chars to avoid token bloat

### Puppeteer Configuration
- Auto-detects serverless (Vercel/Lambda) vs local environment
- Serverless: Uses `@sparticuz/chromium` + `puppeteer-core`
- Local: Uses regular `puppeteer` with bundled Chrome
- Block images, stylesheets, fonts to speed up loading
- 15s timeout for page load, 2s wait for JS rendering

## Don't
- Don't use inline styles
- Don't hardcode URLs or paths (use context)
- Don't import from host app directly
- Don't create new dropdown patterns (use established classes)
- Don't use document selectors for modals (use React portals)
- Don't forget `'use client'` for hooks

## Do
- Keep components focused and reusable
- Handle loading states with skeletons
- Support both light and dark themes
- Test on mobile (44px touch targets)
- Run `npm run build` before committing
- Use `cn()` for conditional class names
- Clean up event listeners in useEffect
- Use portals for dropdowns that need to escape overflow

## Git Workflow

> ‚ö†Ô∏è **CRITICAL: Single-letter commands are git workflow triggers.** When the user types just `g`, `d`, `m`, `p`, or `pf` ‚Äî that IS a command. Execute immediately. Don't interpret as casual chat.

| Command | Action |
|---|-----|
| `g` | Production commit ‚Üí push to `main` |
| `d` | Dev commit ‚Üí push to `dev` |
| `m` | Merge `dev` ‚Üí `main` |
| `p` | Pull current branch |
| `pf` | Force reset to `origin/main` |

> ‚ö†Ô∏è **NEVER push to `main` automatically.** Only push to main when the user EXPLICITLY types "g". After making changes or fixes, commit to `dev` only and WAIT for the user to type "g" before touching main.

### When user types "d" (dev commit)
1. `git status -sb` first ‚Äî review untracked files (`??`), never auto-add `.env*`, `*.save`, `*.bak`
2. `git add -u` (tracked files only) or selectively add, then `git diff --staged --stat`
3. Read modified files for context
4. Review chat history
5. Commit with descriptive message summarizing changes
6. Push to `dev` branch

### When user types "g" (production commit)
**ONLY run this when the user EXPLICITLY types "g".** Never auto-push to main after making fixes.

If on `dev` or another branch:
1. `git stash` (if uncommitted changes)
2. `git checkout main`
3. `git merge dev` (or current branch)
4. Continue with steps below, then `git checkout dev` to return

Steps:
1. **Run `npm run build`** ‚Äî catches TypeScript errors before they fail
2. `git status -sb` ‚Äî review untracked files (`??`), never auto-add `.env*`, `*.save`, `*.bak`
3. `git add -u` (tracked files only) or selectively add, then `git diff --staged --stat`
4. Read modified files for context
5. Review chat history
6. **Update `.cursor/rules/` if significant changes were made:**
   - `rules.mdc` ‚Äî New conventions, patterns, do's/don'ts
   - `context.mdc` ‚Äî New systems, architecture, file structure
7. Commit with comprehensive message
8. `git push origin main`
9. If started on another branch: `git checkout dev && git stash pop`

### When user types "m" (merge dev ‚Üí prod)
1. `git fetch origin && git log --oneline main..dev` to see what's being promoted
2. Review the diff: `git diff main..dev --stat`
3. Review chat history for context on what was built/changed
4. **Update `.cursor/rules/` if significant changes were made**
5. If docs updated: commit on `dev` first, push to `dev`
6. Merge dev into main: `git checkout main && git merge dev`
7. Push to `main`
8. Return to dev branch: `git checkout dev`

### When user types "p" (pull current branch)
1. `git stash` ‚Äî save local changes
2. `git pull origin $(git branch --show-current)`
3. `git stash pop` ‚Äî restore local changes

### When user types "pf" (force reset to main)
1. `git stash` ‚Äî save local changes
2. `git fetch origin main`
3. `git reset --hard origin/main`

Changes are preserved in stash (`git stash list` to see, `git stash pop` to restore)

## Build & Test

Before committing:
1. `npm run build` ‚Äî TypeScript compilation + bundling
2. Check for type errors in output
3. Test in linked host apps if making UI changes

### Local Linking
Autoblogger is linked to test projects for development:
- `/Users/hunter/Local Documents/Code/sample-blog`
- `/Users/hunter/Local Documents/Code/blog`

After changes to autoblogger:
```bash
# In autoblogger directory
npm run build

# Changes are immediately reflected in linked projects
# Run the host app's dev server to test:
cd /Users/hunter/Local\ Documents/Code/sample-blog
npm run dev
```

If `npm install` breaks the link, restore with:
```bash
npm link autoblogger
```

{"version":3,"sources":["../src/index.ts","../src/destination.ts"],"sourcesContent":["export { prismicDestination } from './destination'\nexport type { PrismicDestinationConfig, FieldMapping } from './destination'\n","import type { Destination, DestinationResult, Post } from 'autoblogger'\nimport { markdownToPrismicRichText } from 'autoblogger/rich-text'\nimport * as prismic from '@prismicio/client'\n\n/**\n * Field mapping configuration for Prismic documents.\n * Maps autoblogger post fields to Prismic document fields.\n */\nexport interface FieldMapping {\n  /** Prismic field for the post title (default: 'title') */\n  title?: string\n  /** Prismic field for the post subtitle (default: 'subtitle') */\n  subtitle?: string\n  /** Prismic field for the post content/body as rich text (default: 'body') */\n  content?: string\n  /** Prismic field for the slug/UID (default: 'uid') - always maps to Prismic UID */\n  slug?: 'uid'\n  /** Prismic field for SEO title (default: 'seo_title') */\n  seoTitle?: string\n  /** Prismic field for SEO description (default: 'seo_description') */\n  seoDescription?: string\n  /** Prismic field for publish date (default: 'publish_date') */\n  publishDate?: string\n  /** Custom field mappings for user-defined fields */\n  custom?: Record<string, string>\n}\n\n/**\n * Configuration for the Prismic destination adapter.\n */\nexport interface PrismicDestinationConfig {\n  /** Prismic repository name (e.g., 'my-repo') */\n  repository: string\n  /** Prismic write API token (from Settings > API & Security) */\n  writeToken: string\n  /** Prismic document type to create (e.g., 'blog_post') */\n  documentType: string\n  /** \n   * Sync mode: \n   * - 'full' (default): Syncs all content including markdown body as rich text\n   * - 'stub': Syncs minimal reference data only (uid, title, autoblogger_id)\n   */\n  syncMode?: 'stub' | 'full'\n  /** Field mapping configuration (optional, uses defaults) - only used in 'full' mode */\n  fieldMapping?: FieldMapping\n  /** Master locale for the repository (default: 'en-us') */\n  masterLocale?: string\n  /** Whether to auto-publish documents after creating/updating (default: false) */\n  autoPublish?: boolean\n  /** Custom document ID resolver (optional, uses post.id by default) */\n  getDocumentId?: (post: Post) => string\n  /** \n   * Callback after successful Prismic sync.\n   * Use this to store the immutable Prismic document ID for resilient lookups.\n   * The prismicDocumentId is Prismic's internal ID which cannot be edited by users.\n   */\n  onSyncComplete?: (post: Post, prismicDocumentId: string) => Promise<void>\n  /**\n   * Callback to get existing mapping for a post.\n   * Used to determine if we should update an existing document or create a new one.\n   * Returns the Prismic document ID and last known slug, or null if no mapping exists.\n   */\n  getExistingMapping?: (postId: string) => Promise<{\n    prismicDocumentId: string\n    lastKnownSlug: string | null\n  } | null>\n}\n\nconst DEFAULT_FIELD_MAPPING: Required<Omit<FieldMapping, 'custom'>> = {\n  title: 'title',\n  subtitle: 'subtitle',\n  content: 'body',\n  slug: 'uid',\n  seoTitle: 'seo_title',\n  seoDescription: 'seo_description',\n  publishDate: 'publish_date',\n}\n\n/**\n * Create a Prismic Migration API client.\n */\nfunction createMigrationClient(config: PrismicDestinationConfig) {\n  const writeClient = prismic.createWriteClient(config.repository, {\n    writeToken: config.writeToken,\n  })\n  return writeClient\n}\n\n/**\n * Map an autoblogger post to a minimal stub document.\n * Used in 'stub' sync mode where content lives in autoblogger,\n * and Prismic only stores references for collection slices.\n */\nfunction mapPostToStub(post: Post): Record<string, unknown> {\n  return {\n    title: post.title,\n    autoblogger_id: post.id,\n  }\n}\n\n/**\n * Map an autoblogger post to full Prismic document data.\n * Used in 'full' sync mode where all content is synced to Prismic.\n */\nfunction mapPostToDocument(\n  post: Post,\n  fieldMapping: FieldMapping\n): Record<string, unknown> {\n  const mapping = { ...DEFAULT_FIELD_MAPPING, ...fieldMapping }\n  const data: Record<string, unknown> = {}\n\n  // Title as rich text (Prismic expects array)\n  if (mapping.title && post.title) {\n    data[mapping.title] = [{ type: 'heading1', text: post.title, spans: [] }]\n  }\n\n  // Subtitle as rich text\n  if (mapping.subtitle && post.subtitle) {\n    data[mapping.subtitle] = [{ type: 'paragraph', text: post.subtitle, spans: [] }]\n  }\n\n  // Content as rich text (converted from markdown)\n  if (mapping.content && post.markdown) {\n    data[mapping.content] = markdownToPrismicRichText(post.markdown)\n  }\n\n  // SEO fields as key text\n  if (mapping.seoTitle && post.seoTitle) {\n    data[mapping.seoTitle] = post.seoTitle\n  }\n\n  if (mapping.seoDescription && post.seoDescription) {\n    data[mapping.seoDescription] = post.seoDescription\n  }\n\n  // Publish date\n  if (mapping.publishDate && post.publishedAt) {\n    data[mapping.publishDate] = post.publishedAt.toISOString().split('T')[0]\n  }\n\n  // Custom field mappings\n  if (fieldMapping.custom) {\n    for (const [postField, prismicField] of Object.entries(fieldMapping.custom)) {\n      const value = (post as Record<string, unknown>)[postField]\n      if (value !== undefined && value !== null) {\n        data[prismicField] = value\n      }\n    }\n  }\n\n  return data\n}\n\n/**\n * Create a Prismic destination adapter for autoblogger.\n * \n * @example\n * ```ts\n * import { prismicDestination } from '@autoblogger/prismic'\n * \n * export const cms = createAutoblogger({\n *   prisma,\n *   auth: { ... },\n *   destinations: [\n *     prismicDestination({\n *       repository: 'my-repo',\n *       writeToken: process.env.PRISMIC_WRITE_TOKEN!,\n *       documentType: 'blog_post',\n *     })\n *   ]\n * })\n * ```\n */\nexport function prismicDestination(config: PrismicDestinationConfig): Destination {\n  const fieldMapping = config.fieldMapping || {}\n  const masterLocale = config.masterLocale || 'en-us'\n  const syncMode = config.syncMode || 'full'\n  const getDocumentId = config.getDocumentId || ((post: Post) => `autoblogger-${post.id}`)\n\n  return {\n    name: `prismic:${config.repository}`,\n\n    async onPublish(post: Post): Promise<DestinationResult> {\n      try {\n        const writeClient = createMigrationClient(config)\n        const readClient = prismic.createClient(config.repository)\n        const migration = prismic.createMigration()\n\n        const documentId = getDocumentId(post)\n        \n        // Use stub or full document data based on sync mode\n        const documentData = syncMode === 'stub' \n          ? mapPostToStub(post)\n          : mapPostToDocument(post, fieldMapping)\n\n        // Check if we have an existing mapping for this post\n        const existingMapping = config.getExistingMapping \n          ? await config.getExistingMapping(post.id)\n          : null\n\n        let prismicDocumentId: string | undefined\n        let existingDoc: any = null\n\n        // Try to find existing document either by mapping or by UID\n        if (existingMapping) {\n          // We have a mapping - fetch by document ID\n          try {\n            existingDoc = await readClient.getByID(existingMapping.prismicDocumentId)\n            prismicDocumentId = existingDoc?.id\n          } catch (fetchError) {\n            console.warn(\n              `[prismic:${config.repository}] Document not found by mapping ID, will check by UID:`,\n              fetchError instanceof Error ? fetchError.message : fetchError\n            )\n          }\n        }\n        \n        // If no mapping or mapping lookup failed, try to find by UID (handles pre-existing documents)\n        if (!existingDoc) {\n          try {\n            existingDoc = await readClient.getByUID(config.documentType, post.slug, {\n              lang: masterLocale,\n            })\n            prismicDocumentId = existingDoc?.id\n            console.log(`[prismic:${config.repository}] Found existing document by UID for post \"${post.slug}\"`)\n          } catch {\n            // Document doesn't exist by UID - will create new\n          }\n        }\n\n        // Track the migration document so we can get its ID after migration\n        let migrationDoc: any = null\n\n        if (existingDoc) {\n          // Update existing document with new data, UID, and title\n          const updatedDoc = {\n            ...existingDoc,\n            uid: post.slug, // Update UID if slug changed\n            data: {\n              ...existingDoc.data,\n              ...documentData, // Merge new data\n            },\n          }\n          \n          // Use updateDocument to update both the document and its display name\n          migration.updateDocument(updatedDoc as any, post.title)\n          console.log(`[prismic:${config.repository}] Updating existing document for post \"${post.slug}\"`)\n        } else {\n          // Create a new document\n          migrationDoc = migration.createDocument(\n            {\n              type: config.documentType,\n              uid: post.slug,\n              lang: masterLocale,\n              data: documentData,\n            },\n            post.title\n          )\n          console.log(`[prismic:${config.repository}] Creating new document for post \"${post.slug}\"`)\n        }\n\n        // Execute the migration\n        await writeClient.migrate(migration, {\n          reporter: () => {}, // Silent reporter\n        })\n\n        // After migration, get the document ID from the migration document\n        // The migration API sets doc.document.id after creation\n        if (config.onSyncComplete) {\n          // For new documents, get ID from migration doc\n          if (migrationDoc?.document?.id) {\n            prismicDocumentId = migrationDoc.document.id\n          }\n          \n          // Call the callback with the immutable Prismic document ID\n          if (prismicDocumentId) {\n            await config.onSyncComplete(post, prismicDocumentId)\n            console.log(`[prismic:${config.repository}] Stored mapping for document ID: ${prismicDocumentId}`)\n          } else {\n            console.warn(`[prismic:${config.repository}] Could not get document ID after sync`)\n          }\n        }\n\n        return {\n          success: true,\n          externalId: prismicDocumentId || documentId,\n        }\n      } catch (error) {\n        return {\n          success: false,\n          error: error instanceof Error ? error.message : 'Unknown error publishing to Prismic',\n        }\n      }\n    },\n\n    async onUnpublish(post: Post): Promise<DestinationResult> {\n      // Prismic Migration API doesn't support unpublishing directly\n      // The document will remain but won't be updated\n      // For full unpublish support, use the Document API directly\n      console.warn(\n        `[prismic:${config.repository}] Unpublish not fully supported via Migration API. ` +\n        `Document for post \"${post.slug}\" will remain in Prismic.`\n      )\n      \n      return {\n        success: true,\n        externalId: getDocumentId(post),\n      }\n    },\n\n    async onDelete(post: Post): Promise<DestinationResult> {\n      // Prismic Migration API doesn't support deletion directly\n      // For full delete support, use the Document API directly\n      console.warn(\n        `[prismic:${config.repository}] Delete not fully supported via Migration API. ` +\n        `Document for post \"${post.slug}\" will remain in Prismic.`\n      )\n      \n      return {\n        success: true,\n        externalId: getDocumentId(post),\n      }\n    },\n  }\n}\n"],"mappings":"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","names":[]}